<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PunkSwap v6.3 | Offers UI + All Features</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Preconnect to CDNs (reduces connection overhead, helps avoid ERR_INSUFFICIENT_RESOURCES) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://static.network.keeta.com">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind CDN production warning
        if (typeof window !== 'undefined') {
            const originalError = console.error;
            console.error = (...args) => {
                if (args[0] && typeof args[0] === 'string' && args[0].includes('cdn.tailwindcss.com should not be used in production')) {
                    return; // Suppress this specific warning
                }
                originalError.apply(console, args);
            };
        }
    </script>
    <!-- Chart.js - lazy loaded when charts are needed (saves ~200KB on initial load) -->
    <!-- Keeta SDK - critical for wallet/blockchain -->
    <script src="https://static.network.keeta.com/keetanet-browser.js" defer></script>
    
    <style>
        :root {
            --neon-cyan: #00ffff;
            --neon-magenta: #ff00ff;
            --neon-purple: #bc13fe;
            --carbon-bg: #010102;
            --sidebar-bg: #050508;
            --panel-bg: rgba(8, 8, 12, 0.98);
            --slot-bg: rgba(255, 255, 255, 0.01);
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--carbon-bg);
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.01) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.01) 1px, transparent 1px);
            background-size: 60px 60px;
            color: #e2e2e9;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        .sharp-img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            transform: translateZ(0);
            backface-visibility: hidden;
            will-change: transform;
        }

        #sidebar {
            width: 280px;
            background: var(--sidebar-bg);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            position: relative;
        }
        
        /* Mobile: Hide sidebar by default, show hamburger */
        @media (max-width: 768px) {
            #sidebar {
                position: fixed;
                left: -280px;
                top: 0;
                bottom: 0;
                transition: left 0.3s ease;
                z-index: 2000;
            }
            
            #sidebar.mobile-open {
                left: 0;
                box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
            }
            
            #mobileMenuBtn {
                display: flex !important;
            }
            
            #mobileOverlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.7);
                z-index: 1999;
            }
            
            #mobileOverlay.active {
                display: block;
            }
        }
        
        /* Desktop: Always show sidebar */
        @media (min-width: 769px) {
            #mobileMenuBtn {
                display: none !important;
            }
        }

        .sidebar-section-label {
            padding: 1.5rem 2rem 0.5rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.55rem;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 900;
        }

        .nav-item {
            display: flex;
            align-items: center; gap: 1rem; padding: 0.8rem 2rem; color: #555;
            font-family: 'Orbitron', sans-serif; font-size: 0.7rem; font-weight: 700;
            text-transform: uppercase; letter-spacing: 1.5px; transition: all 0.2s ease;
            border-left: 2px solid transparent; cursor: pointer;
        }

        .nav-item:hover { color: var(--neon-cyan); background: rgba(0, 255, 255, 0.02); }
        .nav-item.active {
            color: var(--neon-cyan); background: linear-gradient(90deg, rgba(0, 255, 255, 0.05) 0%, transparent 100%);
            border-left-color: var(--neon-cyan);
        }

        #viewport { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .top-bar {
            height: 80px; border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 3rem; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(15px);
        }
        .content-scroll { flex: 1; overflow-y: auto; padding: 2.5rem; }

        .glass-card { 
            background: var(--panel-bg); 
            border: 1px solid rgba(255, 255, 255, 0.05); 
            border-radius: 1rem;
            overflow: hidden;
        }

        .seed-box {
            background: #000000 !important;
            border: 2px solid #333 !important;
            color: #ffffff !important;
            text-align: center;
            padding: 18px 10px;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            font-size: 16px;
            font-weight: 900;
            outline: none;
            transition: 0.2s;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.9);
        }

        .btn-primary {
            background: rgba(0, 255, 255, 0.03); border: 1px solid var(--neon-cyan); color: var(--neon-cyan);
            padding: 0.75rem 1rem; font-family: 'Orbitron', sans-serif; text-transform: uppercase;
            font-size: 0.7rem; font-weight: 800; border-radius: 0.5rem; transition: all 0.3s; text-align: center;
        }
        .btn-primary:hover:not(:disabled) { background: var(--neon-cyan); color: black; box-shadow: 0 0 20px var(--neon-cyan); }
        .btn-primary:disabled { opacity: 0.2; cursor: not-allowed; }

        .fira { font-family: 'Fira Code', monospace; }
        
        /* Filter Dropdown */
        #filtersDropdown {
            backdrop-filter: blur(20px);
            animation: slideDown 0.2s ease-out;
        }
        
        /* Mobile: Full width dropdown */
        @media (max-width: 768px) {
            #filtersDropdown {
                position: fixed;
                left: 1rem;
                right: 1rem;
                width: auto;
                max-height: 60vh;
            }
            
            .chart-container {
                padding: 1rem;
            }
            
            .chart-stats {
                flex-wrap: wrap;
                gap: 1rem;
            }
            
            .chart-stat {
                flex: 1 1 45%;
                min-width: 120px;
            }
            
            .top-bar {
                padding: 0 1.5rem;
                height: 70px;
            }
            
            .content-scroll {
                padding: 1.5rem;
            }
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .trait-filter-checkbox {
            width: 14px;
            height: 14px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            appearance: none;
            position: relative;
        }
        
        .trait-filter-checkbox:checked {
            background: #00ffff;
            border-color: #00ffff;
        }
        
        .trait-filter-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            top: -2px;
            left: 2px;
            color: #000;
            font-size: 12px;
            font-weight: bold;
        }
        
        .filter-group {
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .filter-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .orbitron { font-family: 'Orbitron', sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }

        .unit-slot {
            aspect-ratio: 1; border: 1px dashed rgba(255,255,255,0.05); border-radius: 1rem;
            background: rgba(255,255,255,0.01); display: flex; align-items: center; justify-content: center;
        }

        .cyber-switch { position: relative; display: inline-block; width: 44px; height: 22px; }
        .cyber-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #111; transition: .4s; border-radius: 34px; border: 1px solid #333; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 4px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--neon-purple); }
        input:checked + .slider:before { transform: translateX(20px); }

        .forge-mini-preview {
            width: 120px; height: 120px; background: #000; border-radius: 1rem; border: 1px solid var(--neon-cyan);
            overflow: hidden; display: flex; align-items: center; justify-content: center;
        }
        .forge-mini-preview img { width: 100%; height: 100%; object-fit: cover; }
        .price-mode-btn {
            padding: 8px 12px; border: 1px solid rgba(255,255,255,0.05); border-radius: 6px;
            font-family: 'Orbitron', sans-serif; font-size: 8px; text-transform: uppercase;
            color: #444; background: rgba(0,0,0,0.4); cursor: pointer; transition: 0.2s;
        }
        .price-mode-btn.active { border-color: var(--neon-cyan); color: var(--neon-cyan); background: rgba(0, 255, 255, 0.05); }
        .debug-log { background: rgba(0,0,0,0.5); border: 1px solid #111; color: #0f0; font-family: 'Fira Code', monospace; font-size: 9px; height: 100px; overflow-y: auto; padding: 10px; border-radius: 8px; margin-top: 10px; }
        
        /* ============================================
           FIX #2: MINT STATUS INDICATOR 
           ============================================ */
        .mint-status-badge {
            position: fixed;
            top: 100px;
            right: 3rem;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 800;
            text-transform: uppercase;
            z-index: 2000;
            animation: slideIn 0.3s ease;
        }
        
        .mint-status-pending {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.5);
            color: orange;
        }
        
        .mint-status-confirmed {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.5);
            color: lime;
        }
        
        .mint-status-failed {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.5);
            color: red;
        }
        
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* ============================================
           FIX #4: INLINE LISTING MODAL
           ============================================ */
        .listing-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* ============================================
           FIX #5: ENHANCED CHART STYLING
           ============================================ */
        .chart-container {
            position: relative;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 20, 40, 0.4) 100%);
            border-radius: 1rem;
            padding: 1.5rem;
            border: 1px solid rgba(0, 255, 255, 0.1);
            box-shadow: inset 0 0 30px rgba(0, 255, 255, 0.05);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(0, 255, 255, 0.15);
        }
        
        .chart-selector {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            outline: none;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .chart-selector:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .chart-selector option {
            background: #000;
            color: var(--neon-cyan);
        }
        
        .chart-stats {
            display: flex;
            gap: 2rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .chart-stat {
            flex: 1;
            text-align: center;
        }
        
        .chart-stat-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            text-transform: uppercase;
            color: #666;
            letter-spacing: 0.15em;
            margin-bottom: 0.25rem;
        }
        
        .chart-stat-value {
            font-family: 'Fira Code', monospace;
            font-size: 1.2rem;
            font-weight: 900;
            color: var(--neon-cyan);
        }
        
        .chart-stat-change {
            font-family: 'Fira Code', monospace;
            font-size: 0.7rem;
            margin-top: 0.25rem;
        }
        
        .chart-stat-change.positive {
            color: #00ff88;
        }
        
        .chart-stat-change.negative {
            color: #ff4466;
        }
        
        .chart-timeframe-selector {
            display: flex;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.4);
            padding: 0.25rem;
            border-radius: 0.5rem;
        }
        
        .chart-timeframe-btn {
            padding: 0.4rem 0.8rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.4rem;
            color: #666;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chart-timeframe-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
            color: var(--neon-cyan);
        }
        
        .chart-timeframe-btn.active {
            background: var(--neon-cyan);
            border-color: var(--neon-cyan);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        .trait-badge {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            padding: 0.65rem 0.75rem;
        }
        
        .traits-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .traits-container.expanded {
            max-height: 500px;
        }
        
        .trait-toggle-btn {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(0, 255, 255, 0.03);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 0.5rem;
            transition: all 0.2s;
            margin-top: 0.75rem;
        }
        
        .trait-toggle-btn:hover {
            background: rgba(0, 255, 255, 0.08);
            border-color: rgba(0, 255, 255, 0.4);
        }
        
        .trait-toggle-icon {
            transition: transform 0.3s ease;
        }
        
        .trait-toggle-icon.rotated {
            transform: rotate(180deg);
        }
        
        /* FIX #8: Prevent image movement during scroll */
        .group {
            contain: layout style;
        }
        
        .group .sharp-img {
            backface-visibility: hidden;
            transform-style: preserve-3d;
            will-change: transform;
            transform: translateZ(0);
        }
        
        .glass-card {
            transform: translateZ(0);
            will-change: transform;
        }
    
        .batch-mint-option {
            display: inline-block;
            margin-left: 8px;
            padding: 4px 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .batch-mint-option:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        </style>
</head>
<body>

    <!-- SIDEBAR -->
    <aside id="sidebar">
        <div class="px-8 py-10">
            <h1 class="orbitron text-xl font-black italic tracking-tighter text-white">
                PUNK<span class="text-cyan-400">SWAP</span>
            </h1>
            <div class="text-[7px] text-gray-600 uppercase tracking-[0.5em] font-bold mt-1">Grid Node v6.3 OFFERS</div>
        </div>

        <div class="profile-header px-8 py-6">
            <div id="profileOffline" class="space-y-4">
                <div class="flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-red-500 animate-pulse"></span>
                    <span class="orbitron text-[8px] text-gray-500 uppercase font-black tracking-widest">Neural Offline</span>
                </div>
                <button onclick="window.initNeuralLink()" class="btn-primary w-full">Initialize Link</button>
            </div>
            
            <div id="profileOnline" class="hidden space-y-4">
                <div class="flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-green-500 shadow-[0_0_10px_#0f0]"></span>
                    <span class="orbitron text-[8px] text-cyan-400 uppercase font-black tracking-widest">Authorized</span>
                </div>
                <div class="bg-white/5 p-3 rounded-lg border border-white/5">
                    <div id="walletAddressDisplay" class="fira text-[9px] text-gray-400 truncate font-bold">---</div>
                </div>
                <button onclick="window.disconnectWallet()" class="w-full text-[8px] orbitron text-gray-600 hover:text-white uppercase font-bold tracking-widest transition-colors">Terminate Session</button>
                <button onclick="window.clearCorruptedSession()" class="w-full text-[7px] orbitron text-red-600 hover:text-red-400 uppercase font-bold tracking-widest transition-colors">
                    üßπ Clear Corrupted Data
                </button>
            </div>
        </div>

        <div class="flex-1 overflow-y-auto no-scrollbar">
            <div class="sidebar-section-label">Public</div>
            <nav class="flex flex-col">
                <div id="nav-market" onclick="window.switchTab('market')" class="nav-item active">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    Explorer
                </div>
            </nav>

            <div class="sidebar-section-label">Personal Hub</div>
            <nav class="flex flex-col">
                <div id="nav-collection" onclick="window.switchTab('collection')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>
                    Neural Vault
                </div>
                <div id="nav-transactions" onclick="window.switchTab('transactions')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>
                    Transaction History
                </div>
                <div id="nav-offers" onclick="window.switchTab('offers')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Offers
                </div>
                <div id="nav-activity" onclick="window.switchTab('activity')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg>
                    Activity Feed
                </div>
            </nav>

            <div class="sidebar-section-label">Protocols</div>
            <nav class="flex flex-col">
                <div id="nav-admin" onclick="window.switchTab('admin')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
                    Forge Hub
                </div>
                <div id="nav-escrow-admin" onclick="window.switchTab('escrow-admin')" class="nav-item hidden text-purple-400">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></svg>
                    Escrow Oversight
                </div>
                <div id="nav-airdrop" onclick="window.switchTab('airdrop')" class="nav-item hidden text-cyan-400">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
                    Airdrop Control
                </div>
            </nav>
        </div>
    </aside>
    
    <!-- Mobile Menu Overlay -->
    <div id="mobileOverlay" onclick="window.toggleMobileMenu()"></div>

    <!-- MAIN VIEWPORT -->
    <main id="viewport">
        <header class="top-bar">
            <div class="flex items-center gap-6">
                <!-- Mobile Hamburger Menu -->
                <button id="mobileMenuBtn" onclick="window.toggleMobileMenu()" class="hidden p-2 rounded-lg border border-cyan-500/30 hover:bg-cyan-500/10 transition-all">
                    <svg class="w-5 h-5 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                    </svg>
                </button>
                
                <span id="viewTitle" class="orbitron text-md font-black uppercase tracking-[0.2em] text-white">Grid Explorer</span>
                <div class="h-4 w-[1px] bg-white/10 hidden md:block"></div>
                <span class="fira text-[9px] text-gray-600 uppercase tracking-widest hidden md:block">Global Pop: <span id="statTotal" class="text-cyan-400">0</span></span>
            </div>

            <div class="flex gap-6 md:gap-12">
                <div class="text-right">
                    <div class="text-[7px] orbitron text-cyan-500 uppercase font-black tracking-widest mb-1 hidden md:block">RESERVE KTA</div>
                    <div id="balanceKTA" class="fira text-sm md:text-lg font-black text-white">0.0000</div>
                </div>
                <div class="text-right">
                    <div class="text-[7px] orbitron text-magenta-500 uppercase font-black tracking-widest mb-1 hidden md:block">RESERVE PUNKS</div>
                    <div id="balancePunks" class="fira text-sm md:text-lg font-black text-white">0</div>
                </div>
            </div>
        </header>

        <div class="content-scroll no-scrollbar">
            
            <section id="tab-market" class="tab-content animate-view space-y-16">
                <div class="glass-card p-10 space-y-6 border border-white/5">
                    <div class="chart-header">
                        <div>
                            <h3 class="orbitron text-xs text-gray-500 uppercase font-black tracking-[0.4em]">Market Depth Analysis</h3>
                            <p class="fira text-[8px] text-gray-700 mt-1 uppercase tracking-wider">Real-time floor price tracking</p>
                        </div>
                        <div class="flex items-center gap-4">
                            <select id="chartCollectionSelector" class="chart-selector" onchange="window.updateMarketChart()">
                                <option value="all">Overall Marketplace</option>
                            </select>
                            <div class="chart-timeframe-selector">
                                <button class="chart-timeframe-btn active" data-timeframe="1h" onclick="window.setChartTimeframe('1h')">1H</button>
                                <button class="chart-timeframe-btn" data-timeframe="24h" onclick="window.setChartTimeframe('24h')">24H</button>
                                <button class="chart-timeframe-btn" data-timeframe="7d" onclick="window.setChartTimeframe('7d')">7D</button>
                                <button class="chart-timeframe-btn" data-timeframe="30d" onclick="window.setChartTimeframe('30d')">30D</button>
                                <button class="chart-timeframe-btn" data-timeframe="all" onclick="window.setChartTimeframe('all')">ALL</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- FIX #5: Enhanced Market Pulse Chart -->
                    <div class="chart-container">
                        <div class="h-64 relative">
                            <canvas id="floorPulseChart"></canvas>
                            <div id="chartLoadingState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs flex items-center gap-2">
                                    <div class="w-4 h-4 border-2 border-cyan-500 border-t-transparent rounded-full animate-spin"></div>
                                    Loading market data...
                                </div>
                            </div>
                            <div id="chartEmptyState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs">No market data yet</div>
                            </div>
                        </div>
                        
                        <div class="chart-stats">
                            <div class="chart-stat">
                                <div class="chart-stat-label">Floor Price</div>
                                <div class="chart-stat-value" id="chartFloorPrice">‚Äî</div>
                                <div class="chart-stat-change" id="chartFloorChange">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">24h Volume</div>
                                <div class="chart-stat-value" id="chart24hVolume">‚Äî</div>
                                <div class="chart-stat-change" id="chartVolumeChange">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Listed</div>
                                <div class="chart-stat-value" id="chartListedCount">‚Äî</div>
                                <div class="chart-stat-change" id="chartListedPercent">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Avg Price</div>
                                <div class="chart-stat-value" id="chartAvgPrice">‚Äî</div>
                                <div class="chart-stat-change" id="chartAvgChange">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex justify-between items-center">
                    <h2 class="orbitron text-3xl font-black uppercase italic tracking-tighter text-white">Trending Collections</h2>
                    <input type="text" id="marketSearch" oninput="window.renderMarketplace()" placeholder="Search Matrix ID..." class="w-80 bg-black/40 border border-white/5 rounded-lg px-4 py-2 fira text-xs text-cyan-400 outline-none focus:border-cyan-500">
                </div>
                
                <div id="collectionListGrid" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-6"></div>

                <div class="pt-16 border-t border-white/5 space-y-8">
                    <h3 class="orbitron text-lg font-black uppercase text-magenta-500 tracking-widest italic">Active Blind Drops</h3>
                    <div id="dropGrid" class="grid grid-cols-1 md:grid-cols-4 gap-6"></div>
                </div>
            </section>

            <!-- COLLECTION PAGE -->
            <section id="tab-collection-view" class="tab-content animate-view hidden space-y-12">
                <button onclick="window.switchTab('market')" class="text-[10px] orbitron text-cyan-400 uppercase font-black hover:text-white transition-colors">‚Üê explorer</button>
                <div id="collectionPageHeader" class="glass-card p-12 flex gap-12 items-center border-l-[10px] border-cyan-500">
                    <div class="w-48 h-48 rounded-2xl bg-black border border-white/10 overflow-hidden shadow-2xl" id="colPageImage"></div>
                    <div class="flex-1 space-y-4">
                        <h2 id="colPageTitle" class="orbitron text-5xl font-black uppercase italic tracking-tighter text-white">---</h2>
                        <p id="colPageDesc" class="fira text-sm text-gray-400 max-w-2xl leading-relaxed italic"></p>
                        <div class="flex gap-10 pt-4 border-t border-white/5">
                            <div><div class="text-[9px] orbitron text-gray-500 uppercase font-black tracking-widest">Creator ID</div><div id="colPageCreator" class="fira text-xs text-cyan-400 font-bold">---</div></div>
                            <div><div class="text-[9px] orbitron text-gray-500 uppercase font-black tracking-widest">Population</div><div id="colPageSupply" class="fira text-xs text-white font-bold">0</div></div>
                            <div><div class="text-[9px] orbitron text-gray-500 uppercase font-black tracking-widest">Floor Price</div><div id="colPageFloor" class="fira text-xs text-cyan-400 font-bold">‚Äî</div></div>
                        </div>
                    </div>
                </div>
                <div class="glass-card p-10">
                    <div class="chart-header">
                        <div>
                            <h3 class="orbitron text-[10px] text-gray-500 uppercase font-black mb-2 tracking-widest">Collection Market Depth</h3>
                            <p class="fira text-[8px] text-gray-700 uppercase tracking-wider">Real-time price & volume analytics</p>
                        </div>
                        <div class="chart-timeframe-selector">
                            <button class="chart-timeframe-btn" data-timeframe="1h" onclick="window.setCollectionChartTimeframe('1h')">1H</button>
                            <button class="chart-timeframe-btn active" data-timeframe="24h" onclick="window.setCollectionChartTimeframe('24h')">24H</button>
                            <button class="chart-timeframe-btn" data-timeframe="7d" onclick="window.setCollectionChartTimeframe('7d')">7D</button>
                            <button class="chart-timeframe-btn" data-timeframe="all" onclick="window.setCollectionChartTimeframe('all')">ALL</button>
                        </div>
                    </div>
                    
                    <div class="chart-container mt-4">
                        <div class="h-64 relative">
                            <canvas id="colPageChart"></canvas>
                            <div id="colChartLoadingState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs flex items-center gap-2">
                                    <div class="w-4 h-4 border-2 border-cyan-500 border-t-transparent rounded-full animate-spin"></div>
                                    Loading collection data...
                                </div>
                            </div>
                            <div id="colChartEmptyState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs">No listing history yet</div>
                            </div>
                        </div>
                        
                        <div class="chart-stats">
                            <div class="chart-stat">
                                <div class="chart-stat-label">Floor</div>
                                <div class="chart-stat-value" id="colChartFloor">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Ceiling</div>
                                <div class="chart-stat-value" id="colChartCeiling">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Volume</div>
                                <div class="chart-stat-value" id="colChartVolume">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Listed</div>
                                <div class="chart-stat-value" id="colChartListed">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Supply</div>
                                <div class="chart-stat-value" id="colChartSupply">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Filters & Sort Controls -->
                <div class="flex justify-between items-center gap-4">
                    <!-- Trait Filters Dropdown -->
                    <div class="relative">
                        <button id="filtersToggleBtn" onclick="window.toggleFiltersDropdown()" class="flex items-center gap-2 px-4 py-2 rounded-lg border border-cyan-500/30 text-sm orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
                            </svg>
                            <span>Filters</span>
                            <span id="filterCount" class="hidden ml-1 px-2 py-0.5 rounded-full bg-cyan-500 text-black text-xs font-black">0</span>
                        </button>
                        
                        <!-- Dropdown Menu -->
                        <div id="filtersDropdown" class="hidden absolute top-full left-0 mt-2 w-80 max-h-96 overflow-y-auto glass-card border border-cyan-500/30 rounded-lg shadow-2xl z-50">
                            <div class="p-4 border-b border-white/10">
                                <div class="flex justify-between items-center">
                                    <h3 class="orbitron text-sm text-cyan-400 uppercase font-black tracking-widest">Trait Filters</h3>
                                    <button onclick="window.clearFilters()" class="text-xs orbitron font-bold uppercase text-red-400 hover:text-red-300">Clear All</button>
                                </div>
                            </div>
                            <div id="traitFilters" class="p-4 space-y-3"></div>
                        </div>
                    </div>
                    
                    <!-- Sort Options -->
                    <div class="flex gap-3">
                        <button onclick="window.setSortMode('rarity')" id="sort-rarity" class="sort-btn text-sm orbitron font-bold uppercase px-4 py-2 rounded-lg border border-white/10 text-gray-400 hover:text-cyan-400 hover:border-cyan-500/30 transition-all">Rarity %</button>
                        <button onclick="window.setSortMode('traits')" id="sort-traits" class="sort-btn text-sm orbitron font-bold uppercase px-4 py-2 rounded-lg border border-white/10 text-gray-400 hover:text-cyan-400 hover:border-cyan-500/30 transition-all">Trait Count</button>
                        <button onclick="window.setSortMode('price')" id="sort-price" class="sort-btn active text-sm orbitron font-bold uppercase px-4 py-2 rounded-lg border border-cyan-500/30 text-cyan-400 bg-cyan-500/5">Price</button>
                    </div>
                </div>
                
                <div id="colPageGrid" class="grid grid-cols-2 md:grid-cols-5 gap-6"></div>
            </section>

            <!-- Personal Modules -->
            <section id="tab-collection" class="tab-content animate-view hidden space-y-8">
                <div id="vaultGate" class="auth-gate glass-card p-16 text-center border-magenta-500/10"><h2 class="orbitron text-2xl font-black uppercase text-magenta-500 mb-6 italic">Vault Encrypted</h2><button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sync</button></div>
                <div id="vaultContainer" class="hidden space-y-8">
                    <div class="flex justify-between items-center">
                        <h2 class="orbitron text-4xl font-black uppercase italic text-magenta-500">Neural Vault</h2>
                        <div class="flex gap-4 items-center">
                            <button onclick="window.toggleMonitoring()" class="btn-primary px-6 flex items-center gap-2">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0zM2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                                <span id="monitoringBtnText">Show Monitoring</span>
                            </button>
                            <button onclick="window.renderCollection()" class="btn-primary px-10">Refresh Storage</button>
                            <button onclick="window.syncWalletNFTs()" class="btn-secondary px-10 ml-3">Sync Wallet</button>
                        </div>
                    </div>
                    
                    <!-- Monitoring Dropdown -->
                    <div id="monitoringDropdown" class="hidden glass-card p-8 border-cyan-500/20 animate-view">
                        <div class="flex justify-between items-center mb-6">
                            <h3 class="orbitron text-lg font-black uppercase text-cyan-400">Monitored NFTs</h3>
                            <span class="fira text-xs text-gray-500" id="monitoredCount">0 monitored</span>
                        </div>
                        <div id="watchlistGrid" class="grid grid-cols-2 md:grid-cols-5 gap-6"></div>
                    </div>
                    
                    <div id="collectionGrid" class="grid grid-cols-2 md:grid-cols-5 gap-6"></div>
                </div>
            </section>

            <!-- TRANSACTION HISTORY TAB -->
            <section id="tab-transactions" class="tab-content animate-view hidden space-y-8">
                <div id="transactionsGate" class="auth-gate glass-card p-16 text-center border-cyan-500/10">
                    <h2 class="orbitron text-2xl font-black uppercase text-cyan-400 mb-4 italic">Transaction Verification</h2>
                    <button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button>
                </div>
                
                <div id="transactionsContainer" class="hidden space-y-8">
                    <div class="glass-card p-12">
                        <div class="flex justify-between items-center mb-8">
                            <div>
                                <h2 class="orbitron text-4xl font-black uppercase italic text-cyan-500">Transaction History</h2>
                                <p class="fira text-sm text-gray-500 mt-2">Complete record of all marketplace activities</p>
                            </div>
                            <button onclick="window.loadTransactions()" class="btn-primary px-8">
                                <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Refresh
                            </button>
                        </div>
                        
                        <!-- Filter Options -->
                        <div class="flex gap-4 mb-6 flex-wrap">
                            <select id="txTypeFilter" onchange="window.filterTransactions()" class="bg-black/60 border border-cyan-500/30 px-4 py-2 rounded-lg text-sm text-cyan-400 font-bold orbitron">
                                <option value="all">All Types</option>
                                <option value="sale">Sales</option>
                                <option value="purchase">Purchases</option>
                                <option value="listing">Listings</option>
                                <option value="cancellation">Cancellations</option>
                                <option value="mint">Mints</option>
                            </select>
                            
                            <select id="txDateFilter" onchange="window.filterTransactions()" class="bg-black/60 border border-cyan-500/30 px-4 py-2 rounded-lg text-sm text-cyan-400 font-bold orbitron">
                                <option value="all">All Time</option>
                                <option value="today">Today</option>
                                <option value="week">This Week</option>
                                <option value="month">This Month</option>
                            </select>
                            
                            <input type="text" id="txSearchInput" oninput="window.filterTransactions()" placeholder="Search by NFT or collection..." class="flex-1 min-w-64 bg-black/60 border border-cyan-500/30 px-4 py-2 rounded-lg text-sm text-cyan-400 font-bold fira outline-none">
                        </div>
                        
                        <!-- Transaction Stats -->
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                            <div class="bg-black/40 p-4 rounded-lg border border-cyan-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">Total Transactions</div>
                                <div id="txTotalCount" class="text-2xl fira font-black text-cyan-400">0</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-green-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">Total Sales</div>
                                <div id="txTotalSales" class="text-2xl fira font-black text-green-400">0 KTA</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">Total Purchases</div>
                                <div id="txTotalPurchases" class="text-2xl fira font-black text-purple-400">0 KTA</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-yellow-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">NFTs Minted</div>
                                <div id="txTotalMints" class="text-2xl fira font-black text-yellow-400">0</div>
                            </div>
                        </div>
                        
                        <!-- Transactions Table -->
                        <div class="bg-black/40 rounded-xl border border-white/5 overflow-hidden">
                            <div class="overflow-x-auto">
                                <table class="w-full">
                                    <thead class="bg-black/60 border-b border-white/10">
                                        <tr>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Date</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Type</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">NFT</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Collection</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Price</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Counter-Party</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Tx Hash</th>
                                        </tr>
                                    </thead>
                                    <tbody id="transactionsTableBody">
                                        <tr>
                                            <td colspan="7" class="p-12 text-center">
                                                <div class="text-gray-500 fira text-sm">No transactions yet</div>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- OFFERS TAB -->
            <section id="tab-offers" class="tab-content animate-view hidden space-y-8">
                <div id="offersGate" class="auth-gate glass-card p-16 text-center border-purple-500/10">
                    <h2 class="orbitron text-2xl font-black uppercase text-purple-400 mb-4 italic">Offers Hub</h2>
                    <p class="fira text-sm text-gray-500 mb-6">Connect wallet to view and manage offers</p>
                    <button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button>
                </div>
                <div id="offersContainer" class="hidden space-y-8">
                    <div class="glass-card p-12">
                        <div class="flex justify-between items-center mb-8">
                            <div>
                                <h2 class="orbitron text-4xl font-black uppercase italic text-purple-500">Offers</h2>
                                <p class="fira text-sm text-gray-500 mt-2">Make offers on NFTs and manage incoming offers</p>
                            </div>
                            <button onclick="window.loadOffers()" class="btn-primary px-8">
                                <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Refresh
                            </button>
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <div class="space-y-4">
                                <h3 class="orbitron text-lg font-bold text-cyan-400 uppercase tracking-widest">Offers on My NFTs</h3>
                                <p class="fira text-xs text-gray-500">Offers others have made on NFTs you own</p>
                                <div id="offersOnMyNFTsList" class="space-y-4 min-h-[120px]">
                                    <p class="text-gray-500 fira text-sm py-8 text-center">No offers on your NFTs yet</p>
                                </div>
                            </div>
                            <div class="space-y-4">
                                <h3 class="orbitron text-lg font-bold text-magenta-400 uppercase tracking-widest">My Offers</h3>
                                <p class="fira text-xs text-gray-500">Offers you have made on others' NFTs</p>
                                <div id="myOffersList" class="space-y-4 min-h-[120px]">
                                    <p class="text-gray-500 fira text-sm py-8 text-center">No offers made yet</p>
                                </div>
                            </div>
                        </div>
                        <div class="mt-8 p-4 bg-cyan-500/10 border border-cyan-500/20 rounded-lg">
                            <p class="fira text-xs text-cyan-300">
                                <strong>How to make an offer:</strong> Go to Explorer ‚Üí click a collection ‚Üí find an unlisted NFT ‚Üí click "üí∞ Make Offer"
                            </p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ACTIVITY FEED PAGE -->
            <section id="tab-activity" class="tab-content animate-view hidden space-y-8">
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <h2 class="orbitron text-4xl font-black uppercase italic text-cyan-400">Activity Feed</h2>
                        <div class="text-xs orbitron text-gray-500 uppercase">Live ‚Ä¢ Last 24 hours</div>
                    </div>
                    <p class="fira text-sm text-gray-400">Real-time marketplace activity</p>
                </div>
                
                <div class="glass-card p-8 space-y-4">
                    <div id="activityFeedContainer" class="space-y-2">
                        <!-- Activity items render here -->
                        <div class="text-center py-12 text-gray-500 fira text-sm">
                            Loading activity...
                        </div>
                    </div>
                </div>
            </section>

            <!-- Admin/Forge Hub -->
            <section id="tab-admin" class="tab-content animate-view hidden space-y-8">
                <div id="adminGate" class="auth-gate glass-card p-16 text-center border-cyan-500/10"><h2 class="orbitron text-2xl font-black uppercase text-cyan-400 mb-4 italic">Administrative Check</h2><button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button></div>
                
                <!-- UI WIPE & RELOAD PANEL -->
                <div id="uiWipePanel" class="hidden glass-card p-8 space-y-6 border-red-500/20">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="orbitron text-xl text-red-400 uppercase font-black italic">‚ö†Ô∏è UI Reset Panel</h3>
                            <p class="fira text-xs text-gray-500 mt-2">Force sync UI with database (use after database wipe)</p>
                        </div>
                        <div class="text-right">
                            <div class="orbitron text-xs text-gray-500 uppercase">Cached Items</div>
                            <div class="orbitron text-2xl text-cyan-400 font-black" id="cachedItemsCount">0</div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-3 gap-4">
                        <div class="bg-black/40 p-4 rounded-lg border border-white/5 text-center">
                            <div class="orbitron text-xs text-gray-500 uppercase mb-2">NFTs</div>
                            <div class="text-2xl text-white font-bold" id="cachedNFTsCount">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-white/5 text-center">
                            <div class="orbitron text-xs text-gray-500 uppercase mb-2">Collections</div>
                            <div class="text-2xl text-white font-bold" id="cachedCollectionsCount">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-white/5 text-center">
                            <div class="orbitron text-xs text-gray-500 uppercase mb-2">Transactions</div>
                            <div class="text-2xl text-white font-bold" id="cachedTransactionsCount">0</div>
                        </div>
                    </div>
                    
                    <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                        <div class="flex items-start gap-3">
                            <span class="text-yellow-500 text-xl">‚ö†Ô∏è</span>
                            <div class="fira text-xs text-yellow-200">
                                <p class="font-bold mb-1">Warning: This will clear all cached UI data</p>
                                <p>Use this when you've wiped the database and need to force the UI to reload fresh data. All Firestore listeners will be reset.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex gap-4">
                        <button onclick="window.wipeUIAndReload(false)" class="flex-1 p-4 rounded-lg border-2 border-cyan-500/30 text-cyan-400 orbitron text-sm font-bold uppercase hover:bg-cyan-500/10 transition-all">
                            üîÑ Soft Reload
                        </button>
                        <button onclick="window.wipeUIAndReload(true)" class="flex-1 p-4 rounded-lg border-2 border-red-500 text-red-400 orbitron text-sm font-bold uppercase hover:bg-red-500/10 transition-all">
                            üí• Hard Wipe & Reload
                        </button>
                    </div>
                    
                    <div class="flex gap-4">
                        <button onclick="window.forceSyncCollections()" class="flex-1 p-3 rounded-lg border border-purple-500/30 text-purple-400 orbitron text-xs font-bold uppercase hover:bg-purple-500/10 transition-all">
                            üîÑ Force Sync Collections
                        </button>
                        <button onclick="window.clearGhostData()" class="flex-1 p-3 rounded-lg border border-orange-500/30 text-orange-400 orbitron text-xs font-bold uppercase hover:bg-orange-500/10 transition-all">
                            üëª Clear Ghost Data
                        </button>
                    </div>
                    
                    <div class="text-center">
                        <button onclick="window.hardRefreshPage()" class="text-xs orbitron text-gray-500 uppercase hover:text-white transition-colors">
                            Or click here for full page refresh (F5)
                        </button>
                    </div>
                </div>
                
                <div id="forgeContainer" class="hidden space-y-10">
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-10">
                        <div class="lg:col-span-2 glass-card p-12 space-y-10">
                            <div class="flex justify-between items-start">
                                <h3 class="orbitron text-2xl text-cyan-400 uppercase font-black italic">Collection Forge Hub</h3>
                                <div class="forge-mini-preview" id="previewImageContainer"></div>
                            </div>
                            <div class="space-y-6">
                                <input type="text" id="collectionTitleInput" placeholder="COLLECTION TITLE (Required - e.g., 'Series Protocol Alpha')" class="w-full bg-black/60 border border-cyan-500/30 p-5 rounded-xl fira text-sm text-cyan-400 outline-none font-bold">
                                
                                <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                                    <span class="text-[8px] orbitron text-cyan-400 uppercase font-black block mb-3">Collection Type</span>
                                    <div class="flex gap-3">
                                        <label class="flex-1 cursor-pointer">
                                            <input type="radio" name="collectionType" value="external_ipfs" checked class="hidden peer">
                                            <div class="p-3 rounded-lg border border-white/10 peer-checked:border-cyan-500 peer-checked:bg-cyan-500/10 transition-all">
                                                <div class="orbitron text-xs font-bold text-white">External IPFS</div>
                                                <div class="fira text-[9px] text-gray-500 mt-1">Bueno/Pinata metadata</div>
                                            </div>
                                        </label>
                                    </div>
                                </div>
                                
                                <input type="text" id="batchFolderCid" placeholder="IPFS PROTOCOL CID (bafy...)" class="w-full bg-black/60 border border-white/5 p-5 rounded-xl fira text-xs text-cyan-400 outline-none">
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                                        <span class="text-[8px] orbitron text-cyan-400 uppercase font-black block mb-2">Total Supply</span>
                                        <input type="number" id="totalSupplyInput" value="10" min="1" max="1000" class="w-full bg-transparent fira text-lg font-bold outline-none text-white">
                                    </div>
                                    <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                                        <span class="text-[8px] orbitron text-orange-400 uppercase font-black block mb-2">Max Per Wallet</span>
                                        <input type="number" id="maxMintsPerWalletInput" value="1" min="1" max="10" class="w-full bg-transparent fira text-lg font-bold outline-none text-white">
                                    </div>
                                </div>
                                <textarea id="collectionDescInput" placeholder="Narrative summary for this unit series..." class="w-full h-24 bg-black/40 border border-white/5 p-4 rounded-xl fira text-xs text-gray-500 outline-none resize-none"></textarea>
                                <input type="text" id="collectionThumbnailInput" placeholder="Collection Thumbnail CID (The Grid Icon)..." class="w-full bg-black/60 border border-white/5 p-4 rounded-xl fira text-xs text-white outline-none">

                                <div class="flex justify-between items-center">
                                    <div class="flex gap-2" id="priceModeMatrix">
                                        <button onclick="window.setPriceMode('kta')" id="mode-kta" class="price-mode-btn active">KTA Only</button>
                                        <button onclick="window.setPriceMode('punks')" id="mode-punks" class="price-mode-btn">PUNKS Only</button>
                                        <button onclick="window.setPriceMode('hybrid')" id="mode-hybrid" class="price-mode-btn">Hybrid</button>
                                    </div>
                                    <div class="flex items-center gap-4">
                                        <span class="orbitron text-[10px] text-gray-500 uppercase font-black">Blind Mint</span>
                                        <label class="cyber-switch"><input type="checkbox" id="enableDropMode" checked><span class="slider"></span></label>
                                    </div>
                                </div>
                                
                                <!-- WHITELIST FEATURE -->
                                <div class="p-6 bg-gradient-to-br from-cyan-900/10 to-purple-900/10 rounded-xl border border-cyan-500/20 space-y-4">
                                    <div class="flex items-center justify-between">
                                        <div class="flex items-center gap-4">
                                            <span class="orbitron text-sm text-cyan-400 uppercase font-bold">Enable Whitelist</span>
                                            <label class="cyber-switch">
                                                <input type="checkbox" id="enableWhitelist" onchange="window.toggleWhitelistUI()">
                                                <span class="slider"></span>
                                            </label>
                                        </div>
                                        <span class="fira text-xs text-gray-500" id="whitelistCount">0 addresses</span>
                                    </div>
                                    
                                    <div id="whitelistInputContainer" class="hidden space-y-4 animate-view">
                                        <div>
                                            <label class="block text-[9px] orbitron text-cyan-400 uppercase font-black mb-2">Whitelisted Wallet Addresses</label>
                                            <textarea id="whitelistAddresses" rows="6" placeholder="keeta_aab5o4wtbzgfvrsxntftzsecq2l7daek2mzsbni6fc43et5v7r4ihgpn4pv3nra&#10;keeta_another_address_here&#10;keeta_..." class="w-full bg-black/60 border border-cyan-500/20 p-4 rounded-xl fira text-xs text-white outline-none focus:border-cyan-500 font-mono" oninput="window.updateWhitelistCount()"></textarea>
                                            <div class="fira text-[9px] text-gray-500 mt-2">Enter one Keeta wallet address per line. Only these wallets will be able to mint.</div>
                                        </div>
                                        
                                        <div class="flex gap-3">
                                            <button onclick="window.validateWhitelist()" class="flex-1 p-3 rounded-lg border border-cyan-500/30 text-[9px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                                                ‚úì Validate Addresses
                                            </button>
                                            <button onclick="window.importWhitelistCSV()" class="flex-1 p-3 rounded-lg border border-purple-500/30 text-[9px] orbitron font-bold uppercase text-purple-400 hover:bg-purple-500/10 transition-all">
                                                üìÑ Import CSV
                                            </button>
                                            <button onclick="window.clearWhitelist()" class="flex-1 p-3 rounded-lg border border-red-500/30 text-[9px] orbitron font-bold uppercase text-red-400 hover:bg-red-500/10 transition-all">
                                                √ó Clear All
                                            </button>
                                        </div>
                                        
                                        <div id="whitelistStatus" class="hidden p-3 rounded-lg border"></div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-6">
                                    <div id="ktaInputBox" class="bg-black/60 p-5 rounded-xl border border-white/5">
                                        <span class="text-[8px] orbitron text-cyan-400 uppercase font-black">KTA Base Price</span>
                                        <input type="number" id="batchPriceKTA" value="1.0" step="0.1" class="w-full bg-transparent fira text-xl font-bold outline-none text-white mt-1">
                                    </div>
                                    <div id="punksInputBox" class="bg-black/60 p-5 rounded-xl border border-white/5 opacity-20">
                                        <span class="text-[8px] orbitron text-magenta-400 uppercase font-black">PUNKS Base Price</span>
                                        <input type="number" id="batchPricePunks" value="1000" class="w-full bg-transparent fira text-xl font-bold outline-none text-white mt-1">
                                    </div>
                                </div>
                                
                                <!-- CREATOR ROYALTY PERCENTAGE -->
                                <div class="bg-gradient-to-br from-green-900/20 to-emerald-900/20 p-6 rounded-xl border border-green-500/30 space-y-3">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <span class="text-sm orbitron text-green-400 uppercase font-bold block">Creator Royalty %</span>
                                            <span class="text-[9px] fira text-gray-500 block mt-1">You earn this % on every secondary sale</span>
                                        </div>
                                        <div class="text-right">
                                            <span class="text-3xl orbitron text-green-400 font-black" id="royaltyDisplay">5.0</span>
                                            <span class="text-lg orbitron text-green-400">%</span>
                                        </div>
                                    </div>
                                    <input type="range" id="creatorRoyaltyPercent" min="0" max="20" step="0.5" value="5" 
                                           class="w-full h-2 bg-black/60 rounded-lg appearance-none cursor-pointer accent-green-500"
                                           oninput="document.getElementById('royaltyDisplay').textContent = this.value; document.getElementById('royaltyExample').textContent = this.value">
                                    <div class="flex justify-between text-[8px] fira text-gray-500">
                                        <span>0% (No Royalty)</span>
                                        <span class="text-yellow-400">5% (Default)</span>
                                        <span>10% (Premium)</span>
                                        <span>20% (Max)</span>
                                    </div>
                                    <div class="bg-black/40 p-3 rounded-lg border border-green-500/20">
                                        <div class="fira text-[9px] text-gray-400 space-y-1">
                                            <div class="flex justify-between">
                                                <span>If NFT sells for 100 KTA:</span>
                                                <span class="text-white font-bold"></span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span>‚Ä¢ Seller gets:</span>
                                                <span class="text-cyan-400 font-bold">92 KTA (92%)</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span>‚Ä¢ You (creator) get:</span>
                                                <span class="text-green-400 font-bold"><span id="royaltyExample">5</span> KTA</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span>‚Ä¢ Marketplace gets:</span>
                                                <span class="text-purple-400 font-bold">3 KTA (3%)</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button onclick="window.scanCollectionFolder()" class="btn-primary py-5 text-sm w-full">Validate Protocol Matrix</button>
                                <div id="forgeReadyArea" class="hidden animate-view"><button id="startForgeBtn" onclick="window.createBlindMintCollection()" class="btn-primary py-10 text-xl border-orange-500 text-orange-500 border-2 w-full">Deploy Blind Mint Collection</button></div>
                            </div>
                        </div>
                        <div class="space-y-8">
                            <!-- Whitelist Settings Panel -->
                            <div class="glass-card p-10 space-y-6 border-purple-500/20">
                                <div class="flex justify-between items-center">
                                    <h4 class="orbitron text-[10px] text-purple-500 font-bold uppercase tracking-widest">Whitelist Settings</h4>
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="whitelistEnabled" class="w-4 h-4 accent-purple-500" onchange="window.toggleWhitelistSettingsUI()">
                                        <span class="fira text-xs text-gray-400">Enable Whitelist</span>
                                    </label>
                                </div>
                                
                                <div id="whitelistControls" class="hidden space-y-6">
                                    <!-- Whitelist Mode -->
                                    <div>
                                        <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Whitelist Mode</label>
                                        <select id="whitelistMode" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none">
                                            <option value="BLIND_MINT">Blind Mint Only</option>
                                            <option value="STANDARD_MINT">Standard Mint Only</option>
                                            <option value="BOTH">Both Mint Types</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Mint Window -->
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Window Start</label>
                                            <input type="datetime-local" id="whitelistStart" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none">
                                        </div>
                                        <div>
                                            <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Window End</label>
                                            <input type="datetime-local" id="whitelistEnd" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none">
                                        </div>
                                    </div>
                                    
                                    <!-- Default Max Mints -->
                                    <div>
                                        <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Default Max Mints per Wallet</label>
                                        <input type="number" id="whitelistDefaultMax" value="1" min="1" max="10" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none">
                                    </div>
                                    
                                    <!-- WHITELIST PHASES WITH CUSTOM PRICING -->
                                    <div class="bg-gradient-to-br from-purple-900/20 to-pink-900/20 p-6 rounded-xl border border-purple-500/30 space-y-4">
                                        <div class="flex items-center justify-between">
                                            <h5 class="orbitron text-[9px] text-purple-400 uppercase font-black">Whitelist Phases (Custom Pricing)</h5>
                                            <button onclick="window.addWhitelistPhase()" class="text-xs px-3 py-1 rounded bg-purple-500/20 text-purple-400 hover:bg-purple-500/30 transition-all orbitron font-bold">+ Add Phase</button>
                                        </div>
                                        <p class="fira text-[10px] text-gray-500">Create multiple whitelist phases with different pricing per phase</p>
                                        
                                        <div id="whitelistPhasesContainer" class="space-y-3">
                                            <!-- Phases will be added here -->
                                        </div>
                                        
                                        <div class="bg-cyan-500/10 border border-cyan-500/20 rounded-lg p-3">
                                            <p class="fira text-[9px] text-cyan-300">
                                                üí° <strong>Example:</strong> Phase 1 (OG): 0.5 KTA | Phase 2 (Early): 1 KTA | Phase 3 (Public): 2 KTA
                                            </p>
                                        </div>
                                    </div>
                                    
                                    <!-- Manual Entry -->
                                    <div class="bg-black/40 p-6 rounded-lg border border-white/5">
                                        <h5 class="orbitron text-[9px] text-cyan-400 uppercase font-black mb-4">Add Wallet Manually</h5>
                                        <div class="flex gap-3 mb-4">
                                            <input type="text" id="whitelistWallet" placeholder="Keeta wallet address..." class="flex-1 bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-2 text-white fira text-xs outline-none">
                                            <input type="number" id="whitelistMaxMints" value="1" min="1" max="10" class="w-20 bg-black/60 border border-cyan-500/30 rounded-lg px-3 py-2 text-white fira text-xs outline-none">
                                            <button onclick="window.addWhitelistWallet()" class="btn-primary px-6 text-xs">+ Add</button>
                                        </div>
                                    </div>
                                    
                                    <!-- CSV/JSON Upload -->
                                    <div class="bg-black/40 p-6 rounded-lg border border-white/5">
                                        <h5 class="orbitron text-[9px] text-orange-400 uppercase font-black mb-4">Bulk Upload (CSV/JSON)</h5>
                                        <input type="file" id="whitelistFileUpload" accept=".csv,.json" class="hidden" onchange="window.handleWhitelistUpload(event)">
                                        <button onclick="document.getElementById('whitelistFileUpload').click()" class="w-full p-4 rounded-lg border border-orange-500/30 text-orange-400 orbitron text-xs font-bold uppercase hover:bg-orange-500/10 transition-all">
                                            üìÅ Upload Whitelist File
                                        </button>
                                        <p class="fira text-[10px] text-gray-600 mt-2">CSV: wallet_address,max_mints | JSON: [{wallet, max_mints}]</p>
                                    </div>
                                    
                                    <!-- Whitelist Table -->
                                    <div class="bg-black/40 p-6 rounded-lg border border-white/5">
                                        <div class="flex justify-between items-center mb-4">
                                            <h5 class="orbitron text-[9px] text-cyan-400 uppercase font-black">Whitelisted Wallets (<span id="whitelistCount">0</span>)</h5>
                                            <button onclick="window.clearWhitelist()" class="text-red-400 fira text-[10px] hover:text-red-300">Clear All</button>
                                        </div>
                                        <div id="whitelistTable" class="max-h-64 overflow-y-auto space-y-2">
                                            <div class="text-center text-gray-600 fira text-xs py-8">No wallets added yet</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Warnings -->
                                    <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                                        <div class="flex items-start gap-3">
                                            <span class="text-yellow-500 text-xl">‚ö†Ô∏è</span>
                                            <div class="fira text-[10px] text-yellow-200 space-y-1">
                                                <p>‚Ä¢ Whitelist affects access only, not rarity or NFT assignment</p>
                                                <p>‚Ä¢ Blind mint outcomes remain completely random</p>
                                                <p>‚Ä¢ Public mint resumes when whitelist is disabled</p>
                                                <p>‚Ä¢ You cannot bypass mint logic or assign specific NFTs</p>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Save Button -->
                                    <button onclick="window.saveWhitelistSettings()" class="btn-primary w-full py-4">üíæ Save Whitelist Settings</button>
                                </div>
                            </div>
                            
                            <div id="escrowDiagnostics" class="glass-card p-10 space-y-6 hidden">
                                <h4 class="orbitron text-[10px] text-orange-500 font-bold uppercase tracking-widest">Escrow Diagnostics</h4>
                                <button onclick="window.runNeuralRepair()" class="w-full p-4 rounded-xl border border-purple-500/20 text-[9px] orbitron font-bold uppercase text-purple-400 hover:bg-purple-500/5 transition-all text-center">Neural Sync Recovery</button>
                                <div id="previewDetails" class="hidden p-4 bg-black/40 rounded-xl fira text-[10px]"><div class="flex justify-between"><span>POPULATION:</span><span id="previewCount">0</span></div></div>
                            </div>
                            <div id="escrowMaintenanceProtocol" class="glass-card p-10 border-red-500/20 bg-red-500/5 animate-view hidden">
                                <h4 class="orbitron text-[9px] text-red-500 font-black uppercase mb-4 tracking-widest">Admin Wipe Protocol</h4>
                                <div id="wipeStage1"><button onclick="window.prepWipe()" class="w-full p-4 border border-red-500/20 text-[9px] text-red-500 orbitron uppercase font-black hover:bg-red-500/10 transition-all">Database Purge</button></div>
                                <div id="wipeStage2" class="hidden flex gap-2"><button onclick="window.clearAllNFTs()" class="btn-primary flex-1 !border-red-500 !text-red-500 font-black">Confirm Wipe</button><button onclick="window.resetWipe()" class="flex-1 text-[9px] orbitron font-bold text-gray-500 uppercase">Abort</button></div>
                            </div>
                        </div>
                    </div>
                    <div id="batchProgress" class="hidden glass-card p-8 space-y-6 border-cyan-500/20"><div class="flex justify-between fira text-xs font-bold uppercase"><span id="batchStatusMsg" class="text-cyan-400 animate-pulse">Forging...</span><span id="batchPercent">0%</span></div><div class="w-full bg-black/60 h-1 rounded-full overflow-hidden border border-white/5"><div id="batchProgressInner" class="bg-gradient-to-r from-cyan-500 to-purple-500 h-full transition-all duration-300"></div></div><div id="neuralDebugLog" class="debug-log"></div></div>
                </div>
            </section>
        </div>
    </main>

    <!-- Sign-In Modal -->
    <div id="seedModal" class="fixed inset-0 bg-black/95 backdrop-blur-3xl hidden z-[2000] flex items-center justify-center p-12">
        <div class="glass-card p-16 max-w-5xl w-full border-cyan-500/20 shadow-2xl">
            <h2 class="orbitron text-4xl font-black uppercase text-center text-cyan-400 tracking-tighter mb-4 italic">Neural Identity Hub</h2>
            <p class="text-center fira text-[10px] text-gray-600 mb-10 uppercase tracking-widest font-black italic">Matrix Seed Input Required</p>
            <div id="seedGrid" class="grid grid-cols-3 md:grid-cols-6 gap-4 mb-10"></div>
            <div class="flex gap-4 justify-center">
                <button onclick="window.importWallet()" class="btn-primary py-4 px-20 text-lg">Synchronize Link</button>
                <button onclick="window.closeModal('seedModal')" class="text-[9px] orbitron text-gray-700 hover:text-white font-black uppercase tracking-widest px-10 transition-colors">Abort</button>
            </div>
        </div>
    </div>

    <!-- FIX #4: Inline Listing Modal -->
    <div id="listingModal" class="listing-modal-overlay hidden">
        <div class="glass-card p-12 max-w-3xl w-full border-cyan-500/20 shadow-2xl">
            <div class="flex justify-between items-start mb-8">
                <h2 class="orbitron text-2xl font-black uppercase text-cyan-400 tracking-tighter">List NFT for Sale</h2>
                <button onclick="window.closeListingModal()" class="text-gray-500 hover:text-white transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            <div class="grid grid-cols-2 gap-8 mb-8">
                <div>
                    <div id="listingNFTPreview" class="w-full aspect-square bg-black/40 rounded-xl border border-white/10 mb-4 overflow-hidden"></div>
                    <h3 id="listingNFTName" class="orbitron text-lg font-bold text-white mb-2">---</h3>
                    <div id="listingNFTTraits" class="space-y-2"></div>
                </div>
                
                <div class="space-y-6">
                    <div>
                        <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Select Currency</label>
                        <div class="flex gap-3">
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="listingCurrency" value="KTA" checked class="hidden peer" onchange="window.updateFeeBreakdown()">
                                <div class="p-4 rounded-lg border-2 border-cyan-500/30 bg-cyan-500/5 peer-checked:border-cyan-500 peer-checked:bg-cyan-500/20 transition-all text-center hover:border-cyan-500/50">
                                    <div class="orbitron text-sm font-bold text-cyan-400">KTA</div>
                                    <div class="fira text-[9px] text-gray-500 mt-1">Keeta Token</div>
                                </div>
                            </label>
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="listingCurrency" value="PUNKS" class="hidden peer" onchange="window.updateFeeBreakdown()">
                                <div class="p-4 rounded-lg border-2 border-magenta-500/30 bg-magenta-500/5 peer-checked:border-magenta-500 peer-checked:bg-magenta-500/20 transition-all text-center hover:border-magenta-500/50">
                                    <div class="orbitron text-sm font-bold text-magenta-400">PUNKS</div>
                                    <div class="fira text-[9px] text-gray-500 mt-1">Punk Token</div>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <div>
                        <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Listing Price</label>
                        <input type="number" id="listingPriceInput" step="0.1" min="0" placeholder="Enter price..." class="w-full bg-black/60 border border-white/5 p-4 rounded-xl fira text-xl text-cyan-400 outline-none font-bold focus:border-cyan-500" oninput="window.updateFeeBreakdown()">
                    </div>
                    
                    <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                        <div class="text-[9px] orbitron text-gray-500 uppercase font-black mb-3">Fee Breakdown</div>
                        <div class="space-y-2 fira text-xs">
                            <div class="flex justify-between">
                                <span class="text-gray-400">You receive</span>
                                <span id="sellerPayout" class="text-white font-bold">0.00</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">Creator royalty (<span id="royaltyPercent">5.0</span>%)</span>
                                <span id="creatorRoyalty" class="text-cyan-400 font-bold">0.00</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">Marketplace fee (3%)</span>
                                <span id="marketplaceFee" class="text-purple-400 font-bold">0.00</span>
                            </div>
                        </div>
                    </div>
                    
                    <button onclick="window.confirmListing()" class="btn-primary w-full py-4 text-sm">Confirm Listing</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- AIRDROP ADMIN PANEL -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <section id="tab-airdrop" class="tab-content animate-view hidden space-y-8">
        <!-- Passcode Protection -->
        <div id="airdropPasscodeGate" class="flex items-center justify-center min-h-[60vh]">
            <div class="glass-card p-8 max-w-md w-full">
                <div class="text-center mb-6">
                    <div class="text-6xl mb-4">üîí</div>
                    <h2 class="orbitron text-2xl font-bold text-white mb-2">Airdrop Access</h2>
                    <p class="fira text-sm text-gray-400">Enter passcode to access airdrop controls</p>
                </div>
                
                <div class="space-y-4">
                    <input type="password" id="airdropPasscodeInput" placeholder="Enter passcode" 
                        class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white fira text-center text-lg outline-none focus:border-cyan-500 font-mono"
                        onkeypress="if(event.key === 'Enter') window.verifyAirdropPasscode()">
                    
                    <button onclick="window.verifyAirdropPasscode()" class="btn-primary w-full py-3">
                        üîì Unlock Airdrop
                    </button>
                    
                    <p id="airdropPasscodeError" class="text-red-400 text-sm text-center hidden"></p>
                </div>
            </div>
        </div>

        <!-- Airdrop Content (Hidden until unlocked) -->
        <div id="airdropContent" class="hidden">
        <div class="flex items-center justify-between mb-8">
            <div>
                <h2 class="orbitron text-2xl font-bold text-white mb-2">üéÅ Airdrop Control</h2>
                <p class="fira text-sm text-gray-400">Send pre-owned NFTs to their rightful owners</p>
                <p class="fira text-xs text-yellow-500 mt-1">‚ö†Ô∏è Only for non-blind-mint collections</p>
            </div>
        </div>

        <!-- Collection Selector -->
        <div class="glass-card p-6">
            <h3 class="orbitron text-lg font-bold text-cyan-400 mb-4">Select Collection</h3>
            <select id="airdropCollectionSelect" onchange="window.loadAirdropCollection()" class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-cyan-500">
                <option value="">-- Select a collection --</option>
            </select>
            <div id="airdropCollectionInfo" class="hidden mt-4 p-4 bg-cyan-500/10 border border-cyan-500/30 rounded-lg">
                <div class="flex justify-between items-center">
                    <div>
                        <p class="orbitron text-sm text-cyan-400 font-bold" id="airdropCollectionName"></p>
                        <p class="fira text-xs text-gray-400 mt-1">
                            <span id="airdropMintedCount">0</span>/<span id="airdropTotalSupply">0</span> Minted | 
                            <span id="airdropRemainingSupply">0</span> Remaining
                        </p>
                    </div>
                    <div class="text-right">
                        <p class="text-xs text-gray-500">Your Collection</p>
                        <p class="text-xs text-green-400 font-mono" id="airdropCreatorAddress"></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Airdrop Options -->
        <div id="airdropOptionsSection" class="hidden space-y-6">
            <!-- Single Airdrop -->
            <div class="glass-card p-6">
                <h3 class="orbitron text-lg font-bold text-purple-400 mb-4">Single Airdrop</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-xs orbitron text-gray-400 uppercase font-bold mb-2">Recipient Wallet Address</label>
                        <input type="text" id="airdropRecipient" placeholder="keeta_aab5o4wtbzgfvrsxntftzsecq2l7daek2mzsbni6fc43et5v7r4ihgpn4pv3nra" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-purple-500 font-mono">
                    </div>
                    
                    <div>
                        <label class="block text-xs orbitron text-gray-400 uppercase font-bold mb-2">NFT Number (Which NFT to send)</label>
                        <input type="number" id="airdropNFTNumber" min="1" placeholder="1" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-purple-500">
                        <p class="text-xs text-gray-500 mt-1" id="singleNFTHelp">
                            Enter the NFT number: 1-256<br>
                            NFT #1 = 001.json, NFT #2 = 002.json, etc.
                        </p>
                    </div>

                    <button onclick="window.executeSingleAirdrop()" class="btn-primary w-full py-4">
                        üéÅ Send Specific NFT to Owner
                    </button>
                </div>
            </div>

            <!-- Batch Airdrop -->
            <div class="glass-card p-6">
                <h3 class="orbitron text-lg font-bold text-cyan-400 mb-4">Batch Airdrop (CSV)</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-xs orbitron text-gray-400 uppercase font-bold mb-2">CSV Format: wallet_address, nft_number</label>
                        <textarea id="batchAirdropAddresses" rows="6" placeholder="keeta_aab5o4wt..., 1&#10;keeta_aabjzmx5..., 2&#10;keeta_another..., 3" class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-cyan-500 font-mono"></textarea>
                        <p class="text-xs text-gray-400 mt-1">Each line: wallet address, NFT number <span id="batchNFTRange">(1-256)</span></p>
                        <p class="text-xs text-gray-500 mt-1">NFT #1 = 001.json, NFT #2 = 002.json, etc.</p>
                    </div>

                    <div class="flex gap-4">
                        <button onclick="window.importAirdropCSV()" class="flex-1 border border-cyan-500/30 rounded-lg px-4 py-3 text-cyan-400 text-sm hover:bg-cyan-500/10 transition">
                            üìÑ Import CSV
                        </button>
                        <button onclick="window.validateAirdropAddresses()" class="flex-1 border border-purple-500/30 rounded-lg px-4 py-3 text-purple-400 text-sm hover:bg-purple-500/10 transition">
                            ‚úì Validate
                        </button>
                    </div>

                    <div id="batchAirdropStatus" class="hidden p-4 rounded-lg border"></div>

                    <button onclick="window.executeBatchAirdrop()" class="btn-primary w-full py-4">
                        üéÅ Send to All Owners (<span id="batchAirdropCount">0</span> NFTs)
                    </button>
                </div>
            </div>

            <!-- Airdrop History -->
            <div class="glass-card p-6">
                <h3 class="orbitron text-lg font-bold text-green-400 mb-4">Airdrop History</h3>
                <div id="airdropHistoryList" class="space-y-2">
                    <p class="text-sm text-gray-500 text-center py-8">No airdrops yet</p>
                </div>
            </div>
        </div>
        </div> <!-- End airdropContent -->
    </section>

    <script type="module">
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIREBASE INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, deleteDoc, onSnapshot, getDocs, query, where, orderBy, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBe_G4Es-1UrPx_0unnByq2VsiSEKRj0GU",
            authDomain: "punkswap-production.firebaseapp.com",
            projectId: "punkswap-production",
            storageBucket: "punkswap-production.firebasestorage.app",
            messagingSenderId: "897835219222",
            appId: "1:897835219222:web:a65f92db25cd8861d0b837"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        console.log("üî• Firebase initialized - ALL 5 FIXES APPLIED");

        window.db = db;

        async function testFirebaseConnection() {
            try {
                const userCredential = await signInAnonymously(auth);
                console.log("‚úÖ Firebase Auth: CONNECTED");
                const testDocRef = doc(db, 'test', 'connection');
                await setDoc(testDocRef, {
                    timestamp: new Date().toISOString(),
                    status: 'connected',
                    version: 'v17.8.1-FIXED'
                });
                console.log("‚úÖ Firebase Firestore: CONNECTED");
                window.notify("Firebase Connected Successfully", "success");
                return true;
            } catch (error) {
                console.error("‚ùå Firebase connection failed:", error);
                window.notify("Firebase Connection Error: " + error.message, "error");
                return false;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GLOBAL STATE & CONSTANTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const state = { 
            appId: 'punkswap-pro-auth-v16',
            keetaClient: null, 
            keetaAccount: null, 
            user: null, 
            address: null, 
            nfts: [], 
            collections: [],
            traitCounts: {},
            balanceKTA: 0, 
            balancePunks: 0, 
            scannedFiles: [], 
            watchlist: [],
            escrowAccount: null, 
            escrowClient: null, 
            escrowAddress: null,
            priceMode: 'kta', 
            pulseChart: null, 
            colPageChart: null, 
            viewingCollection: null,
            isForging: false,
            firebaseReady: false,
            mintStatus: null,
            listingNFT: null,
            marketPulseData: [],
            chartTimeframe: '24h',
            collectionChartTimeframe: '24h',
            selectedChartCollection: 'all',
            marketHistory: [],
            chartUpdateInterval: null,
            transactions: [], // User's transaction history
            allTransactions: [], // Unfiltered transactions
            collectionFilters: {},
            sortMode: 'price',
            // WHITELIST STATE
            whitelistSettings: {},      // collectionId -> settings
            whitelistWallets: {},        // collectionId -> [wallets]
            editingWhitelist: null,      // current collection being edited
            // Offer system
            offers: [],
            myOffers: [],
            offersOnMyNFTs: []
        };
        
        window.state = state;

        // Lazy-load Chart.js (saves ~200KB on initial page load, reduces ERR_INSUFFICIENT_RESOURCES)
        window.loadChartJs = () => {
            if (window.Chart) return Promise.resolve();
            if (window._chartJsLoadPromise) return window._chartJsLoadPromise;
            window._chartJsLoadPromise = new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/chart.js';
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('Chart.js load failed'));
                document.head.appendChild(s);
            });
            return window._chartJsLoadPromise;
        };

        const KTA_DECIMALS = 1e9; 
        const ESCROW_SEED = "bless hard pride spike rule record style wonder theme glue female rival jeans south alter melt protect stereo siren arrow shy body deputy mesh";
        
        const MARKETPLACE_FEE_WALLET = "keeta_aab5o4wtbzgfvrsxntftzsecq2l7daek2mzsbni6fc43et5v7r4ihgpn4pv3nra";
        const PRIMARY_SALE_CREATOR_PERCENT = 0.90;
        const PRIMARY_SALE_MARKETPLACE_PERCENT = 0.10;
        const SECONDARY_SALE_SELLER_PERCENT = 0.92;
        const SECONDARY_SALE_CREATOR_ROYALTY_PERCENT = 0.05;
        const SECONDARY_SALE_MARKETPLACE_PERCENT = 0.03;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TAB SWITCHING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Toggle mobile menu
        window.toggleMobileMenu = () => {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobileOverlay');
            
            if (sidebar && overlay) {
                sidebar.classList.toggle('mobile-open');
                overlay.classList.toggle('active');
            }
        };
        
        window.switchTab = (tabName) => {
            // Close mobile menu if open
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobileOverlay');
            if (sidebar && overlay) {
                sidebar.classList.remove('mobile-open');
                overlay.classList.remove('active');
            }
            
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            
            // Remove active state from all nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show selected tab
            const selectedTab = document.getElementById(`tab-${tabName}`);
            if (selectedTab) {
                selectedTab.classList.remove('hidden');
            }
            
            // Set active nav item
            const navItem = document.getElementById(`nav-${tabName}`);
            if (navItem) {
                navItem.classList.add('active');
            }
            
            // Load data for specific tabs
            if (tabName === 'market') {
                window.renderMarketplace();
                setTimeout(() => window.updateFloorPulse(), 100);
            } else if (tabName === 'collection') {
                window.renderCollection();
            } else if (tabName === 'offers' && state.address) {
                window.loadOffers();
                window.renderOffers();
            } else if (tabName === 'activity') {
                window.renderActivityFeed();
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // HELPER FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function getNormalizedId(t) {
            if (!t) return "";
            try {
                if (typeof t === 'string') return t.toLowerCase().trim();
                if (t.publicKeyString) return (typeof t.publicKeyString === 'string' ? t.publicKeyString : t.publicKeyString.get()).toLowerCase().trim();
                if (t.account?.publicKeyString) return (typeof t.account.publicKeyString === 'string' ? t.account.publicKeyString : t.account.publicKeyString.get()).toLowerCase().trim();
            } catch (e) {}
            return t.toString().toLowerCase().trim();
        }

        // Resolve NFT imageCid to full IPFS path (handles relative paths like images/004.png)
        // Returns the CID path for use with any gateway: https://gateway.pinata.cloud/ipfs/${path}
        window.getNFTImagePath = (n) => {
            const cid = n?.imageCid || '';
            if (!cid) return '';
            if (cid.startsWith('bafybei') || cid.startsWith('Qm')) return cid;
            const col = state.collections?.find(c => (c.collectionId || c.id) === (n?.collectionId || n?.id) || getNormalizedId(c.collectionToken) === getNormalizedId(n?.collectionToken));
            const ipfsCid = col?.ipfsCid;
            if (ipfsCid) {
                return cid.startsWith('images/') ? `${ipfsCid}/${cid}` : cid.includes('/') ? `${ipfsCid}/${cid}` : `${ipfsCid}/images/${cid}`;
            }
            return cid;
        };

        window.debugLog = (msg, isError = false) => {
            const log = document.getElementById('neuralDebugLog');
            if (log) {
                const timestamp = new Date().toLocaleTimeString();
                const color = isError ? '#ff0066' : '#00ff88';
                log.innerHTML += `<div style="color: ${color}">[${timestamp}] ${msg}</div>`;
                log.scrollTop = log.scrollHeight;
            }
            console.log(msg);
        };

        // NOTIFICATION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        window.notify = (msg, type = "success") => {
            const n = document.createElement('div');
            n.className = `fixed bottom-10 right-10 p-8 glass-card border-l-[10px] ${type==='success'?'border-cyan-500 text-cyan-400':'border-red-500 text-red-500'} z-[5000] orbitron text-[10px] font-black uppercase animate-view shadow-2xl`;
            n.innerText = msg;
            document.body.appendChild(n);
            setTimeout(() => n.remove(), 4000);
        };

        window.updateStats = () => { 
            const el = document.getElementById('statTotal');
            if (el) el.innerText = state.nfts.length; 
        };

        window.notify = (msg, type = "success") => {
            const n = document.createElement('div');
            n.className = `fixed bottom-10 right-10 p-8 glass-card border-l-[10px] ${type==='success'?'border-cyan-500 text-cyan-400':'border-red-500 text-red-500'} z-[5000] orbitron text-[10px] font-black uppercase animate-view shadow-2xl`;
            n.innerText = msg;
            document.body.appendChild(n);
            setTimeout(() => n.remove(), 4000);
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #2: MINT STATUS INDICATOR
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.showMintStatus = (status, message) => {
            state.mintStatus = status;
            
            const existing = document.querySelector('.mint-status-badge');
            if (existing) existing.remove();
            
            const badge = document.createElement('div');
            badge.className = `mint-status-badge mint-status-${status}`;
            badge.innerHTML = `
                <div class="flex items-center gap-3">
                    ${status === 'pending' ? '<div class="w-3 h-3 border-2 border-orange-500 border-t-transparent rounded-full animate-spin"></div>' : ''}
                    ${status === 'confirmed' ? '<div class="w-3 h-3 bg-green-500 rounded-full shadow-[0_0_10px_lime]"></div>' : ''}
                    ${status === 'failed' ? '<div class="w-3 h-3 bg-red-500 rounded-full"></div>' : ''}
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(badge);
            
            if (status === 'confirmed' || status === 'failed') {
                setTimeout(() => {
                    badge.style.opacity = '0';
                    badge.style.transform = 'translateX(400px)';
                    setTimeout(() => badge.remove(), 300);
                }, 3000);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #1 & #3: ENHANCED METADATA FETCHING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.fetchNFTMetadata = async (nft) => {
            try {
                if (nft.metadataCache && nft.metadataCache.attributes) {
                    return nft.metadataCache;
                }
                
                const collection = state.collections.find(c => c.collectionId === nft.collectionId);
                if (!collection) {
                    console.warn("Collection not found for NFT:", nft.id);
                    return null;
                }
                
                const mintIndex = nft.id.split('_').pop();
                const fileName = collection.scannedFiles?.[mintIndex] || `${mintIndex}.json`;
                const metadataUrl = `https://gateway.pinata.cloud/ipfs/${collection.ipfsCid}/${fileName}`;
                
                console.log("üì• Fetching metadata:", metadataUrl);
                
                const response = await fetch(metadataUrl);
                if (!response.ok) {
                    throw new Error(`Metadata fetch failed: ${response.status}`);
                }
                
                const metadata = await response.json();
                nft.metadataCache = metadata;
                
                if (metadata.attributes && Array.isArray(metadata.attributes)) {
                    await updateDoc(doc(db, 'nfts', nft.id), {
                        attributes: metadata.attributes,
                        metadataFetched: true,
                        lastMetadataUpdate: new Date().toISOString()
                    });
                }
                
                return metadata;
            } catch (error) {
                console.error("Error fetching NFT metadata:", error);
                return null;
            }
        };

        // FIX #1: Render traits with rarity - ENHANCED WITH TOGGLE
        window.renderNFTTraits = (nft, mode = 'toggle', initiallyExpanded = false) => {
            if (!nft.attributes || nft.attributes.length === 0) {
                return '<div class="text-xs text-gray-500 fira italic mt-2">No traits available</div>';
            }
            
            const collection = state.collections.find(c => 
                c.collectionId === nft.collectionId || 
                (nft.collectionToken && getNormalizedId(c.collectionToken) === getNormalizedId(nft.collectionToken))
            );
            const totalMinted = collection?.mintedCount || 1;
            const uniqueId = `traits-${nft.id}-${Math.random().toString(36).substr(2, 9)}`;
            
            const traitsHTML = nft.attributes.map(trait => {
                const traitRarity = window.calculateTraitRarity(trait, nft.collectionId, totalMinted);
                const tier = window.getRarityTier(traitRarity);
                return `
                    <div class="trait-badge">
                        <div class="flex justify-between text-xs">
                            <span class="text-gray-400 uppercase font-semibold">${trait.trait_type || 'Unknown'}</span>
                            <span class="${tier.color} font-bold">${trait.value || 'Unknown'}</span>
                        </div>
                        <div class="text-[10px] text-gray-500 mt-0.5">
                            ${traitRarity.toFixed(1)}% rarity
                        </div>
                    </div>
                `;
            }).join('');
            
            // MODE: 'toggle' = collapsible, 'all' = show all expanded, 'limited' = show first 3
            if (mode === 'all') {
                return `<div class="mt-3 space-y-1.5">${traitsHTML}</div>`;
            }
            
            if (mode === 'limited') {
                return `
                    <div class="mt-3 space-y-1.5">
                        ${nft.attributes.slice(0, 3).map(trait => {
                            const traitRarity = window.calculateTraitRarity(trait, nft.collectionId, totalMinted);
                            const tier = window.getRarityTier(traitRarity);
                            return `
                                <div class="trait-badge ${tier.glow}">
                                    <div class="flex justify-between text-xs">
                                        <span class="text-gray-400 uppercase font-semibold">${trait.trait_type || 'Unknown'}</span>
                                        <span class="${tier.color} font-bold">${trait.value || 'Unknown'}</span>
                                    </div>
                                    <div class="text-[10px] ${tier.color} mt-0.5 font-bold">
                                        ${traitRarity.toFixed(1)}% rarity
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        ${nft.attributes.length > 3 ? `
                            <div class="text-[10px] text-cyan-400 fira text-center font-semibold">
                                +${nft.attributes.length - 3} more traits
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // MODE: 'toggle' - collapsible with button
            return `
                <div class="mt-3">
                    <div class="trait-toggle-btn" onclick="window.toggleTraits('${uniqueId}')">
                        <span class="orbitron text-xs font-bold text-cyan-400 uppercase">
                            Traits (${nft.attributes.length})
                        </span>
                        <svg id="${uniqueId}-icon" class="w-4 h-4 text-cyan-400 trait-toggle-icon ${initiallyExpanded ? 'rotated' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    <div id="${uniqueId}" class="traits-container ${initiallyExpanded ? 'expanded' : ''} space-y-1.5 mt-2">
                        ${traitsHTML}
                    </div>
                </div>
            `;
        };
        
        // Toggle traits visibility
        window.toggleTraits = (containerId) => {
            const container = document.getElementById(containerId);
            const icon = document.getElementById(`${containerId}-icon`);
            
            if (container && icon) {
                container.classList.toggle('expanded');
                icon.classList.toggle('rotated');
            }
        };

        window.calculateTraitRarity = (trait, collectionId, totalMinted) => {
            // Try multiple collection ID formats
            const possibleIds = [
                collectionId,
                collectionId?.replace?.('collection_', ''),
                `collection_${collectionId}`
            ].filter(Boolean);
            
            let counts = {};
            for (const id of possibleIds) {
                if (state.traitCounts[id]) {
                    counts = state.traitCounts[id];
                    break;
                }
            }
            
            if (Object.keys(counts).length === 0) {
                console.warn(`‚ö†Ô∏è No trait counts found for collection: ${collectionId}`);
                return 0;
            }
            
            const key = `${trait.trait_type}:${trait.value}`;
            const count = counts[key] || 0;
            const rarity = totalMinted > 0 ? (count / totalMinted) * 100 : 0;
            
            console.log(`üé® Trait rarity: ${key} = ${rarity.toFixed(1)}% (${count}/${totalMinted})`);
            
            return rarity;
        };

        window.getRarityTier = (rarityPercent) => {
            if (rarityPercent > 20) return { tier: 'common', color: 'text-gray-400', glow: '' };
            if (rarityPercent > 10) return { tier: 'uncommon', color: 'text-green-400', glow: 'shadow-[0_0_10px_rgba(34,197,94,0.3)]' };
            if (rarityPercent > 3) return { tier: 'rare', color: 'text-blue-400', glow: 'shadow-[0_0_15px_rgba(59,130,246,0.5)]' };
            if (rarityPercent > 1) return { tier: 'elite', color: 'text-purple-400', glow: 'shadow-[0_0_20px_rgba(168,85,247,0.6)]' };
            return { tier: 'mythic', color: 'text-yellow-400', glow: 'shadow-[0_0_25px_rgba(234,179,8,0.8)]' };
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AUTO-DETECT EXTERNAL NFT COLLECTION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const EXTERNAL_COLLECTION = {
            manifestUrl: 'https://ipfs.io/ipfs/bafkreifh4qgpi7qg2htojj3rndpy23pj3mhkloibo3squ2z6ntwj2svhwe',
            collectionToken: 'keeta_an2ry2lnhztn5x7h5n3af5cw5ho37rqcq5z3kr4jlnmqyxprteu7ooxuhlmje',
            collectionName: 'Peregrine Falcon Punks',
            totalItems: 241
        };

        window.autoDetectExternalNFTs = async () => {
            if (!state.address || !state.keetaClient) {
                console.log("‚è≠Ô∏è Skipping auto-detect: No wallet connected");
                return;
            }

            try {
                console.log("üîç AUTO-DETECT: Starting scan for Peregrine Falcon Punks...");
                
                // Step 1: Fetch the manifest
                console.log("üì° Fetching collection manifest from IPFS...");
                const manifestResponse = await fetch(EXTERNAL_COLLECTION.manifestUrl);
                if (!manifestResponse.ok) {
                    throw new Error(`Failed to fetch manifest: ${manifestResponse.status}`);
                }
                const manifest = await manifestResponse.json();
                console.log(`‚úÖ Manifest loaded: ${manifest.items?.length || 0} NFTs in collection`);

                if (!manifest.items || !Array.isArray(manifest.items)) {
                    console.warn("‚ö†Ô∏è Invalid manifest structure");
                    return;
                }

                // Step 2: Get user's balance to check which NFTs they own
                console.log("üíº Checking wallet balances...");
                let balances = await state.keetaClient.allBalances(state.address);
                
                if (!balances || !Array.isArray(balances)) {
                    console.warn("‚ö†Ô∏è Could not fetch balances");
                    return;
                }

                // Create a set of token addresses the user owns
                const ownedTokens = new Set(
                    balances
                        .filter(b => b.balance && b.balance === '1') // NFTs have balance of 1
                        .map(b => getNormalizedId(b.token))
                );

                console.log(`üíé User owns ${ownedTokens.size} tokens (checking against collection...)`);

                // Step 3: Check which NFTs from the collection the user owns
                let detectedCount = 0;
                let processedCount = 0;
                
                for (const item of manifest.items) {
                    const nftAddress = getNormalizedId(item.address);
                    
                    // Check if user owns this NFT
                    if (ownedTokens.has(nftAddress)) {
                        console.log(`‚ú® Found owned NFT #${item.id}: ${nftAddress.substring(0, 20)}...`);
                        
                        try {
                            // Fetch NFT metadata from chain
                            const accountInfo = await KeetaNet.lib.rpc.accountInfo(item.address);
                            
                            let metadata = null;
                            if (accountInfo?.info?.metadata) {
                                try {
                                    metadata = JSON.parse(accountInfo.info.metadata);
                                } catch (e) {
                                    console.warn(`‚ö†Ô∏è Could not parse metadata for NFT #${item.id}`);
                                }
                            }

                            // Check if this NFT is already in Firebase
                            const existingNFT = state.nfts.find(n => 
                                n.tokenId === item.address || 
                                n.id === `external_${item.id}` ||
                                n.externalId === item.id
                            );

                            if (existingNFT) {
                                console.log(`‚ÑπÔ∏è NFT #${item.id} already in database, skipping`);
                                continue;
                            }

                            // Create NFT record
                            const nftData = {
                                id: `external_${EXTERNAL_COLLECTION.collectionName.toLowerCase().replace(/\s+/g, '_')}_${item.id}`,
                                externalId: item.id,
                                tokenId: item.address,
                                name: metadata?.name || `${EXTERNAL_COLLECTION.collectionName} #${item.id}`,
                                description: metadata?.description || `NFT from ${EXTERNAL_COLLECTION.collectionName} collection`,
                                image: metadata?.image || null,
                                imageUrl: metadata?.image || null,
                                imageCid: metadata?.image ? metadata.image.split('/').pop() : null,
                                attributes: metadata?.attributes || [],
                                collectionToken: EXTERNAL_COLLECTION.collectionToken,
                                collectionName: EXTERNAL_COLLECTION.collectionName,
                                collectionId: EXTERNAL_COLLECTION.collectionToken,
                                owner: state.address,
                                creator: accountInfo?.info?.representative || state.address,
                                status: 'external',
                                isExternal: true,
                                autoDetected: true,
                                detectedAt: new Date().toISOString(),
                                isListed: false,
                                listed: false,
                                inVault: true,
                                source: 'auto-detect'
                            };

                            // Save to Firebase
                            await setDoc(
                                doc(db, 'nfts', nftData.id),
                                nftData
                            );

                            console.log(`‚úÖ Saved NFT #${item.id} to database`);
                            detectedCount++;

                        } catch (error) {
                            console.error(`‚ùå Error processing NFT #${item.id}:`, error);
                        }
                    }
                    
                    processedCount++;
                    
                    // Progress update every 50 NFTs
                    if (processedCount % 50 === 0) {
                        console.log(`üìä Progress: ${processedCount}/${manifest.items.length} checked`);
                    }
                    
                    // Small delay to avoid rate limiting
                    if (processedCount % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                if (detectedCount > 0) {
                    console.log(`üéâ AUTO-DETECT COMPLETE: Found and imported ${detectedCount} NFTs from ${EXTERNAL_COLLECTION.collectionName}`);
                    
                    // Create or update collection record
                    await window.createOrUpdateCollectionRecord(EXTERNAL_COLLECTION.collectionToken, EXTERNAL_COLLECTION.collectionName);
                    
                    // Reload all data
                    await window.loadNFTsFromFirebase();
                    await window.loadCollections();
                    
                    // Calculate and save trait counts for rarity system
                    await window.calculateAndSaveTraitCounts(EXTERNAL_COLLECTION.collectionToken);
                    await window.loadTraitCounts();
                    
                    window.notify(`Auto-detected ${detectedCount} NFTs from ${EXTERNAL_COLLECTION.collectionName}!`, "success");
                } else {
                    console.log(`‚ÑπÔ∏è AUTO-DETECT: No new NFTs found from ${EXTERNAL_COLLECTION.collectionName}`);
                }

            } catch (error) {
                console.error("‚ùå Auto-detect error:", error);
                // Fail silently - don't interrupt the user experience
            }
        };

        // Calculate and save trait counts for a collection
        window.calculateAndSaveTraitCounts = async (collectionToken) => {
            try {
                console.log(`üìä Calculating trait counts for collection: ${collectionToken}`);
                
                // Get all NFTs from this collection
                const collectionNFTs = state.nfts.filter(nft => 
                    getNormalizedId(nft.collectionToken) === getNormalizedId(collectionToken)
                );
                
                if (collectionNFTs.length === 0) {
                    console.log("‚ÑπÔ∏è No NFTs found for trait count calculation");
                    return;
                }
                
                // Count each trait
                const traitCounts = {};
                collectionNFTs.forEach(nft => {
                    if (nft.attributes && Array.isArray(nft.attributes)) {
                        nft.attributes.forEach(trait => {
                            const key = `${trait.trait_type}:${trait.value}`;
                            traitCounts[key] = (traitCounts[key] || 0) + 1;
                        });
                    }
                });
                
                // Save to Firebase
                await setDoc(
                    doc(db, 'traitCounts', collectionToken),
                    traitCounts
                );
                
                console.log(`‚úÖ Saved ${Object.keys(traitCounts).length} trait counts for collection`);
                
            } catch (error) {
                console.error("‚ùå Error calculating trait counts:", error);
            }
        };

        // Create or update collection record
        window.createOrUpdateCollectionRecord = async (collectionToken, collectionName) => {
            try {
                console.log(`üìù Creating/updating collection record: ${collectionName}`);
                
                // Count how many NFTs are in this collection
                const collectionNFTs = state.nfts.filter(nft => 
                    getNormalizedId(nft.collectionToken) === getNormalizedId(collectionToken)
                );
                
                const mintedCount = collectionNFTs.length;
                
                // Get a sample NFT for the collection image
                const sampleNFT = collectionNFTs[0];
                
                const collectionData = {
                    collectionId: collectionToken,
                    collectionToken: collectionToken,
                    collectionName: collectionName,
                    mintedCount: mintedCount,
                    totalSupply: 241, // From manifest
                    creator: sampleNFT?.creator || state.address,
                    createdAt: sampleNFT?.detectedAt || new Date().toISOString(),
                    imageCid: sampleNFT?.imageCid || null,
                    isExternal: true,
                    autoDetected: true
                };
                
                await setDoc(
                    doc(db, 'collections', collectionToken),
                    collectionData
                );
                
                console.log(`‚úÖ Collection record saved: ${mintedCount} NFTs minted`);
                
            } catch (error) {
                console.error("‚ùå Error creating collection record:", error);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WALLET & BALANCE FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        window.refreshBalance = async () => {
            if (!state.address || !state.keetaClient) return;
            try {
                if (!state.keetaClient.baseToken) { 
                    try { await state.keetaClient.init(); } catch(e) {} 
                }
                
                const bals = await state.keetaClient.allBalances(state.address);
                if (!bals || !Array.isArray(bals)) return;
                
                const clientBaseTokenId = getNormalizedId(state.keetaClient.baseToken);
                let ktaToken = bals.find(b => 
                    getNormalizedId(b.token) === clientBaseTokenId || 
                    b.isBaseToken === true || 
                    (b.info && b.info.symbol === 'KTA')
                );
                
                if (!ktaToken && bals.length > 0) ktaToken = bals[0];

                if (ktaToken) {
                    const rawVal = (ktaToken.balance ?? ktaToken.amount ?? 0).toString().replace('n','');
                    state.balanceKTA = Number(BigInt(rawVal)) / KTA_DECIMALS;
                    const el = document.getElementById('balanceKTA');
                    if (el) el.innerText = state.balanceKTA.toFixed(4);
                }

                const punksToken = bals.find(b => !b.isBaseToken && (b.info?.name||"").toUpperCase().includes('PUNK'));
                const punksRaw = (punksToken?.balance ?? punksToken?.amount ?? 0).toString().replace('n','');
                state.balancePunks = Number(BigInt(punksRaw));
                const pEl = document.getElementById('balancePunks');
                if (pEl) pEl.innerText = state.balancePunks.toLocaleString();
                
                console.log("üí∞ Balance updated - KTA:", state.balanceKTA, "PUNKS:", state.balancePunks);
            } catch (e) { 
                console.warn("Balance sync delay:", e.message); 
            }
        };

        window.refreshAuthGate = () => {
            const hasAuth = !!state.address;
            const isEscrowWallet = state.address === MARKETPLACE_FEE_WALLET;
            
            document.getElementById('adminGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('forgeContainer')?.classList.toggle('hidden', !hasAuth);
            
            // UI Reset Panel - ONLY show for escrow wallet
            document.getElementById('uiWipePanel')?.classList.toggle('hidden', !isEscrowWallet);
            
            document.getElementById('vaultGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('vaultContainer')?.classList.toggle('hidden', !hasAuth);
            document.getElementById('watchlistGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('watchlistContainer')?.classList.toggle('hidden', !hasAuth);
            document.getElementById('transactionsGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('transactionsContainer')?.classList.toggle('hidden', !hasAuth);
            document.getElementById('offersGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('offersContainer')?.classList.toggle('hidden', !hasAuth);
            
            // Update cached items display when showing admin panel (escrow wallet only)
            if (isEscrowWallet) {
                setTimeout(() => window.updateCachedItemsDisplay(), 100);
            }
        };

        window.initNeuralLink = () => {
            try {
                const modal = document.getElementById('seedModal');
                if (modal) modal.classList.remove('hidden');
                
                const grid = document.getElementById('seedGrid');
                if (grid) {
                    grid.innerHTML = '';
                    for (let i = 0; i < 24; i++) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'seed-box';
                    input.placeholder = `${i + 1}`;
                    input.autocomplete = 'off';
                    
                    input.addEventListener('paste', (e) => {
                        e.preventDefault();
                        const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                        const words = pastedText.trim().split(/\s+/);
                        
                        if (words.length >= 12) {
                            const allInputs = grid.querySelectorAll('.seed-box');
                            words.forEach((word, index) => {
                                if (allInputs[index]) {
                                    allInputs[index].value = word.toLowerCase().trim();
                                }
                            });
                            window.notify(`Pasted ${words.length} words`, "success");
                        } else {
                            input.value = pastedText;
                        }
                    });
                    
                    grid.appendChild(input);
                }
            }
            } catch (error) {
                console.error("Error in initNeuralLink:", error);
                // Fallback: just show a simple prompt
                alert("Please refresh the page and try again. If the issue persists, check the console for details.");
            }
        };

        window.closeModal = (modalId) => {
            const modal = document.getElementById(modalId);
            if (modal) modal.classList.add('hidden');
        };

        window.disconnectWallet = () => {
            state.address = null;
            state.keetaAccount = null;
            state.keetaClient = null;
            
            // FIX #6: Clear localStorage on disconnect
            try {
                localStorage.removeItem('punkswap_wallet_seed');
                console.log("‚úÖ Session cleared");
            } catch (e) {
                console.warn("‚ö†Ô∏è Could not clear localStorage:", e);
            }
            
            document.getElementById('profileOffline').classList.remove('hidden');
            document.getElementById('profileOnline').classList.add('hidden');
            window.refreshAuthGate();
            window.notify("‚úÖ Session Terminated", "success");
        };

        // Clear corrupted session data
        window.clearCorruptedSession = () => {
            if (confirm("Clear all saved session data?\n\nThis will sign you out and remove any corrupted wallet data.")) {
                try {
                    // Clear localStorage
                    localStorage.removeItem('punkswap_wallet_seed');
                    
                    // Clear state
                    state.address = null;
                    state.keetaAccount = null;
                    state.keetaClient = null;
                    
                    // Clear UI
                    document.querySelectorAll('.seed-box').forEach(box => {
                        if (box) box.value = '';
                    });
                    
                    // Reset profile
                    document.getElementById('profileOffline').classList.remove('hidden');
                    document.getElementById('profileOnline').classList.add('hidden');
                    
                    window.refreshAuthGate();
                    
                    window.notify("‚úÖ Session data cleared - please sign in again", "success");
                    
                    console.log("üßπ All session data cleared");
                } catch (error) {
                    console.error("Error clearing session:", error);
                    window.notify("Manual clear needed - check console", "error");
                }
            }
        };

        window.importWallet = async () => {
            const raw = Array.from(document.querySelectorAll('.seed-box')).map(i => (i?.value || '').toLowerCase().trim());
            
            // Less strict filtering - just remove obvious non-words
            const words = raw.filter(w => {
                if (!w || w.length < 2) return false;
                if (w.startsWith('keeta_')) return false;
                if (/^https?:\/\//.test(w)) return false;
                return true;
            });
            
            console.log('üîç DEBUG - Seed validation:');
            console.log('- Raw input length:', raw.join(' ').length);
            console.log('- Split words count:', raw.length);
            console.log('- Filtered words count:', words.length);
            console.log('- First 3 words:', words.slice(0, 3));
            console.log('- Last 3 words:', words.slice(-3));
            
            if (words.length !== 12 && words.length !== 24) {
                console.error('‚ùå Invalid word count:', words.length);
                
                // Clear corrupted localStorage
                try {
                    localStorage.removeItem('punkswap_wallet_seed');
                    console.log('üßπ Cleared corrupted seed from localStorage');
                } catch (e) {
                    console.warn('Could not clear localStorage:', e);
                }
                
                return window.notify(`Invalid seed phrase (Need 12 or 24 words, got ${words.length})`, "error");
            }
            
            try {
                window.notify("Connecting wallet...", "success");
                
                const passphrase = words.join(' ');
                console.log('‚úÖ Seed validation passed');
                
                const hex = await KeetaNet.lib.Account.seedFromPassphrase(passphrase, { asString: true });
                state.keetaAccount = KeetaNet.lib.Account.fromSeed(hex, 0);
                state.address = state.keetaAccount.publicKeyString.get();
                state.keetaClient = KeetaNet.UserClient.fromNetwork('test', state.keetaAccount);
                
                // Save to localStorage
                try {
                    localStorage.setItem('punkswap_wallet_seed', passphrase);
                    console.log("‚úÖ Wallet saved to session");
                } catch (storageError) {
                    console.warn("‚ö†Ô∏è Could not save to localStorage:", storageError);
                }
                
                document.getElementById('profileOffline').classList.add('hidden');
                document.getElementById('profileOnline').classList.remove('hidden');
                document.getElementById('walletAddressDisplay').innerText = state.address;
                
                window.closeModal('seedModal');
                
                console.log("üîê Wallet connected:", state.address);
                
                const linkLoop = async () => {
                    try {
                        if (state.keetaClient && typeof state.keetaClient.init === 'function') {
                            await state.keetaClient.init();
                        }
                        await window.refreshBalance();
                        window.refreshAuthGate();
                        window.checkEscrowAccess();
                        await window.loadNFTsFromFirebase();
                        await window.loadCollections();
                        await window.loadTraitCounts();
                        
                        // ‚ö° AUTO-DETECT: Scan for Peregrine Falcon Punks collection
                        await window.autoDetectExternalNFTs();
                        
                        // üìä Load transaction history
                        await window.loadTransactions();
                        await window.loadOffers();
                    } catch (e) { 
                        console.warn("Link initialization delay, retrying...");
                        setTimeout(linkLoop, 3000); 
                    }
                };
                linkLoop();
                
            } catch (e) { 
                console.error("Authorization error:", e);
                window.notify("Authorization Failure", "error"); 
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIREBASE NFT FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UNIVERSAL WALLET SYNC - Detect transfers outside marketplace
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.syncWalletNFTs = async () => {
            if (!state.address || !state.keetaClient) {
                console.log("‚ö†Ô∏è Wallet not connected, skipping sync");
                return;
            }
            
            try {
                console.log("üîÑ WALLET SYNC: Scanning blockchain for all NFTs...");
                
                // Get all tokens in wallet from blockchain
                const balances = await state.keetaClient.allBalances(state.address);
                
                if (!balances || !Array.isArray(balances)) {
                    console.warn("‚ö†Ô∏è Could not fetch wallet balances");
                    return;
                }
                
                // Filter to NFTs (balance = 1, not KTA)
                const walletNFTs = balances.filter(b => 
                    b.balance === '1' && 
                    b.token && 
                    b.token.$type !== 'KTA'
                );
                
                console.log(`üíé Found ${walletNFTs.length} NFTs in wallet`);
                
                let syncedCount = 0;
                let removedCount = 0;
                
                // CHECK 1: Update ownership for NFTs user now owns
                for (const walletNFT of walletNFTs) {
                    const tokenId = walletNFT.token.publicKeyString?.get() || walletNFT.token;
                    
                    // Check if this NFT exists in Firebase
                    const existingNFT = state.nfts.find(n => 
                        getNormalizedId(n.tokenId) === getNormalizedId(tokenId)
                    );
                    
                    if (existingNFT) {
                        // NFT exists in Firebase - check if owner is correct
                        if (getNormalizedId(existingNFT.owner) !== getNormalizedId(state.address)) {
                            console.log(`üîÑ Updating ownership: ${existingNFT.name || tokenId.substring(0, 20)}`);
                            
                            // Update Firebase
                            await updateDoc(
                                doc(db, 'nfts', existingNFT.id),
                                {
                                    owner: state.address,
                                    inEscrow: false,
                                    isListed: false,
                                    listedPrice: null,
                                    listedCurrency: null,
                                    updatedAt: new Date().toISOString()
                                }
                            );
                            
                            syncedCount++;
                        }
                    }
                }
                
                // CHECK 2: Remove NFTs user no longer owns
                const walletTokenIds = new Set(
                    walletNFTs.map(nft => {
                        const tokenId = nft.token.publicKeyString?.get() || nft.token;
                        return getNormalizedId(tokenId);
                    })
                );
                
                for (const fbNFT of state.nfts) {
                    // If Firebase says we own it, but wallet doesn't have it
                    if (getNormalizedId(fbNFT.owner) === getNormalizedId(state.address)) {
                        const normalizedToken = getNormalizedId(fbNFT.tokenId);
                        
                        if (!walletTokenIds.has(normalizedToken)) {
                            console.log(`üîÑ NFT transferred out: ${fbNFT.name || fbNFT.tokenId.substring(0, 20)}`);
                            
                            // Update Firebase - mark as transferred (owner = null or previous owner)
                            await updateDoc(
                                doc(db, 'nfts', fbNFT.id),
                                {
                                    owner: null,  // Unknown owner
                                    inEscrow: false,
                                    isListed: false,
                                    listedPrice: null,
                                    listedCurrency: null,
                                    updatedAt: new Date().toISOString(),
                                    transferredOutside: true
                                }
                            );
                            
                            removedCount++;
                        }
                    }
                }
                
                if (syncedCount > 0 || removedCount > 0) {
                    console.log(`‚úÖ WALLET SYNC: ${syncedCount} NFTs synced, ${removedCount} removed`);
                    
                    // Refresh UI
                    await window.loadNFTsFromFirebase();
                    await window.renderCollection();
                    
                    window.notify(`Wallet synced: ${syncedCount} updated, ${removedCount} removed`, "success");
                } else {
                    console.log("‚úÖ WALLET SYNC: All NFTs already in sync");
                }
                
            } catch (error) {
                console.error("‚ùå Wallet sync failed:", error);
            }
        };
        
        // Auto-sync on wallet connection and periodically
        window.startAutoSync = () => {
            // Sync immediately
            window.syncWalletNFTs();
            
            // Sync every 30 seconds
            if (window.autoSyncInterval) {
                clearInterval(window.autoSyncInterval);
            }
            window.autoSyncInterval = setInterval(() => {
                if (state.address) {
                    window.syncWalletNFTs();
                }
            }, 30000); // 30 seconds
        };
        
        // Stop auto-sync (call on disconnect)
        window.stopAutoSync = () => {
            if (window.autoSyncInterval) {
                clearInterval(window.autoSyncInterval);
                window.autoSyncInterval = null;
            }
        };

        


        // RARITY SCORING SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.calculateRarityScore = (nft, allNFTsInCollection) => {
            if (!nft.attributes || !Array.isArray(nft.attributes)) {
                return { score: 0, rank: null, percentile: 0 };
            }
            
            const collectionSize = allNFTsInCollection.length;
            if (collectionSize === 0) return { score: 0, rank: null, percentile: 0 };
            
            let totalScore = 0;
            const traitScores = [];
            
            // Calculate score for each trait
            for (const trait of nft.attributes) {
                const traitType = trait.trait_type;
                const traitValue = trait.value;
                
                // Count how many NFTs have this exact trait
                const countWithTrait = allNFTsInCollection.filter(n => {
                    if (!n.attributes) return false;
                    return n.attributes.some(a => 
                        a.trait_type === traitType && a.value === traitValue
                    );
                }).length;
                
                // Rarity formula: 1 / (frequency / total)
                const frequency = countWithTrait / collectionSize;
                const traitScore = frequency > 0 ? (1 / frequency) : 0;
                
                traitScores.push({
                    trait_type: traitType,
                    value: traitValue,
                    count: countWithTrait,
                    frequency: (frequency * 100).toFixed(1) + '%',
                    score: traitScore
                });
                
                totalScore += traitScore;
            }
            
            // Calculate rank
            const allScores = allNFTsInCollection.map(n => {
                if (!n.attributes) return 0;
                let score = 0;
                for (const trait of n.attributes) {
                    const countWithTrait = allNFTsInCollection.filter(x => 
                        x.attributes && x.attributes.some(a => 
                            a.trait_type === trait.trait_type && a.value === trait.value
                        )
                    ).length;
                    const freq = countWithTrait / collectionSize;
                    score += freq > 0 ? (1 / freq) : 0;
                }
                return score;
            }).sort((a, b) => b - a); // Descending order
            
            const rank = allScores.indexOf(totalScore) + 1;
            const percentile = ((collectionSize - rank) / collectionSize * 100).toFixed(1);
            
            return {
                score: totalScore,
                rank: rank,
                total: collectionSize,
                percentile: parseFloat(percentile),
                traitScores: traitScores,
                formattedScore: totalScore.toFixed(2)
            };
        };
        
        window.addRarityToNFTs = () => {
            console.log("üé≤ Calculating rarity scores...");
            
            // Group NFTs by collection
            const byCollection = {};
            for (const nft of state.nfts) {
                const colId = nft.collectionId || nft.collectionToken;
                if (!colId) continue;
                if (!byCollection[colId]) byCollection[colId] = [];
                byCollection[colId].push(nft);
            }
            
            // Calculate rarity for each NFT
            let calculated = 0;
            for (const [colId, nfts] of Object.entries(byCollection)) {
                for (const nft of nfts) {
                    const rarity = window.calculateRarityScore(nft, nfts);
                    nft.rarity = rarity;
                    calculated++;
                }
            }
            
            console.log(`‚úÖ Calculated rarity for ${calculated} NFTs across ${Object.keys(byCollection).length} collections`);
            return calculated;
        };
        
        window.getRarityBadgeHTML = (rarity) => {
            if (!rarity || !rarity.rank) return '';
            
            let badgeColor = 'gray';
            let badgeText = 'Common';
            
            // Percentile-based rarity tiers
            if (rarity.percentile >= 95) {
                badgeColor = 'from-yellow-400 to-orange-500';
                badgeText = 'Legendary';
            } else if (rarity.percentile >= 85) {
                badgeColor = 'from-purple-500 to-pink-500';
                badgeText = 'Epic';
            } else if (rarity.percentile >= 70) {
                badgeColor = 'from-blue-500 to-cyan-500';
                badgeText = 'Rare';
            } else if (rarity.percentile >= 50) {
                badgeColor = 'from-green-500 to-emerald-500';
                badgeText = 'Uncommon';
            } else {
                badgeColor = 'from-gray-600 to-gray-700';
                badgeText = 'Common';
            }
            
            return `
                <div class="absolute top-2 left-2 z-10">
                    <div class="bg-gradient-to-r ${badgeColor} px-2 py-1 rounded text-[8px] orbitron font-black text-white shadow-lg">
                        #${rarity.rank} / ${rarity.total}
                    </div>
                    <div class="bg-black/80 mt-1 px-2 py-0.5 rounded text-[7px] fira text-white">
                        ${badgeText}
                    </div>
                </div>
            `;
        };
        
        window.sortNFTsByRarity = (nfts, order = 'desc') => {
            return [...nfts].sort((a, b) => {
                const scoreA = a.rarity?.score || 0;
                const scoreB = b.rarity?.score || 0;
                return order === 'desc' ? scoreB - scoreA : scoreA - scoreB;
            });
        };

        window.loadNFTsFromFirebase = async () => {
            try {
                console.log("üì• Loading NFTs from Firebase...");
                
                const nftsRef = collection(db, 'nfts');
                const snapshot = await getDocs(nftsRef);
                
                state.nfts = [];
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    state.nfts.push({
                        id: doc.id,
                        ...data
                    });
                });
                
                console.log(`‚úÖ Loaded ${state.nfts.length} NFTs from Firebase`);
                if (state.nfts.length > 0) {
                    console.log("üì¶ Sample NFT:", state.nfts[0]);
                    console.log("üì¶ First NFT keys:", Object.keys(state.nfts[0]));
                    
                    // üé≤ Calculate rarity scores for all NFTs
                    const rarityCount = window.addRarityToNFTs();
                    console.log(`üé≤ Calculated rarity for ${rarityCount} NFTs`);
                } else {
                    console.warn("‚ö†Ô∏è Query returned 0 NFTs - checking Firebase path...");
                    console.log("üîç Expected path:", `artifacts/${state.appId}/public/data/nfts`);
                    console.log("üîç Check Firebase Console: Is data at this exact path?");
                }
                window.updateStats();
                window.renderMarketplace();
                window.renderDrops();
                // FIX #7: Also refresh user's collection view
                window.renderCollection();
                
                // FIX #1: Fetch metadata for NFTs missing traits
                await window.enrichNFTMetadata();
                
                return state.nfts;
            } catch (error) {
                console.error("‚ùå Error loading NFTs:", error);
                window.notify("Error loading marketplace data", "error");
                return [];
            }
        };

        // ACTIVITY FEED - Real-time marketplace activity
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.initActivityFeed = () => {
            console.log("üì∞ Initializing activity feed...");
            
            // Listen to transactions collection for real-time updates
            const txQuery = query(
                collection(db, 'transactions'),
                orderBy('timestamp', 'desc'),
                limit(50)
            );
            
            onSnapshot(txQuery, (snapshot) => {
                console.log("üì∞ Activity feed updated");
                window.renderActivityFeed();
            });
        };
        
        window.renderActivityFeed = () => {
            const container = document.getElementById('activityFeedContainer');
            if (!container) return;
            
            // Get recent transactions (last 24 hours)
            const now = Date.now();
            const oneDayAgo = now - (24 * 60 * 60 * 1000);
            
            const recentActivity = state.transactions
                .filter(tx => {
                    const txTime = new Date(tx.timestamp).getTime();
                    return txTime > oneDayAgo;
                })
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                .slice(0, 20);
            
            if (recentActivity.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-8 text-gray-500 fira text-sm">
                        No recent activity
                    </div>
                `;
                return;
            }
            
            container.innerHTML = recentActivity.map(tx => {
                const timeAgo = window.getTimeAgo(tx.timestamp);
                const nft = state.nfts.find(n => n.id === tx.nftId || n.tokenId === tx.nftId);
                const nftName = nft?.name || 'Unknown NFT';
                const collection = state.collections.find(c => c.collectionId === nft?.collectionId);
                const collectionName = collection?.collectionTitle || 'Unknown Collection';
                
                let icon = 'üí∞';
                let action = '';
                let color = 'text-cyan-400';
                
                if (tx.type === 'mint' || tx.type === 'MINT') {
                    icon = 'üé®';
                    action = 'minted';
                    color = 'text-green-400';
                } else if (tx.type === 'sale' || tx.type === 'SALE') {
                    icon = 'üíé';
                    action = 'bought';
                    color = 'text-cyan-400';
                } else if (tx.type === 'list' || tx.type === 'LIST') {
                    icon = 'üìã';
                    action = 'listed';
                    color = 'text-purple-400';
                } else if (tx.type === 'offer' || tx.type === 'OFFER') {
                    icon = 'üí∞';
                    action = 'offered on';
                    color = 'text-yellow-400';
                }
                
                const buyerShort = tx.buyer ? tx.buyer.substring(0, 6) + '...' + tx.buyer.substring(tx.buyer.length - 4) : 'Someone';
                
                return `
                    <div class="flex items-center gap-3 p-3 rounded-lg hover:bg-white/5 transition-all group cursor-pointer border border-white/5 hover:border-cyan-500/30">
                        <div class="text-2xl">${icon}</div>
                        <div class="flex-1 min-w-0">
                            <div class="fira text-xs ${color}">
                                <span class="font-bold">${buyerShort}</span>
                                <span class="text-gray-400"> ${action} </span>
                                <span class="font-bold text-white truncate">${nftName}</span>
                            </div>
                            <div class="fira text-[10px] text-gray-600 mt-0.5">
                                ${collectionName} ‚Ä¢ ${timeAgo}
                            </div>
                        </div>
                        ${tx.price ? `
                            <div class="orbitron text-xs font-bold ${color}">
                                ${tx.price} ${tx.currency || 'KTA'}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        };
        
        window.getTimeAgo = (timestamp) => {
            const now = Date.now();
            const then = new Date(timestamp).getTime();
            const diff = now - then;
            
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            if (minutes > 0) return `${minutes}m ago`;
            return 'just now';
        };

        // FIX #1: Enrich NFTs with missing metadata
        window.enrichNFTMetadata = async () => {
            const nftsNeedingMetadata = state.nfts.filter(n => 
                !n.attributes || n.attributes.length === 0
            );
            
            if (nftsNeedingMetadata.length === 0) return;
            
            console.log(`üîç Fetching metadata for ${nftsNeedingMetadata.length} NFTs...`);
            
            for (const nft of nftsNeedingMetadata) {
                try {
                    await window.fetchNFTMetadata(nft);
                    await new Promise(r => setTimeout(r, 200));
                } catch (error) {
                    console.error(`Failed to fetch metadata for ${nft.id}:`, error);
                }
            }
        };

        window.setupNFTListener = () => {
            try {
                console.log("üëÇ Setting up Firebase listeners...");
                
                // Debounce helper to prevent excessive re-renders
                let renderTimeout = null;
                const debouncedRender = () => {
                    if (renderTimeout) clearTimeout(renderTimeout);
                    renderTimeout = setTimeout(() => {
                        window.renderMarketplace();
                        window.renderDrops();
                    }, 300); // Wait 300ms before rendering
                };
                
                const nftsRef = collection(db, 'nfts');
                
                onSnapshot(nftsRef, 
                    (snapshot) => {
                        console.log("üîÑ NFT data updated, refreshing...");
                        state.nfts = [];
                        snapshot.forEach((doc) => {
                            state.nfts.push({
                                id: doc.id,
                                ...doc.data()
                            });
                        });
                        
                        window.updateStats();
                        debouncedRender();
                        
                        // CRITICAL: Update charts in real-time
                        console.log("üìä Updating charts from real-time data...");
                        window.updateMarketChart();
                        
                        if (state.viewingCollection) {
                            window.updateCollectionDepth(state.viewingCollection);
                        }
                    },
                    (error) => {
                        console.error("‚ùå NFT listener error:", error.message);
                        // Attempt to reconnect after 5 seconds
                        setTimeout(() => window.setupListeners(), 5000);
                    }
                );
                
                // NEW: Real-time transaction listener for charts
                const txRef = collection(db, 'transactions');
                onSnapshot(txRef, 
                    (snapshot) => {
                        console.log("üí≥ Transaction data updated, refreshing charts...");
                        
                        // Update all charts when transactions change
                        window.updateMarketChart();
                        
                        if (state.viewingCollection) {
                            window.updateCollectionDepth(state.viewingCollection);
                        }
                        
                        // Always refresh transaction list when data changes (so it's fresh when user switches to tab)
                        if (state.address) {
                            window.loadTransactions();
                        }
                    },
                    (error) => {
                        console.error("‚ùå Transaction listener error:", error.message);
                    }
                );
                
                // NEW: Real-time collections listener to update blind mint cards
                const collectionsRef = collection(db, 'collections');
                let lastCollectionUpdate = 0;
                onSnapshot(collectionsRef, 
                    (snapshot) => {
                        // Throttle collection updates to max once per second
                        const now = Date.now();
                        if (now - lastCollectionUpdate < 1000) {
                            console.log("‚è∏Ô∏è Collection update throttled");
                            return;
                        }
                        lastCollectionUpdate = now;
                        
                        console.log("üîÑ Collection data updated, refreshing drops...");
                        
                        // Update state.collections
                        state.collections = [];
                        snapshot.forEach((doc) => {
                            state.collections.push({
                                id: doc.id,
                                ...doc.data()
                            });
                        });
                        
                        // Use debounced render
                        debouncedRender();
                    },
                    (error) => {
                        console.error("‚ùå Collection listener error:", error.message);
                    }
                );
                
                console.log("üëÇ Real-time NFT, Transaction & Collection listeners active");
            } catch (error) {
                console.error("Error setting up listeners:", error);
            }
        };

        window.updateTraitCounts = async (collectionId, traits) => {
            if (!traits || traits.length === 0) return;
            
            try {
                const traitCountsRef = doc(db, 'traitCounts', collectionId);
                const countSnap = await getDoc(traitCountsRef);
                
                let counts = countSnap.exists() ? countSnap.data() : {};
                
                traits.forEach(trait => {
                    const key = `${trait.trait_type}:${trait.value}`;
                    counts[key] = (counts[key] || 0) + 1;
                });
                
                await setDoc(traitCountsRef, counts);
                console.log("‚úÖ Trait counts updated");
            } catch (error) {
                console.error("Error updating trait counts:", error);
            }
        };

        window.loadTraitCounts = async () => {
            if (!db) return;
            
            try {
                const countsRef = collection(db, 'traitCounts');
                const snapshot = await getDocs(countsRef);
                
                state.traitCounts = {};
                snapshot.forEach(doc => {
                    state.traitCounts[doc.id] = doc.data();
                });
                
                console.log(`‚úÖ Loaded trait counts for ${snapshot.size} collections`);
            } catch (error) {
                console.error("Error loading trait counts:", error);
            }
        };

        window.loadCollections = async () => {
            if (!db) return;
            
            try {
                // Try primary path first
                let collectionsRef = collection(db, 'collections');
                let snapshot = await getDocs(collectionsRef);
                
                state.collections = [];
                snapshot.forEach(doc => {
                    state.collections.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(`‚úÖ Loaded ${state.collections.length} collections`);
                if (state.collections.length > 0) {
                    console.log("üì¶ Sample collection:", state.collections[0]);
                    console.log("üìç Collections loaded from Firebase successfully");
                } else {
                    console.warn("‚ö†Ô∏è Query returned 0 collections");
                    console.log("üîç Check these paths in Firebase:");
                    console.log("   1.", `artifacts/${state.appId}/public/data/collections`);
                    console.log("   2.", `collections`);
                    console.log("üí° Collections may be stored elsewhere in your database");
                }
                window.renderCollections();
                window.updateAirdropVisibility();
                
            } catch (error) {
                console.error("Error loading collections:", error);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #2 & #3: MINT FUNCTIONS - USES KEETA MINT PIPELINE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BATCH MINT - Wrapper around existing mint (doesn't modify core logic)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.executeBatchMint = async (collectionId, quantity) => {
            if (!quantity || quantity < 1 || quantity > 10) {
                window.notify("Quantity must be between 1-10", "error");
                return { success: false, error: "Invalid quantity" };
            }
            
            console.log(`üé® Starting batch mint: ${quantity} NFTs`);
            
            const results = {
                successful: [],
                failed: [],
                total: quantity
            };
            
            // Show batch progress modal
            window.showBatchMintProgress(quantity);
            
            // ‚ö° PARALLEL MINTING - All at once for max speed!
            console.log(`‚ö° Starting ${quantity} parallel mints...`);
            
            // Create array of mint promises
            const mintPromises = [];
            for (let i = 0; i < quantity; i++) {
                const current = i + 1;
                
                // Create mint promise
                const mintPromise = (async () => {
                    console.log(`\nüé® ‚ïê‚ïê‚ïê MINTING ${current}/${quantity} ‚ïê‚ïê‚ïê`);
                    window.updateBatchMintProgress(current, quantity, 'minting');
                    
                    try {
                        // Call YOUR EXISTING, WORKING mint function!
                        const result = await window.mintFromCollection(collectionId);
                        
                        if (result && result.success) {
                            results.successful.push(result);
                            window.updateBatchMintProgress(current, quantity, 'success');
                            console.log(`‚úÖ Mint ${current}/${quantity} successful`);
                            return { success: true, index: current, result };
                        } else {
                            results.failed.push({ index: current, error: result?.error || 'Unknown error' });
                            window.updateBatchMintProgress(current, quantity, 'failed');
                            console.error(`‚ùå Mint ${current}/${quantity} failed:`, result?.error);
                            return { success: false, index: current, error: result?.error };
                        }
                    } catch (error) {
                        results.failed.push({ index: current, error: error.message });
                        window.updateBatchMintProgress(current, quantity, 'failed');
                        console.error(`‚ùå Mint ${current}/${quantity} error:`, error);
                        return { success: false, index: current, error: error.message };
                    }
                })();
                
                mintPromises.push(mintPromise);
                
                // Tiny stagger (100ms) to prevent exact simultaneous hits
                if (i < quantity - 1) {
                    await new Promise(r => setTimeout(r, 100));
                }
            }
            
            // Wait for all mints to complete
            console.log(`‚è≥ Waiting for all ${quantity} mints to complete...`);
            await Promise.allSettled(mintPromises);
            console.log(`‚úÖ All ${quantity} mints processed!`);
            
            // Show final results
            window.showBatchMintResults(results);
            
            console.log(`\nüéâ Batch mint complete:`, results);
            return results;
        };

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BATCH MINT PROGRESS UI
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.showBatchMintProgress = (total) => {
            const modal = document.createElement('div');
            modal.id = 'batchMintModal';
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-md w-full mx-4">
                    <h3 class="orbitron text-xl text-cyan-400 font-bold mb-6 text-center">Batch Minting Progress</h3>
                    <div id="batchMintProgressContainer" class="space-y-4">
                        <!-- Progress items will be added here -->
                    </div>
                    <div class="mt-6 text-center">
                        <div class="text-sm text-gray-400">
                            <span id="batchMintSuccessCount">0</span> of <span id="batchMintTotal">${total}</span> completed
                        </div>
                        <div class="mt-2 text-xs text-gray-600">
                            Please wait... Do not close this window
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Create progress items
            const container = document.getElementById('batchMintProgressContainer');
            for (let i = 1; i <= total; i++) {
                const item = document.createElement('div');
                item.id = `batchMintItem${i}`;
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-black/40 border border-white/10';
                item.innerHTML = `
                    <div class="w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center text-sm font-bold">
                        ${i}
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-400">NFT #${i}</div>
                        <div class="text-xs text-gray-600" id="batchMintStatus${i}">Waiting...</div>
                    </div>
                    <div id="batchMintIcon${i}" class="text-2xl">‚è≥</div>
                `;
                container.appendChild(item);
            }
        };
        
        window.updateBatchMintProgress = (current, total, status) => {
            const item = document.getElementById(`batchMintItem${current}`);
            const statusEl = document.getElementById(`batchMintStatus${current}`);
            const iconEl = document.getElementById(`batchMintIcon${current}`);
            
            if (!item || !statusEl || !iconEl) return;
            
            if (status === 'minting') {
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-cyan-900/20 border border-cyan-500/30';
                statusEl.textContent = 'Minting...';
                statusEl.className = 'text-xs text-cyan-400';
                iconEl.textContent = '‚öôÔ∏è';
            } else if (status === 'success') {
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-green-900/20 border border-green-500/30';
                statusEl.textContent = 'Minted!';
                statusEl.className = 'text-xs text-green-400';
                iconEl.textContent = '‚úÖ';
                
                // Update success count
                const successCount = document.getElementById('batchMintSuccessCount');
                if (successCount) {
                    successCount.textContent = current;
                }
            } else if (status === 'failed') {
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-red-900/20 border border-red-500/30';
                statusEl.textContent = 'Failed';
                statusEl.className = 'text-xs text-red-400';
                iconEl.textContent = '‚ùå';
            }
        };
        
        window.showBatchMintResults = (results) => {
            const modal = document.getElementById('batchMintModal');
            if (!modal) return;
            
            const successful = results.successful.length;
            const failed = results.failed.length;
            const total = results.total;
            
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-md w-full mx-4">
                    <h3 class="orbitron text-xl text-cyan-400 font-bold mb-6 text-center">Batch Mint Complete!</h3>
                    
                    <div class="space-y-4 mb-6">
                        <div class="p-4 rounded-lg bg-green-900/20 border border-green-500/30">
                            <div class="text-3xl font-bold text-green-400 text-center">${successful}</div>
                            <div class="text-sm text-gray-400 text-center">Successfully Minted</div>
                        </div>
                        
                        ${failed > 0 ? `
                        <div class="p-4 rounded-lg bg-red-900/20 border border-red-500/30">
                            <div class="text-3xl font-bold text-red-400 text-center">${failed}</div>
                            <div class="text-sm text-gray-400 text-center">Failed</div>
                        </div>
                        ` : ''}
                        
                        <div class="p-4 rounded-lg bg-black/40 border border-white/10">
                            <div class="text-2xl font-bold text-white text-center">${total}</div>
                            <div class="text-sm text-gray-400 text-center">Total Attempted</div>
                        </div>
                    </div>
                    
                    <button onclick="document.getElementById('batchMintModal').remove(); window.renderCollection();" 
                            class="btn-primary w-full py-3">
                        View My NFTs
                    </button>
                </div>
            `;
        };

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BATCH MINT UI TRIGGER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.showBatchMintModal = (collectionId) => {
            const modal = document.createElement('div');
            modal.id = 'batchMintQuantityModal';
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-md w-full mx-4">
                    <h3 class="orbitron text-xl text-cyan-400 font-bold mb-6 text-center">Batch Mint</h3>
                    
                    <div class="mb-6">
                        <label class="block text-sm text-gray-400 mb-3">How many NFTs to mint?</label>
                        <input type="number" id="batchMintQuantity" 
                               value="1" min="1" max="10" 
                               class="w-full bg-black/60 border border-cyan-500/30 p-4 rounded-xl text-3xl text-center text-cyan-400 outline-none font-bold focus:border-cyan-500">
                        <div class="text-xs text-gray-600 mt-2 text-center">Maximum 10 NFTs per batch</div>
                    </div>
                    
                    <div class="grid grid-cols-5 gap-2 mb-6">
                        <button onclick="document.getElementById('batchMintQuantity').value = 1" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">1</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = 3" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">3</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = 5" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">5</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = 10" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">10</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = ''" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-gray-500 hover:border-red-500 transition-all">Clear</button>
                    </div>
                    
                    <div class="flex gap-3">
                        <button onclick="document.getElementById('batchMintQuantityModal').remove()" 
                                class="flex-1 p-3 rounded-lg border border-white/10 text-gray-400 hover:bg-white/5 transition-all">
                            Cancel
                        </button>
                        <button onclick="window.startBatchMint('${collectionId}')" 
                                class="flex-1 btn-primary p-3">
                            Start Minting
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        window.startBatchMint = async (collectionId) => {
            const quantity = parseInt(document.getElementById('batchMintQuantity')?.value || 1);
            
            if (isNaN(quantity) || quantity < 1 || quantity > 10) {
                window.notify("Please enter a quantity between 1-10", "error");
                return;
            }
            
            // Remove quantity modal
            document.getElementById('batchMintQuantityModal')?.remove();
            
            // If quantity is 1, just use normal mint
            if (quantity === 1) {
                await window.mintFromCollection(collectionId);
            } else {
                // Use batch mint
                await window.executeBatchMint(collectionId, quantity);
            }
        };

        window.mintFromCollection = async (collectionId) => {
            if (!state.address) {
                return window.notify("Connect wallet first", "error");
            }
            
            // Clear any previous mint status
            const existingBadge = document.querySelector('.mint-status-badge');
            if (existingBadge) existingBadge.remove();
            
            try {
                window.showMintStatus('pending', 'Initializing mint...');
                
                const pipeline = window.createKeetaMintPipeline();
                const result = await pipeline.executeMint({
                    collectionId,
                    userWallet: state.address,
                    userClient: state.keetaClient,
                    userAccount: state.keetaAccount,
                    escrowClient: state.escrowClient,
                    escrowAccount: state.escrowAccount
                });
                
                // CRITICAL: Only show ONE status based on result
                if (result.success) {
                    console.log("‚úÖ Mint pipeline succeeded:", result);
                    window.showMintStatus('confirmed', '‚úÖ Mint Confirmed!');
                    
                    // Single success notification
                    window.notify("‚úÖ NFT minted successfully!", "success");
                    
                    // Refresh UI
                    window.refreshBalance();
                    setTimeout(async () => {
                        await window.loadNFTsFromFirebase();
                        window.renderCollection();
                        await window.loadCollections();
                        await window.loadTraitCounts();
                    }, 2000);
                } else {
                    // Only show failure if result.success is false
                    console.error("‚ùå Mint pipeline failed:", result.error);
                    window.showMintStatus('failed', result.error || 'Mint failed');
                    window.notify(`‚ùå Mint failed: ${result.error}`, "error");
                }
                
                return result;
                
            } catch (error) {
                console.error("‚ùå Mint exception:", error);
                window.showMintStatus('failed', 'Unexpected error');
                window.notify(`‚ùå Mint failed: ${error.message}`, "error");
                return { success: false, error: error.message };
            }
        };

        // FIX #7: Bulk minting function
        window.mintMultipleFromCollection = async (collectionId) => {
            if (!state.address) {
                return window.notify("Connect wallet first", "error");
            }
            
            // Get selected quantity
            const quantitySelect = document.getElementById(`mintQuantity_${collectionId}`);
            const quantity = parseInt(quantitySelect?.value || 1);
            
            if (quantity < 1 || quantity > 10) {
                return window.notify("Invalid quantity (1-10)", "error");
            }
            
            try {
                window.notify(`üé≤ Minting ${quantity} NFTs...`, "success");
                
                let successCount = 0;
                let failedCount = 0;
                
                // ‚ö° PARALLEL minting - all at once for speed!
                console.log(`‚ö° Starting ${quantity} parallel mints...`);
                
                const mintPromises = [];
                for (let i = 0; i < quantity; i++) {
                    const mintNum = i + 1;
                    
                    const mintPromise = (async () => {
                        console.log(`üé® Starting mint ${mintNum}/${quantity}`);
                        try {
                            const result = await window.mintFromCollection(collectionId);
                            
                            // Check if mint actually succeeded
                            if (result && result.success) {
                                successCount++;
                                console.log(`‚úÖ Mint ${mintNum} SUCCESS`);
                            } else {
                                failedCount++;
                                console.error(`‚ùå Mint ${mintNum} FAILED:`, result?.error || 'Unknown error');
                            }
                        } catch (error) {
                            console.error(`‚ùå Mint ${mintNum} exception:`, error);
                            failedCount++;
                        }
                    })();
                    
                    mintPromises.push(mintPromise);
                    
                    // Tiny 100ms stagger
                    if (i < quantity - 1) {
                        await new Promise(r => setTimeout(r, 100));
                    }
                }
                
                // Wait for all to complete
                console.log(`‚è≥ Waiting for all ${quantity} mints...`);
                await Promise.allSettled(mintPromises);
                console.log(`‚úÖ All mints complete!`)
                
                // Final notification
                if (successCount > 0) {
                    window.notify(`‚úÖ Successfully minted ${successCount}/${quantity} NFTs!`, "success");
                } else {
                    window.notify(`‚ùå All mints failed`, "error");
                }
                
                // Refresh collection data
                await window.loadCollections();
                window.renderCollections();
                
                // FIX #7: Also refresh user's collection view  
                setTimeout(async () => {
                    await window.loadNFTsFromFirebase();
                    window.renderCollection();
                }, 2000);
                
            } catch (error) {
                console.error("Bulk mint error:", error);
                window.notify(`‚ùå Bulk mint failed: ${error.message}`, "error");
            }
        };

        window.executeMintSwap = async (nftAddr, collection, meta, mintIndex) => {
            try {
                console.log("‚öõÔ∏è Creating atomic swap...");
                
                // Check for phase-based pricing
                let totalPrice = collection.priceKTA;
                const activePhase = window.getActivePhaseForWallet(collection.collectionId, state.address);
                
                if (activePhase) {
                    totalPrice = activePhase.priceKTA;
                    console.log(`üíé Phase pricing active: "${activePhase.name}" = ${totalPrice} KTA`);
                } else {
                    console.log(`üí∞ Standard pricing: ${totalPrice} KTA`);
                }
                
                const marketplaceFee = totalPrice * PRIMARY_SALE_MARKETPLACE_PERCENT;
                const creatorPayment = totalPrice * PRIMARY_SALE_CREATOR_PERCENT;
                
                console.log(`üí∞ Primary sale split: Creator ${creatorPayment} KTA (90%) | Marketplace ${marketplaceFee} KTA (10%)`);
                
                if (typeof state.keetaClient.init === 'function') {
                    await state.keetaClient.init();
                }
                if (typeof state.escrowClient.init === 'function') {
                    await state.escrowClient.init();
                }
                
                const buyerBuilder = state.keetaClient.initBuilder();
                buyerBuilder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                
                buyerBuilder.send(
                    KeetaNet.lib.Account.fromPublicKeyString(collection.creator),
                    BigInt(Math.floor(creatorPayment * KTA_DECIMALS)),
                    state.keetaClient.baseToken
                );
                
                buyerBuilder.send(
                    KeetaNet.lib.Account.fromPublicKeyString(MARKETPLACE_FEE_WALLET),
                    BigInt(Math.floor(marketplaceFee * KTA_DECIMALS)),
                    state.keetaClient.baseToken
                );
                
                const escrowBuilder = state.escrowClient.initBuilder();
                escrowBuilder.updateAccounts({ signer: state.escrowAccount, account: state.escrowAccount });
                escrowBuilder.send(
                    KeetaNet.lib.Account.fromPublicKeyString(state.address),
                    1n,
                    KeetaNet.lib.Account.fromPublicKeyString(nftAddr)
                );
                
                await state.keetaClient.computeBuilderBlocks(buyerBuilder);
                await state.escrowClient.computeBuilderBlocks(escrowBuilder);
                
                console.log("‚öõÔ∏è Publishing atomic swap...");
                
                const [buyerTx, escrowTx] = await Promise.all([
                    state.keetaClient.publishBuilder(buyerBuilder),
                    state.escrowClient.publishBuilder(escrowBuilder)
                ]);
                
                console.log("‚úÖ Atomic swap complete!");
                
                // Custom replacer to handle BigInt serialization
                const bigIntReplacer = (key, value) => {
                    return typeof value === 'bigint' ? value.toString() : value;
                };
                
                console.log("üìù Buyer tx (full):", JSON.stringify(buyerTx, bigIntReplacer, 2));
                console.log("üìù Escrow tx (full):", JSON.stringify(escrowTx, bigIntReplacer, 2));
                
                // Extract REAL transaction hash from blocks - Try multiple methods
                let txHash = null;
                
                // Method 1: Direct access to first block hash
                try {
                    if (buyerTx?.voteStaple?.blocks?.[0]?.$hash) {
                        txHash = buyerTx.voteStaple.blocks[0].$hash;
                        console.log("‚úÖ Method 1 (buyer blocks[0]): ", txHash);
                    }
                } catch (e) {
                    console.warn("‚ùå Method 1 failed:", e.message);
                }
                
                // Method 2: Try escrow tx
                if (!txHash) {
                    try {
                        if (escrowTx?.voteStaple?.blocks?.[0]?.$hash) {
                            txHash = escrowTx.voteStaple.blocks[0].$hash;
                            console.log("‚úÖ Method 2 (escrow blocks[0]): ", txHash);
                        }
                    } catch (e) {
                        console.warn("‚ùå Method 2 failed:", e.message);
                    }
                }
                
                // Method 3: Try second block (vote block)
                if (!txHash) {
                    try {
                        if (buyerTx?.voteStaple?.blocks?.[1]?.$hash) {
                            txHash = buyerTx.voteStaple.blocks[1].$hash;
                            console.log("‚úÖ Method 3 (buyer blocks[1]): ", txHash);
                        }
                    } catch (e) {
                        console.warn("‚ùå Method 3 failed:", e.message);
                    }
                }
                
                // Method 4: Try accessing as property without ?. operator
                if (!txHash) {
                    try {
                        const blocks = buyerTx.voteStaple.blocks;
                        if (blocks && blocks.length > 0) {
                            txHash = blocks[0].$hash || blocks[0]['$hash'];
                            console.log("‚úÖ Method 4 (direct property): ", txHash);
                        }
                    } catch (e) {
                        console.warn("‚ùå Method 4 failed:", e.message);
                    }
                }
                
                // Method 5: Parse from JSON string (last resort)
                if (!txHash) {
                    try {
                        const txJson = JSON.stringify(buyerTx, bigIntReplacer);
                        const hashMatch = txJson.match(/"(\$hash|hash)":\s*"([A-F0-9]{64})"/);
                        if (hashMatch) {
                            txHash = hashMatch[2];
                            console.log("‚úÖ Method 5 (regex from JSON): ", txHash);
                        }
                    } catch (e) {
                        console.warn("‚ùå Method 5 failed:", e.message);
                    }
                }
                
                console.log("üîç Final extracted tx hash:", txHash);
                
                // Brief delay to ensure blockchain confirmation
                await new Promise(r => setTimeout(r, 500));
                
                // SMART IMAGE PATH RESOLVER - Handles ALL IPFS formats
                function resolveImagePath(imageField, collectionCid, mintIndex) {
                    console.log(`üîç Resolving image path from: "${imageField}"`);
                    
                    if (!imageField) {
                        console.warn("‚ö†Ô∏è No image field in metadata, using default");
                        return `${collectionCid}/images/${String(mintIndex + 1).padStart(3, '0')}.png`;
                    }
                    
                    let imagePath = imageField;
                    
                    // 1. Remove ipfs:// protocol
                    imagePath = imagePath.replace(/^ipfs:\/\//, '');
                    
                    // 2. Handle {{COLLECTION_CID}} placeholder (Bueno format)
                    imagePath = imagePath.replace(/\{\{COLLECTION_CID\}\}/, collectionCid);
                    imagePath = imagePath.replace(/\{\{CID\}\}/, collectionCid);
                    
                    // 3. Check if path already has a CID
                    const hasCid = imagePath.match(/^(bafybei[a-z0-9]{52}|Qm[a-zA-Z0-9]{44})/);
                    
                    if (hasCid) {
                        // Path already includes full CID (e.g., "bafybei.../images/001.png")
                        console.log(`‚úÖ Path has CID: ${imagePath}`);
                        return imagePath;
                    }
                    
                    // 4. Check for various relative path formats
                    // Format: "images/001.png" or "images/1.png"
                    if (imagePath.match(/^images?\//i)) {
                        const fullPath = `${collectionCid}/${imagePath}`;
                        console.log(`‚úÖ Relative path: ${imagePath} ‚Üí ${fullPath}`);
                        return fullPath;
                    }
                    
                    // Format: "001.png" or "1.png" (just filename)
                    if (imagePath.match(/^\d+\.png$/i)) {
                        const fullPath = `${collectionCid}/images/${imagePath}`;
                        console.log(`‚úÖ Filename only: ${imagePath} ‚Üí ${fullPath}`);
                        return fullPath;
                    }
                    
                    // 5. Handle absolute paths that start with CID but might be malformed
                    // e.g., "CID/001.png" without images/ folder
                    if (imagePath.includes('/')) {
                        // Check if it's missing the collection CID
                        if (!hasCid) {
                            const fullPath = `${collectionCid}/${imagePath}`;
                            console.log(`‚úÖ Adding CID to path: ${imagePath} ‚Üí ${fullPath}`);
                            return fullPath;
                        }
                    }
                    
                    // 6. Last resort: assume it's a relative path and prepend CID + images/
                    const fullPath = `${collectionCid}/images/${imagePath}`;
                    console.log(`‚ö†Ô∏è Unknown format, guessing: ${imagePath} ‚Üí ${fullPath}`);
                    return fullPath;
                }
                
                // Use smart resolver
                const fullImagePath = resolveImagePath(meta.image, collection.ipfsCid, mintIndex);
                console.log(`üñºÔ∏è Final image path: ${fullImagePath}`);
                
                const docId = `nft_${getNormalizedId(collection.collectionToken)}_${mintIndex}`;
                
                await setDoc(doc(db, 'nfts', docId), {
                    name: meta.name || `Unit #${mintIndex + 1}`,
                    imageCid: fullImagePath,
                    priceKTA: collection.priceKTA,
                    pricePunks: collection.pricePunks,
                    status: 'minted',
                    tokenId: nftAddr,
                    collectionToken: collection.collectionToken,
                    collectionId: collection.collectionId,
                    collectionTitle: collection.collectionTitle,
                    collection: meta.collection || collection.collectionTitle,
                    collectionDesc: collection.collectionDesc,
                    creator: collection.creator,
                    owner: state.address,
                    collectionThumbnailCid: collection.collectionThumbnailCid,
                    mintedAt: new Date().toISOString(),
                    wasBlindMinted: true,
                    attributes: meta.attributes || [],  // FIX #3: FULL attributes
                    description: meta.description || '',
                    externalUrl: meta.external_url || ''
                });
                
                // NOTE: mintedCount already incremented atomically above (line ~2266)
                // No need to update again here
                
                const walletTrackingRef = doc(db, 'artifacts', state.appId, 'public', 'data', 'walletMintTracking', `${state.address}_${collection.collectionId}`);
                const trackingSnap = await getDoc(walletTrackingRef);
                const currentCount = trackingSnap.exists() ? trackingSnap.data().mintedCount : 0;
                
                await setDoc(walletTrackingRef, {
                    walletAddress: state.address,
                    collectionId: collection.collectionId,
                    mintedCount: currentCount + 1
                });
                
                await window.updateTraitCounts(collection.collectionId, meta.attributes || []);
                
                // Record mint transaction (don't let this break the flow)
                try {
                    await window.recordTransaction({
                        type: 'mint',
                        nftId: docId,
                        nftName: meta.name || `${collection.collectionTitle} #${mintIndex + 1}`,
                        collection: collection.collectionTitle,
                        collectionId: collection.collectionId,
                        price: collection.priceKTA,
                        currency: 'KTA',
                        counterParty: collection.creator,
                        txHash: txHash
                    });
                    console.log("‚úÖ Transaction recorded with hash:", txHash);
                    await window.loadTransactions();
                } catch (txError) {
                    console.warn("‚ö†Ô∏è Could not record transaction:", txError.message);
                }
                
                window.notify("NFT minted successfully!", "success");
                window.refreshBalance();
                await window.loadNFTsFromFirebase();
                await window.loadCollections();
                await window.loadTraitCounts();
                
                // Start auto-sync for wallet changes
                window.startAutoSync(); // Load trait counts for color coding
                
            } catch (error) {
                console.error("Swap error:", error);
                throw error;
            }
        };

        // Collection rendering and Forge functions
        window.renderCollections = () => {
            console.log("üé≤ renderCollections called");
            const container = document.getElementById('dropGrid');
            if (!container) {
                console.error("‚ùå dropGrid element not found!");
                return;
            }
            console.log("üìä Active collections:", state.collections.filter(c => c.blindMintEnabled && c.remainingSupply > 0).length);
            
            const activeCollections = state.collections.filter(c => c.blindMintEnabled && c.remainingSupply > 0);
            
            if (activeCollections.length === 0) {
                container.innerHTML = '<div class="col-span-full text-center text-gray-500 fira text-sm py-20">No active blind drops</div>';
                return;
            }
            
            // Dice image hosted on IPFS
            const DICE_IMAGE_URL = 'https://gateway.pinata.cloud/ipfs/bafybeidgzwxcrhvf2jpo65gtqrt33otfk4yqwjc5vadntpp4yntqohvgtm';
            
            container.innerHTML = activeCollections.map(col => {
                // Check whitelist status
                const whitelistSettings = state.whitelistSettings[col.collectionId];
                let buttonClass = 'btn-primary w-full py-3 group-hover:bg-cyan-500/20';
                let buttonText = 'üé≤ Mystery Forge';
                let buttonDisabled = '';
                let statusBadge = '';
                
                if (whitelistSettings && whitelistSettings.enabled) {
                    const wallets = state.whitelistWallets[col.collectionId] || [];
                    const entry = state.address ? wallets.find(w => w.walletAddress.toLowerCase() === state.address.toLowerCase()) : null;
                    
                    // Check mint window
                    const now = Date.now();
                    let windowClosed = false;
                    
                    if (whitelistSettings.mintWindowStart) {
                        const startTime = new Date(whitelistSettings.mintWindowStart).getTime();
                        if (now < startTime) {
                            const minsLeft = Math.ceil((startTime - now) / 60000);
                            buttonClass = 'w-full py-3 bg-orange-500/20 border border-orange-500/30 text-orange-400 cursor-not-allowed';
                            buttonText = `‚è∞ Starts in ${minsLeft}m`;
                            buttonDisabled = 'disabled';
                            windowClosed = true;
                        }
                    }
                    
                    if (whitelistSettings.mintWindowEnd && !windowClosed) {
                        const endTime = new Date(whitelistSettings.mintWindowEnd).getTime();
                        if (now > endTime) {
                            buttonClass = 'w-full py-3 bg-red-500/20 border border-red-500/30 text-red-400 cursor-not-allowed';
                            buttonText = '‚è∞ Window Closed';
                            buttonDisabled = 'disabled';
                            windowClosed = true;
                        }
                    }
                    
                    if (!windowClosed) {
                        if (state.address && entry) {
                            // Whitelisted
                            if (entry.usedMints >= entry.maxMints) {
                                // Max reached
                                buttonClass = 'w-full py-3 bg-gray-500/20 border border-gray-500/30 text-gray-400 cursor-not-allowed';
                                buttonText = `‚úì Max Reached (${entry.maxMints})`;
                                buttonDisabled = 'disabled';
                            } else {
                                // Can mint
                                buttonText = `üé≤ Mint (${entry.usedMints}/${entry.maxMints})`;
                                statusBadge = '<div class="absolute top-2 left-2 bg-green-500/90 px-2 py-1 rounded text-[8px] orbitron font-black text-black">‚úì WHITELISTED</div>';
                            }
                        } else if (state.address) {
                            // Not whitelisted
                            buttonClass = 'w-full py-3 bg-red-500/20 border border-red-500/30 text-red-400 cursor-not-allowed';
                            buttonText = 'üîí Not Whitelisted';
                            buttonDisabled = 'disabled';
                            statusBadge = '<div class="absolute top-2 left-2 bg-red-500/90 px-2 py-1 rounded text-[8px] orbitron font-black text-white">üîí WHITELIST ONLY</div>';
                        } else {
                            // Not connected
                            buttonClass = 'w-full py-3 bg-purple-500/20 border border-purple-500/30 text-purple-400';
                            buttonText = 'üîå Connect Wallet';
                            statusBadge = '<div class="absolute top-2 left-2 bg-purple-500/90 px-2 py-1 rounded text-[8px] orbitron font-black text-white">üîí WHITELIST ACTIVE</div>';
                        }
                    }
                }
                
                return `
                <div class="glass-card p-6 space-y-4 hover:border-cyan-500/20 transition-all group">
                    <div class="aspect-square bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded-xl flex items-center justify-center overflow-hidden border border-cyan-500/30 shadow-[0_0_30px_rgba(0,255,255,0.2)] relative">
                        ${statusBadge}
                        <div class="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48cGF0dGVybiBpZD0iZ3JpZCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiBwYXR0ZXJuVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aCBkPSJNIDIwIDAgTCAwIDAgMCAyMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2JhKDAsMjU1LDI1NSwwLjEpIiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvcGF0dGVybj48L2RlZnM+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmlkKSIvPjwvc3ZnPg==')] opacity-20"></div>
                        <img src="${DICE_IMAGE_URL}" 
                             class="w-full h-full object-cover relative z-10 group-hover:scale-110 transition-transform duration-300 sharp-img will-change-transform" 
                             style="transform-origin: center; backface-visibility: hidden;"
                             onerror="this.style.display='none';this.parentElement.innerHTML+='<div class=\\'text-8xl relative z-10 animate-pulse\\' style=\\'filter: drop-shadow(0 0 20px rgba(0,255,255,0.5));\\'>üé≤</div>'" 
                             alt="Mystery Drop"/>
                    </div>
                    <div>
                        <h3 class="orbitron text-lg font-bold text-cyan-400">${col.collectionTitle}</h3>
                        <p class="fira text-xs text-gray-500 mt-1">${col.collectionDesc}</p>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="fira text-sm font-bold ${(() => {
                            const activePhase = state.address ? window.getActivePhaseForWallet(col.collectionId, state.address) : null;
                            const price = activePhase ? activePhase.priceKTA : col.priceKTA;
                            return price === 0 ? 'text-green-400' : 'text-white';
                        })()}">${(() => {
                            const activePhase = state.address ? window.getActivePhaseForWallet(col.collectionId, state.address) : null;
                            const price = activePhase ? activePhase.priceKTA : col.priceKTA;
                            const phaseName = activePhase ? ` (${activePhase.name})` : '';
                            return price === 0 ? 'FREE' : `${price} KTA${phaseName}`;
                        })()}</span>
                        <span class="fira text-xs text-orange-400">Remaining: ${col.remainingSupply}/${col.totalSupply}</span>
                    </div>
                    
                    <!-- FIX #7: Quantity selector for bulk minting -->
                    <div class="flex items-center gap-2 ${buttonDisabled ? 'opacity-50 pointer-events-none' : ''}">
                        <label class="fira text-xs text-gray-400">Qty:</label>
                        <select id="mintQuantity_${col.collectionId}" class="bg-black/40 border border-white/10 rounded px-2 py-1 text-xs text-white min-w-[60px]" ${buttonDisabled}>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="5">5</option>
                            <option value="10">10</option>
                        </select>
                        <span class="fira text-xs text-gray-500">NFTs</span>
                    </div>
                    
                    <button class="${buttonClass}" ${buttonDisabled} onclick="${buttonDisabled ? '' : `window.mintMultipleFromCollection('${col.collectionId}')`}">
                        ${buttonText}
                    </button>
                </div>
            `;
            }).join('');
        };

        window.createBlindMintCollection = async () => {
            if (state.isForging) {
                window.notify("Collection creation already in progress", "error");
                return;
            }
            
            const collectionTitle = document.getElementById('collectionTitleInput')?.value.trim() || "";
            const cidVal = document.getElementById('batchFolderCid')?.value.trim() || "";
            const totalSupply = parseInt(document.getElementById('totalSupplyInput')?.value) || 10;
            const maxMintsPerWallet = parseInt(document.getElementById('maxMintsPerWalletInput')?.value) || 1;
            const pktaVal = parseFloat(document.getElementById('batchPriceKTA')?.value) || 0;
            const punksVal = parseFloat(document.getElementById('batchPricePunks')?.value) || 0;
            const isDrop = document.getElementById('enableDropMode')?.checked || false;
            const desc = document.getElementById('collectionDescInput')?.value || "";
            const colThumb = document.getElementById('collectionThumbnailInput')?.value.trim() || "";
            const collectionType = document.querySelector('input[name="collectionType"]:checked')?.value || "external_ipfs";
            const creatorRoyalty = parseFloat(document.getElementById('creatorRoyaltyPercent')?.value) || 5; // Default 5%
            
            if (!collectionTitle) return window.notify("Collection Title Required", "error");
            if (!cidVal) return window.notify("IPFS CID Required", "error");
            if (!state.keetaClient) return window.notify("Connect wallet first", "error");
            if (state.scannedFiles.length === 0) return window.notify("No files scanned", "error");
            if (totalSupply > state.scannedFiles.length) return window.notify(`Supply exceeds scanned files`, "error");
            
            if (isDrop && !state.escrowClient) {
                window.notify("Initializing escrow wallet...", "success");
                await initializeEscrowWallet();
                if (!state.escrowClient) return window.notify("Escrow initialization failed", "error");
            }
            
            state.isForging = true;
            const startBtn = document.getElementById('startForgeBtn');
            if (startBtn) startBtn.disabled = true;
            
            window.debugLog("üöÄ Creating blind mint collection...");
            
            try {
                const client = isDrop ? state.escrowClient : state.keetaClient;
                const signer = isDrop ? state.escrowAccount : state.keetaAccount;
                
                if (!client) throw new Error("Client not initialized");
                if (typeof client.init === 'function') await client.init();
                
                window.debugLog("üîß Creating collection token...");
                
                const cB = client.initBuilder(); 
                cB.updateAccounts({ signer, account: signer });
                const cID = cB.generateIdentifier(KeetaNet.lib.Account.AccountKeyAlgorithm.TOKEN);
                await client.computeBuilderBlocks(cB); 
                
                // FIX #8: Add collection metadata to token
                const collectionMetadata = {
                    name: collectionTitle,
                    symbol: collectionTitle.replace(/\s+/g, '').substring(0, 8).toUpperCase(),
                    description: desc || `${collectionTitle} NFT Collection`,
                    totalSupply: totalSupply,
                    tokenType: "COLLECTION",
                    standard: "KeeTa-Collection",
                    ipfsCid: cidVal,
                    thumbnail: colThumb,
                    createdAt: new Date().toISOString(),
                    creator: signer.publicKeyString.get(),
                    blindMintEnabled: isDrop,
                    priceKTA: pktaVal,
                    maxMintsPerWallet: maxMintsPerWallet
                };
                
                cB.modifyTokenSupply(1n, { 
                    account: cID.account,
                    metadata: JSON.stringify(collectionMetadata)
                });
                await client.publishBuilder(cB);
                const colAddr = cID.account.publicKeyString.get();
                
                window.debugLog(`‚úÖ Collection token: ${colAddr.substring(0, 12)}...`);

                const collectionId = `collection_${getNormalizedId(colAddr)}`;
                
                // RANDOM MINTING: Shuffle scanned files for blind mint
                let mintOrder = state.scannedFiles.slice(0, totalSupply);
                
                console.log("üîç PRE-SHUFFLE ORDER (first 10):", mintOrder.slice(0, 10));
                console.log("üé≤ Blind mint enabled?", isDrop);
                
                if (isDrop && mintOrder.length > 0) {
                    // Fisher-Yates shuffle for truly random order
                    for (let i = mintOrder.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [mintOrder[i], mintOrder[j]] = [mintOrder[j], mintOrder[i]];
                    }
                    console.log("üé≤ SHUFFLED! New order (first 10):", mintOrder.slice(0, 10));
                    console.log("üé≤ Collection will mint in this random order");
                } else {
                    console.log("‚ö†Ô∏è Shuffle SKIPPED - blind mint not enabled or no files");
                }
                
                await setDoc(doc(db, 'collections', collectionId), {
                    collectionId, collectionTitle, collectionName: collectionTitle, collection: collectionTitle,
                    collectionType, collectionToken: colAddr,
                    totalSupply, mintedCount: 0, remainingSupply: totalSupply, ipfsCid: cidVal,
                    priceKTA: state.priceMode !== 'punks' ? pktaVal : 0,
                    pricePunks: state.priceMode !== 'kta' ? punksVal : 0,
                    maxMintsPerWallet, blindMintEnabled: isDrop,
                    collectionDesc: desc || "Metadata encrypted.",
                    collectionThumbnailCid: colThumb, creator: state.address,
                    createdBy: state.address, createdAt: new Date().toISOString(),
                    creatorRoyaltyPercent: creatorRoyalty / 100, // Convert 5 to 0.05
                    scannedFiles: mintOrder
                });
                
                window.debugLog(`‚úÖ Collection created: ${collectionTitle}`);
                window.notify(`Collection "${collectionTitle}" deployed!`, "success");
                
                document.getElementById('collectionTitleInput').value = '';
                document.getElementById('batchFolderCid').value = '';
                document.getElementById('collectionDescInput').value = '';
                document.getElementById('collectionThumbnailInput').value = '';
                state.scannedFiles = [];
                document.getElementById('forgeReadyArea')?.classList.add('hidden');
                
                await window.loadCollections();
                
            } catch (error) {
                console.error("Collection creation error:", error);
                window.notify(`Collection creation failed: ${error.message}`, "error");
            } finally {
                state.isForging = false;
                if (startBtn) startBtn.disabled = false;
            }
        };

        window.scanCollectionFolder = async () => {
            const cid = document.getElementById('batchFolderCid')?.value.trim() || "";
            const totalSupply = parseInt(document.getElementById('totalSupplyInput')?.value) || 10;
            
            if (!cid) return window.notify("CID Required", "error");
            
            try {
                window.notify("Scanning Protocol CID...", "success");
                console.log("üîç Scanning IPFS folder:", cid);
                
                const gateways = [
                    `https://ipfs.io/ipfs/${cid}`,
                    `https://cloudflare-ipfs.com/ipfs/${cid}`,
                    `https://gateway.pinata.cloud/ipfs/${cid}`
                ];
                
                let html = null;
                
                for (const gateway of gateways) {
                    try {
                        const res = await fetch(gateway, { method: 'GET', mode: 'cors' });
                        if (res.ok) {
                            html = await res.text();
                            break;
                        }
                    } catch (err) {
                        console.warn(`Gateway failed: ${gateway}`);
                    }
                }
                
                if (!html) {
                    console.log("‚ö†Ô∏è IPFS scan failed, trying auto-detection...");
                    // Try to fetch first file to detect format
                    const testFormats = [
                        `001.json`,  // Standard format
                        `0001.json`, // 4-digit padding
                        `1.json`,    // 1-indexed JSON
                        `0`,         // Bueno format (no extension)
                        `1`          // Bueno 1-indexed
                    ];
                    
                    let detectedFormat = null;
                    for (const testFile of testFormats) {
                        try {
                            const res = await fetch(`https://ipfs.io/ipfs/${cid}/${testFile}`);
                            if (res.ok) {
                                detectedFormat = testFile;
                                console.log(`‚úÖ Detected format: ${testFile}`);
                                break;
                            }
                        } catch (e) { continue; }
                    }
                    
                    if (detectedFormat) {
                        // Generate file list based on detected format
                        if (detectedFormat.endsWith('.json')) {
                            if (detectedFormat.startsWith('0001')) {
                                // 4-digit padding
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(4, '0')}.json`);
                            } else if (detectedFormat.startsWith('001')) {
                                // 3-digit padding (standard)
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                            } else {
                                // No padding
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${i + 1}.json`);
                            }
                        } else {
                            // Bueno format (no extension)
                            if (detectedFormat === '0') {
                                // 0-indexed
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => String(i));
                            } else {
                                // 1-indexed
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => String(i + 1));
                            }
                        }
                        console.log(`üìã Generated ${state.scannedFiles.length} files in format: ${detectedFormat}`);
                    } else {
                        // Ultimate fallback: standard format
                        state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                        console.log("‚ö†Ô∏è Could not detect format, using standard: 001.json, 002.json...");
                    }
                } else {
                    // Parse HTML for file list
                    const matches = html.match(/href="([^"]*\.json[^"]*)"/gi) || [];
                    const jsonFiles = [...new Set(matches.map(m => m.match(/href="([^"]*)"/)[1].split('/').pop().split('?')[0]))].filter(f => f.endsWith('.json')).sort();
                    
                    if (jsonFiles.length > 0) {
                        state.scannedFiles = jsonFiles.slice(0, totalSupply);
                        console.log(`‚úÖ Found ${state.scannedFiles.length} .json files`);
                    } else {
                        // No .json files, check for Bueno format (plain numbers)
                        const allMatches = html.match(/href="([^"]+)"/gi) || [];
                        const numberFiles = [...new Set(allMatches.map(m => {
                            const match = m.match(/href="([^"]*)"/);
                            return match ? match[1].split('/').pop().split('?')[0] : null;
                        }))].filter(f => f && f !== '..' && f !== '.' && /^\d+$/.test(f)).sort((a, b) => parseInt(a) - parseInt(b));
                        
                        if (numberFiles.length > 0) {
                            state.scannedFiles = numberFiles.slice(0, totalSupply);
                            console.log(`‚úÖ Found ${state.scannedFiles.length} Bueno-format files (plain numbers)`);
                        } else {
                            // Fallback to standard
                            state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                        }
                    }
                }
                
                if (state.scannedFiles.length > 0) {
                    document.getElementById('forgeReadyArea')?.classList.remove('hidden');
                    document.getElementById('previewDetails')?.classList.remove('hidden');
                    
                    const countEl = document.getElementById('previewCount');
                    if (countEl) countEl.textContent = state.scannedFiles.length;
                    
                    try {
                        console.log("üì∏ [DEBUG] CID:", cid);
                        console.log("üì∏ [DEBUG] First file:", state.scannedFiles[0]);
                        console.log("üì∏ Loading preview from:", state.scannedFiles[0]);
                        const metadataFetchUrl = `https://gateway.pinata.cloud/ipfs/${cid}/${state.scannedFiles[0]}`;
                        console.log("üì∏ [DEBUG] Fetching metadata from:", metadataFetchUrl);
                        const mR = await fetch(metadataFetchUrl);
                        console.log("üì∏ [DEBUG] Fetch response status:", mR.status, mR.ok);
                        const meta = await mR.json();
                        console.log("üì∏ Metadata:", meta);
                        
                        let imageUrl = '';
                        if (meta.image) {
                            if (meta.image.startsWith('ipfs://')) {
                                imageUrl = meta.image.replace('ipfs://', 'https://gateway.pinata.cloud/ipfs/');
                            } else if (meta.image.startsWith('http')) {
                                imageUrl = meta.image;
                            } else if (meta.image.includes('/')) {
                                imageUrl = `https://gateway.pinata.cloud/ipfs/${meta.image}`;
                            } else {
                                imageUrl = `https://gateway.pinata.cloud/ipfs/${cid}/${meta.image}`;
                            }
                        }
                        
                        console.log("üì∏ Image URL:", imageUrl);
                        
                        const previewContainer = document.getElementById('previewImageContainer');
                        if (previewContainer && imageUrl) {
                            previewContainer.innerHTML = `<img src="${imageUrl}" class="sharp-img w-full h-full object-cover" onload="console.log('‚úÖ Preview image loaded')" onerror="console.error('‚ùå Preview image failed'); this.parentElement.innerHTML='<div class=\\'w-full h-full bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded flex items-center justify-center text-4xl\\'>üé®</div>'">`;
                        }
                        
                    } catch (e) {
                        console.warn("üì∏ Preview failed:", e);
                        const colThumb = document.getElementById('collectionThumbnailInput')?.value.trim() || "";
                        const previewContainer = document.getElementById('previewImageContainer');
                        if (previewContainer) {
                            if (colThumb) {
                                previewContainer.innerHTML = `<img src="https://gateway.pinata.cloud/ipfs/${colThumb}" class="sharp-img w-full h-full object-cover" onerror="this.parentElement.innerHTML='<div class=\\'w-full h-full bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded flex items-center justify-center text-4xl\\'>üé®</div>'">`;
                            } else {
                                previewContainer.innerHTML = `<div class="w-full h-full bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded flex items-center justify-center text-4xl">üé®</div>`;
                            }
                        }
                    }
                    
                    window.notify(`‚úÖ Validated ${state.scannedFiles.length} units`, "success");
                } else {
                    window.notify("No files found", "error");
                }
                
            } catch (e) { 
                console.error("Scan error:", e);
                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                if (state.scannedFiles.length > 0) {
                    document.getElementById('forgeReadyArea')?.classList.remove('hidden');
                    document.getElementById('previewDetails')?.classList.remove('hidden');
                }
            }
        };

        // Marketplace rendering with volume-based sorting
        window.renderMarketplace = () => {
            console.log("üé® renderMarketplace called");
            console.log("üìä state.nfts.length:", state.nfts?.length || 0);
            console.log("üìä state.collections.length:", state.collections?.length || 0);
            
            const grid = document.getElementById('collectionListGrid');
            if (!grid) {
                console.error("‚ùå collectionListGrid element not found!");
                return;
            }
            
            if (state.nfts.length === 0) {
                grid.innerHTML = Array.from({length: 5}).map(() => `<div class="unit-slot"></div>`).join('');
                return;
            }
            
            const search = document.getElementById('marketSearch')?.value.toLowerCase() || "";
            const collections = {};
            
            state.nfts.forEach(n => {
                const k = getNormalizedId(n.collectionToken);
                if (!collections[k]) collections[k] = { ...n, count: 0, floorKTA: null, floorPUNKS: null, volume24h: 0, salesCount: 0 };
                collections[k].count++;
                
                // Track sales for volume calculation
                if (n.soldAt && n.soldPrice && n.soldCurrency === 'KTA') {
                    const saleTime = new Date(n.soldAt).getTime();
                    const now = Date.now();
                    if (now - saleTime < 24 * 3600000) { // Last 24 hours
                        collections[k].volume24h += n.soldPrice;
                        collections[k].salesCount++;
                    }
                }
                
                if (n.isListed) {
                    if (n.listedCurrency === 'KTA') {
                        if (!collections[k].floorKTA || n.listedPrice < collections[k].floorKTA) collections[k].floorKTA = n.listedPrice;
                    } else if (n.listedCurrency === 'PUNKS') {
                        if (!collections[k].floorPUNKS || n.listedPrice < collections[k].floorPUNKS) collections[k].floorPUNKS = n.listedPrice;
                    }
                }
            });
            
            const filtered = Object.keys(collections).filter(k => (collections[k].collection || "").toLowerCase().includes(search));
            
            // Sort by 24h volume (highest first) - TRENDING
            const sorted = filtered.sort((a, b) => {
                const volA = collections[a].volume24h || 0;
                const volB = collections[b].volume24h || 0;
                return volB - volA; // Descending
            });
            
            grid.innerHTML = sorted.map(k => {
                const col = collections[k];
                const fullCollection = state.collections.find(c => getNormalizedId(c.collectionToken) === k);
                const thumbCid = fullCollection?.collectionThumbnailCid || col.collectionThumbnailCid || col.imageCid;
                const thumbUrl = thumbCid ? `https://gateway.pinata.cloud/ipfs/${thumbCid}` : `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23000' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-family='monospace' font-size='20'%3ECLASSIFIED%3C/text%3E%3C/svg%3E`;
                const floorText = col.floorKTA ? `${col.floorKTA.toFixed(2)} KTA` : (col.floorPUNKS ? `${col.floorPUNKS} PUNKS` : 'N/A');
                
                // Show volume badge for trending
                const volumeBadge = col.volume24h > 0 ? `
                    <div class="absolute top-2 right-2 bg-orange-500/90 px-2 py-1 rounded text-[7px] orbitron font-black text-black">
                        ${col.volume24h.toFixed(1)} KTA VOL
                    </div>
                ` : '';
                
                return `
                <div onclick="window.viewCollection('${k}')" class="glass-card p-6 flex flex-col group cursor-pointer border-white/5 hover:border-cyan-500/40 transition-all relative">
                    ${volumeBadge}
                    <img src="${thumbUrl}" class="sharp-img rounded-xl aspect-square object-cover mb-6 border border-white/10 group-hover:scale-105 transition-transform duration-300 shadow-2xl will-change-transform" style="transform-origin: center; backface-visibility: hidden;">
                    <h4 class="orbitron text-xs font-black text-white mb-2 uppercase">${col.collection || col.collectionTitle || col.collectionName || 'Unknown Collection'}</h4>
                    <div class="flex justify-between items-center mt-2 fira text-[9px] font-black uppercase">
                        <span class="text-gray-600">${col.count} POP</span>
                        <span class="text-cyan-400">Floor: ${floorText}</span>
                    </div>
                    <button onclick="event.stopPropagation(); window.makeOfferOnCollection('${k.replace(/'/g, "\\'")}')" class="w-full mt-3 p-2 border border-purple-500/30 text-purple-400 rounded-lg text-[8px] hover:bg-purple-500/10 orbitron font-bold uppercase transition-all">
                        Offer
                    </button>
                </div>`;
            }).join('');
        };

        window.renderDrops = () => { window.renderCollections(); };

        // FIX #1: Enhanced collection rendering with full traits
        window.renderCollection = async () => {
            const grid = document.getElementById('collectionGrid');
            if (!grid) return;
            
            const my = state.nfts.filter(n => (n.owner || "").toLowerCase() === (state.address || "").toLowerCase() && n.status !== 'drop');
            
            if (my.length === 0) {
                grid.innerHTML = Array.from({length: 5}).map(() => `<div class="unit-slot"></div>`).join('');
                return;
            }
            
            // FIX #1: Fetch metadata for missing traits
            for (const nft of my) {
                if (!nft.attributes || nft.attributes.length === 0) {
                    await window.fetchNFTMetadata(nft);
                }
            }
            
            grid.innerHTML = my.map(n => {
                const isListed = n.isListed || false;
                
                // Collection name display
                const collectionName = n.collectionName || n.collection || n.collectionTitle || 'Unknown Collection';
                
                // FIX: Build COMPLETE image URL (not partial path)
                const imgCid = window.getNFTImagePath(n);
                const imgUrl = imgCid ? `https://gateway.pinata.cloud/ipfs/${imgCid}` : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E';
                
                // Render traits
                const traitsHTML = window.renderNFTTraits(n, 'toggle', false);
                
                // Show price badge if listed
                const priceBadge = isListed ? `
                    <div class="absolute top-3 right-3 bg-green-500 text-black px-3 py-1 rounded-lg font-black text-xs orbitron shadow-lg border-2 border-green-400">
                        ${n.listedPrice} ${n.listedCurrency}
                    </div>
                ` : '';
                
                const listingButtons = isListed ? `
                    <div class="flex gap-2 mt-3">
                        <button onclick="window.editNFTPrice('${n.id}')" class="flex-1 p-2 rounded-lg border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">Edit</button>
                        <button onclick="window.cancelListing('${n.id}')" class="flex-1 p-2 rounded-lg border border-red-500/30 text-[8px] orbitron font-bold uppercase text-red-400 hover:bg-red-500/10 transition-all">Cancel</button>
                    </div>
                ` : `
                    <button onclick="window.listNFTForSale('${n.id}')" class="w-full mt-3 p-2 rounded-lg border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">List for Sale</button>
                `;
                
                // Enhanced listing status badge
                const statusBadge = isListed ? `
                    <div class="absolute top-2 right-2 z-10">
                        <div class="bg-gradient-to-br from-green-500 to-emerald-600 text-white px-3 py-1.5 rounded-lg font-black text-[10px] orbitron shadow-lg border border-green-400/50 flex items-center gap-1.5">
                            <span class="w-1.5 h-1.5 bg-white rounded-full animate-pulse"></span>
                            <span>LISTED</span>
                        </div>
                        <div class="mt-1 bg-black/80 backdrop-blur-sm text-green-400 px-2 py-1 rounded text-[11px] orbitron font-bold text-center border border-green-500/30">
                            ${n.listedPrice} ${n.listedCurrency}
                        </div>
                    </div>
                ` : '';
                
                // Get collection royalty for accurate fee calculation
                const nftCollection = state.collections.find(c => 
                    c.collectionId === n.collectionId || 
                    c.collectionToken === n.collectionToken
                );
                const royaltyPercent = nftCollection?.creatorRoyaltyPercent || 0.05; // Default 5%
                const marketplaceFee = 0.03; // Always 3%
                const sellerPercent = 1 - royaltyPercent - marketplaceFee; // What seller gets
                const youReceive = n.listedPrice * sellerPercent;
                
                // Listing management dropdown (only show if listed)
                const listingDropdown = isListed ? `
                    <div class="mt-3 border border-green-500/30 rounded-lg overflow-hidden bg-green-500/5">
                        <button onclick="toggleListingDropdown('${n.id}')" 
                                class="w-full p-2 flex items-center justify-between text-[9px] orbitron font-bold uppercase text-green-400 hover:bg-green-500/10 transition-all">
                            <span>üìä Manage Listing</span>
                            <svg id="dropdown-icon-${n.id}" class="w-3 h-3 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                            </svg>
                        </button>
                        <div id="listing-dropdown-${n.id}" class="hidden border-t border-green-500/20 p-2 space-y-2">
                            <div class="text-[8px] text-gray-400 mb-2">
                                <div class="flex justify-between mb-1">
                                    <span>Listed Price:</span>
                                    <span class="text-green-400 font-bold">${n.listedPrice} ${n.listedCurrency}</span>
                                </div>
                                <div class="flex justify-between mb-1">
                                    <span>Creator Royalty:</span>
                                    <span class="text-yellow-400 font-bold">${(royaltyPercent * 100).toFixed(1)}%</span>
                                </div>
                                <div class="flex justify-between mb-1">
                                    <span>Marketplace Fee:</span>
                                    <span class="text-purple-400 font-bold">3%</span>
                                </div>
                                <div class="flex justify-between border-t border-white/10 pt-1 mt-1">
                                    <span class="font-bold">You receive:</span>
                                    <span class="text-cyan-400 font-bold">${youReceive.toFixed(2)} ${n.listedCurrency}</span>
                                </div>
                            </div>
                            <button onclick="window.editNFTPrice('${n.id}')" 
                                    class="w-full p-2 rounded border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                                ‚úèÔ∏è Edit Price
                            </button>
                            <button onclick="window.cancelListing('${n.id}')" 
                                    class="w-full p-2 rounded border border-red-500/30 text-[8px] orbitron font-bold uppercase text-red-400 hover:bg-red-500/10 transition-all">
                                ‚ùå Cancel Listing
                            </button>
                        </div>
                    </div>
                ` : `
                    <button onclick="window.listNFTForSale('${n.id}')" 
                            class="w-full mt-3 p-2 rounded-lg border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                        üí∞ List for Sale
                    </button>
                `;
                
                return `
                <div class="glass-card p-4 flex flex-col group border-white/5 shadow-xl transition-all hover:border-magenta-500/30 hover:shadow-2xl hover:shadow-magenta-500/10 relative">
                    ${statusBadge}
                    <img src="${imgUrl}" 
                         onerror="this.onerror=null; this.src='https://ipfs.io/ipfs/${imgCid}'" 
                         class="sharp-img rounded-lg aspect-square object-cover mb-3 border border-white/5 shadow-2xl group-hover:scale-[1.02] transition-transform duration-300">
                    <h4 class="orbitron text-[9px] font-bold text-white uppercase truncate">${n.name}</h4>
                    <div class="text-[8px] fira text-cyan-400 mt-1 truncate">${collectionName}</div>
                    ${traitsHTML}
                    ${listingDropdown}
                </div>
                `;
            }).join('');
        };

        
        // Show NFTs in escrow and allow recovery
        window.showEscrowNFTs = async () => {
            const escrowNFTs = state.nfts.filter(n => n.inEscrow || (n.owner || '').toLowerCase() === (state.escrowAddress || '').toLowerCase());
            
            if (escrowNFTs.length === 0) {
                console.log('‚úÖ No NFTs in escrow');
                return;
            }
            
            console.log(`üîç Found ${escrowNFTs.length} NFTs in escrow:`);
            escrowNFTs.forEach(nft => {
                console.log(`  - ${nft.name} (${nft.tokenId})`);
            });
            
            // Automatically recover them
            for (const nft of escrowNFTs) {
                await window.recoverFromEscrow(nft.tokenId, nft.id);
            }
        };
        
        // Recover a single NFT from escrow
        window.recoverFromEscrow = async (nftTokenId, nftDocId) => {
            console.log(`üîÑ Recovering NFT ${nftTokenId} from escrow...`);
            
            try {
                // Transfer from escrow to user
                const builder = state.escrowClient.initBuilder();
                builder.updateAccounts({ 
                    signer: state.escrowAccount, 
                    account: state.escrowAccount 
                });
                
                const myAccount = KeetaNet.lib.Account.fromPublicKeyString(state.address);
                const nftAccount = KeetaNet.lib.Account.fromPublicKeyString(nftTokenId);
                
                builder.send(myAccount, 1n, nftAccount);
                
                await state.escrowClient.computeBuilderBlocks(builder);
                await state.escrowClient.publishBuilder(builder);
                
                console.log('‚úÖ Transfer complete! Updating Firebase...');
                
                // Update Firebase
                await firebase.firestore()
                    .collection('artifacts')
                    .doc(state.appId)
                    .collection('public')
                    .doc('data')
                    .collection('nfts')
                    .doc(nftDocId)
                    .update({
                        owner: state.address,
                        inEscrow: false
                    });
                
                console.log('‚úÖ NFT recovered to your wallet!');
                
                // Refresh UI
                await window.loadNFTsFromFirebase();
                await window.renderCollection();
                
            } catch (error) {
                console.error('‚ùå Recovery failed:', error);
            }
        };

        
        // Toggle listing dropdown in Neural Vault
        window.toggleListingDropdown = (nftId) => {
            const dropdown = document.getElementById(`listing-dropdown-${nftId}`);
            const icon = document.getElementById(`dropdown-icon-${nftId}`);
            
            if (!dropdown) return;
            
            if (dropdown.classList.contains('hidden')) {
                dropdown.classList.remove('hidden');
                if (icon) icon.style.transform = 'rotate(180deg)';
            } else {
                dropdown.classList.add('hidden');
                if (icon) icon.style.transform = 'rotate(0deg)';
            }
        };

        window.viewCollection = (colToken) => {
            state.viewingCollection = colToken;
            window.switchTab('collection-view');
            
            const colNfts = state.nfts.filter(n => getNormalizedId(n.collectionToken) === getNormalizedId(colToken));
            colNfts.sort((a, b) => {
                if (a.isListed && !b.isListed) return -1;
                if (!a.isListed && b.isListed) return 1;
                if (a.isListed && b.isListed) return (a.listedPrice || 0) - (b.listedPrice || 0);
                return 0;
            });
            
            const base = colNfts[0];
            if (!base) return;
            
            const listedNfts = colNfts.filter(n => n.isListed);
            const ktaListings = listedNfts.filter(n => n.listedCurrency === 'KTA');
            const floorKTA = ktaListings.length > 0 ? Math.min(...ktaListings.map(n => n.listedPrice)) : null;
            const floorDisplay = floorKTA ? `${floorKTA} KTA` : '‚Äî';
            
            document.getElementById('colPageTitle').innerText = base.collection || base.collectionTitle || base.collectionName || "Protocol Node";
            document.getElementById('colPageDesc').innerText = base.collectionDesc || "Description encrypted.";
            document.getElementById('colPageCreator').innerText = (base.creator || "---").substring(0, 24) + "...";
            document.getElementById('colPageSupply').innerText = colNfts.length;
            
            const floorEl = document.getElementById('colPageFloor');
            if (floorEl) floorEl.innerText = floorDisplay;
            
            let headerThumb = '';
            if (base.collectionThumbnailCid) {
                headerThumb = `https://gateway.pinata.cloud/ipfs/${base.collectionThumbnailCid}`;
            } else if (base.imageCid) {
                headerThumb = `https://gateway.pinata.cloud/ipfs/${base.imageCid}`;
            } else {
                headerThumb = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23000' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-size='20'%3ECLASSIFIED%3C/text%3E%3C/svg%3E`;
            }
            document.getElementById('colPageImage').innerHTML = `<img src="${headerThumb}" class="sharp-img w-full h-full object-cover shadow-2xl border border-white/10">`;
            
            document.getElementById('colPageGrid').innerHTML = colNfts.map(n => {
                if (!n.collectionId) n.collectionId = state.viewingCollection;
                let rarestPercent = 100;
                const collectionData = state.collections.find(c => c.collectionId === n.collectionId || (n.collectionToken && getNormalizedId(c.collectionToken) === getNormalizedId(n.collectionToken)));
                if (n.attributes && n.attributes.length > 0 && collectionData) {
                    n.attributes.forEach(trait => {
                        const rarity = window.calculateTraitRarity(trait, n.collectionId, collectionData.mintedCount);
                        if (rarity < rarestPercent) rarestPercent = rarity;
                    });
                }
                
                const rarityTier = window.getRarityTier(rarestPercent);
                
                // Use toggle mode for marketplace cards too
                const traitsHTML = window.renderNFTTraits(n, 'toggle', false);
                
                const isListed = n.isListed || false;
                const buyButton = isListed ? `
                    <div class="flex justify-between items-center mt-4">
                        <span class="fira text-[9px] text-cyan-400 font-bold">${n.listedPrice} ${n.listedCurrency}</span>
                        <button onclick="window.buyNFT('${n.id}')" class="btn-primary !py-1 px-4 !text-[8px]">Buy</button>
                    </div>
                ` : `
                    <div class="mt-4 space-y-2">
                        <div class="text-center text-[8px] text-gray-500 fira">Not Listed</div>
                        <button onclick="window.makeOfferOnNFT('${n.id}')" class="w-full p-2 border border-purple-500/30 text-purple-400 rounded-lg text-[8px] hover:bg-purple-500/10 orbitron font-bold uppercase">
                            üí∞ Make Offer
                        </button>
                    </div>
                `;
                
                const imgCid = window.getNFTImagePath(n);
                const imgUrl = imgCid ? `https://gateway.pinata.cloud/ipfs/${imgCid}` : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E';

                return `
                <div class="glass-card p-5 flex flex-col group border-white/5 transition-all hover:border-cyan-500/20 ${rarityTier.glow}">
                    <img src="${imgUrl}" 
                         onerror="this.onerror=null; this.src='https://ipfs.io/ipfs/${imgCid}'" 
                         class="sharp-img rounded-lg aspect-square object-cover mb-4 shadow-xl">
                    <h4 class="orbitron text-[9px] font-black text-white truncate uppercase">${n.name}</h4>
                    ${traitsHTML}
                    ${buyButton}
                </div>
                `;
            }).join('');
            
            // Initialize collection chart with slight delay to ensure canvas is ready
            setTimeout(() => {
                window.updateCollectionDepth(colToken);
            }, 100);
            
            // Build trait filters
            window.buildTraitFilters(colNfts);
        };

        // Toggle filters dropdown
        window.toggleFiltersDropdown = () => {
            const dropdown = document.getElementById('filtersDropdown');
            if (dropdown) {
                dropdown.classList.toggle('hidden');
            }
        };

        // Build trait filter options
        window.buildTraitFilters = (nfts) => {
            const filtersContainer = document.getElementById('traitFilters');
            if (!filtersContainer) return;
            
            // Collect all unique traits
            const traitsByType = {};
            nfts.forEach(nft => {
                if (nft.attributes && Array.isArray(nft.attributes)) {
                    nft.attributes.forEach(trait => {
                        if (!traitsByType[trait.trait_type]) {
                            traitsByType[trait.trait_type] = new Set();
                        }
                        traitsByType[trait.trait_type].add(trait.value);
                    });
                }
            });
            
            // Build filter UI
            filtersContainer.innerHTML = Object.entries(traitsByType).map(([type, values]) => {
                const valuesArray = Array.from(values).sort();
                return `
                    <div class="filter-group">
                        <div class="text-xs orbitron text-gray-400 uppercase font-bold mb-2">${type}</div>
                        <div class="space-y-1">
                            ${valuesArray.map(value => `
                                <label class="flex items-center gap-2 text-xs fira text-gray-300 hover:text-cyan-400 cursor-pointer">
                                    <input 
                                        type="checkbox" 
                                        class="trait-filter-checkbox"
                                        data-trait-type="${type}" 
                                        data-trait-value="${value}"
                                        onchange="window.applyFilters()"
                                    >
                                    <span>${value}</span>
                                </label>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        };

        // Apply filters
        window.applyFilters = () => {
            const checkboxes = document.querySelectorAll('.trait-filter-checkbox:checked');
            const filters = {};
            
            checkboxes.forEach(cb => {
                const type = cb.dataset.traitType;
                const value = cb.dataset.traitValue;
                if (!filters[type]) filters[type] = [];
                filters[type].push(value);
            });
            
            state.collectionFilters = filters;
            
            // Update filter count badge
            const filterCount = Object.keys(filters).length;
            const badge = document.getElementById('filterCount');
            if (badge) {
                if (filterCount > 0) {
                    badge.textContent = filterCount;
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            }
            
            // Re-render collection with filters
            window.renderFilteredCollection();
        };

        // Clear all filters
        window.clearFilters = () => {
            state.collectionFilters = {};
            document.querySelectorAll('.trait-filter-checkbox').forEach(cb => {
                cb.checked = false;
            });
            document.getElementById('filterCount')?.classList.add('hidden');
            window.renderFilteredCollection();
        };

        // Set sort mode
        window.setSortMode = (mode) => {
            state.sortMode = mode;
            
            // Update button states
            document.querySelectorAll('.sort-btn').forEach(btn => {
                btn.classList.remove('active', 'border-cyan-500/30', 'text-cyan-400', 'bg-cyan-500/5');
                btn.classList.add('border-white/10', 'text-gray-400');
            });
            
            const activeBtn = document.getElementById(`sort-${mode}`);
            if (activeBtn) {
                activeBtn.classList.add('active', 'border-cyan-500/30', 'text-cyan-400', 'bg-cyan-500/5');
                activeBtn.classList.remove('border-white/10', 'text-gray-400');
            }
            
            window.renderFilteredCollection();
        };

        // Render collection with filters and sorting
        window.renderFilteredCollection = () => {
            if (!state.viewingCollection) return;
            
            const colToken = state.viewingCollection;
            let colNfts = state.nfts.filter(n => getNormalizedId(n.collectionToken) === getNormalizedId(colToken));
            
            // Apply trait filters
            if (Object.keys(state.collectionFilters).length > 0) {
                colNfts = colNfts.filter(nft => {
                    if (!nft.attributes) return false;
                    
                    // NFT must match ALL filter groups (AND logic)
                    return Object.entries(state.collectionFilters).every(([type, values]) => {
                        // Within a group, match ANY value (OR logic)
                        return nft.attributes.some(attr => 
                            attr.trait_type === type && values.includes(attr.value)
                        );
                    });
                });
            }
            
            // Apply sorting
            if (state.sortMode === 'price') {
                colNfts.sort((a, b) => {
                    if (a.isListed && !b.isListed) return -1;
                    if (!a.isListed && b.isListed) return 1;
                    if (a.isListed && b.isListed) return (a.listedPrice || 0) - (b.listedPrice || 0);
                    return 0;
                });
            } else if (state.sortMode === 'rarity') {
                colNfts.sort((a, b) => {
                    const rarestA = window.getLowestTraitRarity(a);
                    const rarestB = window.getLowestTraitRarity(b);
                    return rarestA - rarestB; // Lower % = more rare
                });
            } else if (state.sortMode === 'traits') {
                colNfts.sort((a, b) => {
                    const countA = a.attributes?.length || 0;
                    const countB = b.attributes?.length || 0;
                    return countB - countA; // More traits first
                });
            }
            
            // Render the filtered/sorted grid
            document.getElementById('colPageGrid').innerHTML = colNfts.map(n => {
                let rarestPercent = 100;
                if (n.attributes && n.attributes.length > 0 && n.collectionId) {
                    const collectionData = state.collections.find(c => c.collectionId === n.collectionId);
                    if (collectionData) {
                        n.attributes.forEach(trait => {
                            const rarity = window.calculateTraitRarity(trait, n.collectionId, collectionData.mintedCount);
                            if (rarity < rarestPercent) rarestPercent = rarity;
                        });
                    }
                }
                
                const rarityTier = window.getRarityTier(rarestPercent);
                const traitsHTML = window.renderNFTTraits(n, 'toggle', false);
                
                const isListed = n.isListed || false;
                const buyButton = isListed ? `
                    <div class="flex justify-between items-center mt-4">
                        <span class="fira text-[9px] text-cyan-400 font-bold">${n.listedPrice} ${n.listedCurrency}</span>
                        <button onclick="window.buyNFT('${n.id}')" class="btn-primary !py-1 px-4 !text-[8px]">Buy</button>
                    </div>
                ` : `
                    <div class="mt-4 space-y-2">
                        <div class="text-center text-[8px] text-gray-500 fira">Not Listed</div>
                        <button onclick="window.makeOfferOnNFT('${n.id}')" class="w-full p-2 border border-purple-500/30 text-purple-400 rounded-lg text-[8px] hover:bg-purple-500/10 orbitron font-bold uppercase">
                            üí∞ Make Offer
                        </button>
                    </div>
                `;
                
                const imgCid = window.getNFTImagePath(n);
                const imgUrl = imgCid ? `https://gateway.pinata.cloud/ipfs/${imgCid}` : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E';

                return `
                <div class="glass-card p-5 flex flex-col group border-white/5 transition-all hover:border-cyan-500/20 ${rarityTier.glow}">
                    <img src="${imgUrl}" 
                         onerror="this.onerror=null; this.src='https://ipfs.io/ipfs/${imgCid}'" 
                         class="sharp-img rounded-lg aspect-square object-cover mb-4 shadow-xl">
                    <h4 class="orbitron text-[9px] font-black text-white truncate uppercase">${n.name}</h4>
                    ${traitsHTML}
                    ${buyButton}
                </div>
                `;
            }).join('');
        };

        // Get lowest trait rarity for an NFT
        window.getLowestTraitRarity = (nft) => {
            if (!nft.attributes || nft.attributes.length === 0) return 100;
            const lookupId = nft.collectionId || state.viewingCollection;
            if (!lookupId) return 100;
            
            const collectionData = state.collections.find(c => c.collectionId === lookupId || (nft.collectionToken && getNormalizedId(c.collectionToken) === getNormalizedId(nft.collectionToken)));
            if (!collectionData) return 100;
            
            let lowestRarity = 100;
            nft.attributes.forEach(trait => {
                const rarity = window.calculateTraitRarity(trait, lookupId, collectionData.mintedCount);
                if (rarity < lowestRarity) lowestRarity = rarity;
            });
            
            return lowestRarity;
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #4: INLINE LISTING SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        window.listNFTForSale = async (nftId) => {
            const nft = state.nfts.find(n => n.id === nftId);
            if (!nft) return window.notify("NFT not found", "error");
            
            if (!nft.attributes || nft.attributes.length === 0) await window.fetchNFTMetadata(nft);
            
            state.listingNFT = nft;
            
            const listingImgPath = window.getNFTImagePath(nft);
            const preview = document.getElementById('listingNFTPreview');
            if (preview) preview.innerHTML = `<img src="${listingImgPath ? 'https://gateway.pinata.cloud/ipfs/' + listingImgPath : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E'}" class="sharp-img w-full h-full object-cover rounded-xl">`;
            
            const nameEl = document.getElementById('listingNFTName');
            if (nameEl) nameEl.innerText = nft.name || "Unit";
            
            const traitsEl = document.getElementById('listingNFTTraits');
            if (traitsEl) {
                // Show all traits expanded in listing modal
                traitsEl.innerHTML = window.renderNFTTraits(nft, 'all');
            }
            
            document.getElementById('listingPriceInput').value = '';
            document.querySelector('input[name="listingCurrency"][value="KTA"]').checked = true;
            window.updateFeeBreakdown();
            
            document.getElementById('listingModal').classList.remove('hidden');
        };

        window.closeListingModal = () => {
            document.getElementById('listingModal').classList.add('hidden');
            state.listingNFT = null;
        };

        window.updateFeeBreakdown = () => {
            const priceInput = document.getElementById('listingPriceInput');
            const price = parseFloat(priceInput?.value || 0);
            
            if (isNaN(price) || price <= 0) {
                document.getElementById('sellerPayout').innerText = '0.00';
                document.getElementById('creatorRoyalty').innerText = '0.00';
                document.getElementById('marketplaceFee').innerText = '0.00';
                const royaltyPercentEl = document.getElementById('royaltyPercent');
                if (royaltyPercentEl) royaltyPercentEl.innerText = '5.0';
                return;
            }
            
            const currency = document.querySelector('input[name="listingCurrency"]:checked')?.value || 'KTA';
            
            // Get actual collection royalty from the NFT being listed
            const nft = state.listingNFT;
            const collection = state.collections.find(c => 
                c.collectionId === nft?.collectionId || 
                c.collectionToken === nft?.collectionToken
            );
            const royaltyPercent = collection?.creatorRoyaltyPercent || SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
            const marketplaceFeePercent = SECONDARY_SALE_MARKETPLACE_PERCENT;
            const sellerPercent = 1 - royaltyPercent - marketplaceFeePercent;
            
            const sellerAmount = price * sellerPercent;
            const royaltyAmount = price * royaltyPercent;
            const feeAmount = price * marketplaceFeePercent;
            
            document.getElementById('sellerPayout').innerText = `${sellerAmount.toFixed(2)} ${currency}`;
            document.getElementById('creatorRoyalty').innerText = `${royaltyAmount.toFixed(2)} ${currency}`;
            document.getElementById('marketplaceFee').innerText = `${feeAmount.toFixed(2)} ${currency}`;
            
            // Update royalty percentage display if element exists
            const royaltyPercentEl = document.getElementById('royaltyPercent');
            if (royaltyPercentEl) {
                royaltyPercentEl.innerText = `${(royaltyPercent * 100).toFixed(1)}`;
            }
        };

        window.confirmListing = async () => {
            if (!state.listingNFT) return window.notify("No NFT selected", "error");
            
            const price = parseFloat(document.getElementById('listingPriceInput')?.value || 0);
            if (isNaN(price) || price <= 0) return window.notify("Invalid price", "error");
            
            const currency = document.querySelector('input[name="listingCurrency"]:checked')?.value || "KTA";
            
            try {
                window.notify("Creating listing...", "success");
                
                // NO ESCROW TRANSFER - Just update Firebase
                await updateDoc(doc(db, 'nfts', state.listingNFT.id), {
                    isListed: true,
                    listedPrice: price,
                    listedCurrency: currency,
                    listedAt: new Date().toISOString()
                });
                
                // Create transaction record for listing
                const transactionId = `tx_listing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const transactionData = {
                    id: transactionId,
                    type: 'listing',
                    nftId: state.listingNFT.id,
                    nftName: state.listingNFT.name,
                    nftImage: state.listingNFT.imagePath || state.listingNFT.imageCid,
                    collectionId: state.listingNFT.collectionId || state.listingNFT.collection,
                    collectionName: state.listingNFT.collectionName || state.listingNFT.collectionTitle,
                    price: price,
                    currency: currency,
                    seller: state.address,
                    wallet: state.address, // For seller's transaction history
                    timestamp: new Date().toISOString(),
                    txHash: `listing_${state.listingNFT.id}`,
                    status: 'listed'
                };
                
                await setDoc(
                    doc(db, 'transactions', transactionId),
                    transactionData
                );
                
                console.log("‚úÖ Transaction record created for listing");
                
                window.notify(`‚úÖ Listed for ${price} ${currency}!`, "success");
                window.closeListingModal();
                
                await window.renderCollection();
                await window.renderMarketplace();
                
            } catch (error) {
                console.error("Listing error:", error);
                window.notify(`‚ùå Listing failed: ${error.message}`, "error");
            }
        };

        window.editNFTPrice = async (nftId) => {
            const nft = state.nfts.find(n => n.id === nftId);
            if (!nft) return;
            
            // Open the listing modal with current values pre-filled
            if (!nft.attributes || nft.attributes.length === 0) await window.fetchNFTMetadata(nft);
            
            state.listingNFT = nft;
            
            const editImgPath = window.getNFTImagePath(nft);
            const preview = document.getElementById('listingNFTPreview');
            if (preview) preview.innerHTML = `<img src="${editImgPath ? 'https://gateway.pinata.cloud/ipfs/' + editImgPath : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E'}" class="sharp-img w-full h-full object-cover rounded-xl">`;
            
            const nameEl = document.getElementById('listingNFTName');
            if (nameEl) nameEl.innerText = nft.name || "Unit";
            
            const traitsEl = document.getElementById('listingNFTTraits');
            if (traitsEl) {
                traitsEl.innerHTML = window.renderNFTTraits(nft, 'all');
            }
            
            // Pre-fill with current listing values
            document.getElementById('listingPriceInput').value = nft.listedPrice || '';
            
            // Set currency
            const currencyRadio = document.querySelector(`input[name="listingCurrency"][value="${nft.listedCurrency || 'KTA'}"]`);
            if (currencyRadio) currencyRadio.checked = true;
            
            window.updateFeeBreakdown();
            
            // Show modal
            document.getElementById('listingModal').classList.remove('hidden');
        };

        window.cancelListing = async (nftId) => {
            try {
                const nft = state.nfts.find(n => n.id === nftId);
                if (!nft) return window.notify("NFT not found", "error");
                
                // Verify caller owns this NFT
                if ((nft.owner || '').toLowerCase() !== (state.address || '').toLowerCase()) {
                    return window.notify("You can only cancel your own listings", "error");
                }
                
                // Listing uses NO ESCROW - NFT stays with owner. Just update Firebase.
                window.notify("Canceling listing...", "success");
                
                await updateDoc(doc(db, 'nfts', nftId), {
                    isListed: false,
                    listedPrice: null,
                    listedCurrency: null,
                    inEscrow: false,
                    listedAt: null,
                    cancelledAt: new Date().toISOString()
                });
                
                // Record cancellation transaction
                try {
                    await window.recordTransaction({
                        type: 'cancellation',
                        nftId,
                        nftName: nft.name,
                        collection: nft.collection || nft.collectionTitle,
                        collectionId: nft.collectionId,
                        price: 0,
                        currency: 'KTA',
                        counterParty: null,
                        txHash: null
                    });
                } catch (e) { console.warn("Could not record cancellation:", e); }
                
                // Update local state immediately
                const nftIndex = state.nfts.findIndex(n => n.id === nftId);
                if (nftIndex !== -1) {
                    state.nfts[nftIndex].isListed = false;
                    state.nfts[nftIndex].listedPrice = null;
                    state.nfts[nftIndex].listedCurrency = null;
                    state.nfts[nftIndex].inEscrow = false;
                }
                
                window.notify("‚úÖ Listing cancelled successfully", "success");
                
                await window.renderCollection();
                await window.renderMarketplace();
                window.updateMarketChart();
                
            } catch (error) {
                console.error("Cancel error:", error);
                window.notify("‚ùå Cancel failed: " + error.message, "error");
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ENHANCED CHART SYSTEM WITH REAL-TIME UPDATES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Populate collection selector
        window.populateChartSelector = () => {
            const selector = document.getElementById('chartCollectionSelector');
            if (!selector) return;
            
            const collections = {};
            state.nfts.forEach(n => {
                const k = getNormalizedId(n.collectionToken);
                if (!collections[k]) {
                    collections[k] = { title: n.collection || 'Unknown', token: k };
                }
            });
            
            selector.innerHTML = '<option value="all">Overall Marketplace</option>';
            Object.values(collections).forEach(col => {
                selector.innerHTML += `<option value="${col.token}">${col.title}</option>`;
            });
            
            selector.value = state.selectedChartCollection;
        };

        // Set timeframe for main chart
        window.setChartTimeframe = (timeframe) => {
            state.chartTimeframe = timeframe;
            
            // Update button states in main market view
            const marketTab = document.querySelector('#tab-market');
            if (marketTab) {
                marketTab.querySelectorAll('.chart-timeframe-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.timeframe === timeframe) {
                        btn.classList.add('active');
                    }
                });
            }
            
            console.log("üìä Chart timeframe changed to:", timeframe);
            
            // Force regenerate chart with new timeframe
            window.updateMarketChart();
        };

        // Set timeframe for collection chart
        window.setCollectionChartTimeframe = (timeframe) => {
            state.collectionChartTimeframe = timeframe;
            
            // Update button states in collection view
            const collectionTab = document.querySelector('#tab-collection-view');
            if (collectionTab) {
                collectionTab.querySelectorAll('.chart-timeframe-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.timeframe === timeframe) {
                        btn.classList.add('active');
                    }
                });
            }
            
            console.log("üìä Collection chart timeframe changed to:", timeframe);
            
            // Force regenerate collection chart
            if (state.viewingCollection) {
                window.updateCollectionDepth(state.viewingCollection);
            }
        };

        // Update main market chart - FORCE REFRESH with new data
        window.updateMarketChart = async () => {
            const selector = document.getElementById('chartCollectionSelector');
            if (selector) {
                state.selectedChartCollection = selector.value;
            }
            
            console.log(`üîÑ Updating chart for: ${state.selectedChartCollection} | Timeframe: ${state.chartTimeframe}`);
            
            // Force destroy and recreate chart
            if (state.pulseChart) {
                state.pulseChart.destroy();
                state.pulseChart = null;
            }
            
            await window.initFloorPulseChart();
        };

        // Generate sophisticated market data based on actual sales
        window.getMarketPulseData = async () => {
            try {
                const selectedCollection = state.selectedChartCollection;
                let relevantNFTs = state.nfts || [];
                
                // Filter by collection if not "all"
                if (selectedCollection !== 'all') {
                    relevantNFTs = relevantNFTs.filter(n => 
                        getNormalizedId(n.collectionToken) === selectedCollection
                    );
                }
                
                // Get REAL transaction data from Firebase
                const txRef = collection(db, 'transactions');
                let txQuery;
                
                if (selectedCollection !== 'all') {
                    // Match the collectionId format: collection_<tokenId>
                    const formattedColId = `collection_${selectedCollection}`;
                    console.log(`üîç Filtering for collectionId: ${formattedColId}`);
                    txQuery = query(txRef, where('collectionId', '==', formattedColId));
                } else {
                    txQuery = txRef;
                }
                
                const txSnapshot = await getDocs(txQuery);
                const transactions = txSnapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                console.log(`üìä Found ${transactions.length} transactions for chart`);
                
                // Filter to only sales and mints with KTA prices
                const ktaTransactions = transactions.filter(tx => 
                    (tx.type === 'sale' || tx.type === 'mint' || tx.type === 'purchase') && 
                    tx.currency === 'KTA' && 
                    tx.price > 0 &&
                    tx.timestamp
                );
                
                console.log(`üìä ${ktaTransactions.length} KTA transactions for charting`);
                // FIX #10: Enhanced debugging - show recent transactions
                const recentTxs = ktaTransactions.slice(-5); // Last 5 transactions
                console.log("üìä Recent transactions:", recentTxs.map(tx => `${tx.type}:${tx.price}KTA@${new Date(tx.timestamp).toLocaleTimeString()}`));
                
                // Also check NFT soldAt data
                const soldNFTs = relevantNFTs.filter(n => n.soldAt && n.soldPrice && n.soldCurrency === 'KTA');
                console.log(`üìä ${soldNFTs.length} NFTs with soldAt data`);
                
                // Get current listings for floor price
                const listedNFTs = relevantNFTs.filter(n => n.isListed && n.listedCurrency === 'KTA');
                
                // Calculate current floor from listings
                const prices = listedNFTs.map(n => n.listedPrice).sort((a, b) => a - b);
                const currentFloor = prices.length > 0 ? prices[0] : 1;
                const ceiling = prices.length > 0 ? prices[prices.length - 1] : currentFloor * 1.5;
                const avgPrice = prices.length > 0 
                    ? prices.reduce((a, b) => a + b, 0) / prices.length 
                    : currentFloor;
                
                // Generate time series data based on timeframe
                const now = Date.now();
                let dataPoints = [];
                let intervals = 24;
                let intervalMs = 3600000;
                
                switch (state.chartTimeframe) {
                    case '1h':
                        intervals = 12;
                        intervalMs = 300000; // 5 min
                        break;
                    case '24h':
                        intervals = 24;
                        intervalMs = 3600000; // 1 hour
                        break;
                    case '7d':
                        intervals = 28;
                        intervalMs = 6 * 3600000; // 6 hours
                        break;
                    case '30d':
                        intervals = 30;
                        intervalMs = 24 * 3600000; // 1 day
                        break;
                    case 'all':
                        intervals = 50;
                        intervalMs = 24 * 3600000; // 1 day
                        break;
                }
                
                // Build REAL data points from transactions
                for (let i = intervals; i >= 0; i--) {
                    const timestamp = new Date(now - (i * intervalMs));
                    const intervalStart = timestamp.getTime();
                    const intervalEnd = intervalStart + intervalMs;
                    
                    // Find transactions in this time interval
                    const intervalTxs = ktaTransactions.filter(tx => {
                        const txTime = new Date(tx.timestamp).getTime();
                        return txTime >= intervalStart && txTime < intervalEnd;
                    });
                    
                    // Calculate average price for this interval
                    let avgIntervalPrice = currentFloor;
                    if (intervalTxs.length > 0) {
                        const sum = intervalTxs.reduce((acc, tx) => acc + tx.price, 0);
                        avgIntervalPrice = sum / intervalTxs.length;
                    }
                    
                    // Calculate volume (total KTA traded)
                    const volume = intervalTxs.reduce((acc, tx) => acc + tx.price, 0);
                    
                    dataPoints.push({
                        timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                        fullTimestamp: timestamp,
                        floorKTA: avgIntervalPrice,
                        volume: volume,
                        sales: intervalTxs.length
                    });
                }
                
                // Calculate 24h change from REAL data
                const firstPrice = dataPoints[0]?.floorKTA || currentFloor;
                const lastPrice = dataPoints[dataPoints.length - 1]?.floorKTA || currentFloor;
                const change24h = firstPrice > 0 ? ((lastPrice - firstPrice) / firstPrice) * 100 : 0;
                
                // FIX #10: Calculate real 24h volume from transactions
                const last24h = now - (24 * 3600000);
                const recent24hTxs = ktaTransactions.filter(tx => {
                    const txTime = new Date(tx.timestamp).getTime();
                    return txTime >= last24h;
                });
                const volume24h = recent24hTxs.reduce((sum, tx) => sum + tx.price, 0);
                
                // Update stats display with REAL data
                window.updateChartStats(
                    currentFloor, 
                    ceiling, 
                    avgPrice, 
                    listedNFTs.length, 
                    relevantNFTs.length,
                    change24h,
                    recent24hTxs.length,
                    volume24h // Pass actual volume
                );
                
                console.log(`üìä Chart: ${dataPoints.length} points | Floor: ${currentFloor.toFixed(2)} KTA | Change: ${change24h.toFixed(2)}% | Volume: ${volume24h.toFixed(2)} KTA (${recent24hTxs.length} txs)`);
                
                return dataPoints;
                
            } catch (error) {
                console.error("Error generating market data:", error);
                // Return minimal data to prevent chart crash
                return [{
                    timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    floorKTA: 0,
                    volume: 0
                }];
            }
        };

        // Update chart statistics with real calculations
        window.updateChartStats = (floor, ceiling, avgPrice, listedCount, totalSupply, change24h = 0, salesCount = 0, realVolume24h = 0) => {
            // Floor price
            const floorEl = document.getElementById('chartFloorPrice');
            if (floorEl) floorEl.innerText = floor ? `${floor.toFixed(2)} KTA` : '‚Äî';
            
            // 24h change (calculated from actual data)
            const changeEl = document.getElementById('chartFloorChange');
            if (changeEl) {
                changeEl.innerText = change24h !== 0 ? `${change24h > 0 ? '+' : ''}${change24h.toFixed(2)}%` : '‚Äî';
                changeEl.className = `chart-stat-change ${change24h > 0 ? 'positive' : 'negative'}`;
            }
            
            // FIX #10: 24h Volume using real transaction sums
            const volume24h = realVolume24h > 0 ? realVolume24h.toFixed(2) : '0.00';
            const volumeEl = document.getElementById('chart24hVolume');
            if (volumeEl) volumeEl.innerText = `${volume24h} KTA`;
            
            // Volume change indicator
            const volumeChangeEl = document.getElementById('chartVolumeChange');
            if (volumeChangeEl) {
                volumeChangeEl.innerText = `${salesCount} sales`;
                volumeChangeEl.className = salesCount > 0 ? 'chart-stat-change positive' : 'chart-stat-change';
            }
            
            // Listed count
            const listedEl = document.getElementById('chartListedCount');
            if (listedEl) listedEl.innerText = listedCount;
            
            const listedPercent = totalSupply > 0 ? (listedCount / totalSupply * 100).toFixed(1) : 0;
            const listedPercentEl = document.getElementById('chartListedPercent');
            if (listedPercentEl) listedPercentEl.innerText = `${listedPercent}% of supply`;
            
            // Average price
            const avgEl = document.getElementById('chartAvgPrice');
            if (avgEl) avgEl.innerText = avgPrice ? `${avgPrice.toFixed(2)} KTA` : '‚Äî';
            
            // Calculate avg vs floor percentage
            const avgVsFloor = floor && avgPrice ? (((avgPrice - floor) / floor) * 100).toFixed(1) : '0';
            const avgChangeEl = document.getElementById('chartAvgChange');
            if (avgChangeEl) {
                avgChangeEl.innerText = `${avgVsFloor}% above floor`;
                avgChangeEl.className = 'chart-stat-change positive';
            }
        };

        // Initialize main market chart with sophisticated styling
        window.initFloorPulseChart = async () => {
            await window.loadChartJs();
            const canvas = document.getElementById('floorPulseChart');
            if (!canvas) {
                console.error("‚ùå Chart canvas not found!");
                return;
            }
            
            const loadingState = document.getElementById('chartLoadingState');
            const emptyState = document.getElementById('chartEmptyState');
            
            try {
                if (loadingState) loadingState.classList.remove('hidden');
                if (emptyState) emptyState.classList.add('hidden');
                
                console.log("üìä Generating market data...");
                const data = await window.getMarketPulseData();
                
                // CRITICAL: Always show chart, even with minimal data
                if (!data || data.length === 0) {
                    console.log("‚ö†Ô∏è No market data - creating placeholder chart");
                    // Create placeholder data
                    const placeholderData = [];
                    const now = Date.now();
                    for (let i = 24; i >= 0; i--) {
                        const timestamp = new Date(now - (i * 3600000));
                        placeholderData.push({
                            timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                            floorKTA: 0,
                            volume: 0
                        });
                    }
                    
                    if (state.pulseChart) state.pulseChart.destroy();
                    
                    const ctx = canvas.getContext('2d');
                    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.2)');
                    gradient.addColorStop(1, 'rgba(0, 255, 255, 0.0)');
                    
                    state.pulseChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: placeholderData.map(d => d.timestamp),
                            datasets: [{
                                label: 'Floor Price',
                                data: placeholderData.map(d => d.floorKTA),
                                borderColor: '#00ffff',
                                backgroundColor: gradient,
                                borderWidth: 2,
                                tension: 0.4,
                                fill: true,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: false }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(0, 255, 255, 0.05)', drawBorder: false },
                                    ticks: { color: '#666', font: { family: 'Fira Code', size: 9 } }
                                },
                                y: {
                                    grid: { color: 'rgba(0, 255, 255, 0.08)', drawBorder: false },
                                    ticks: { color: '#00ffff', font: { family: 'Fira Code', size: 10, weight: 'bold' } }
                                }
                            }
                        }
                    });
                    
                    if (loadingState) loadingState.classList.add('hidden');
                    console.log("üìä Placeholder chart created");
                    return;
                }
                
                if (state.pulseChart) state.pulseChart.destroy();
                
                const ctx = canvas.getContext('2d');
                
                // Create gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.0)');
                
                state.pulseChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.map(d => d.timestamp),
                        datasets: [{
                            label: 'Floor Price',
                            data: data.map(d => d.floorKTA),
                            borderColor: '#00ffff',
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointHoverBackgroundColor: '#00ffff',
                            pointHoverBorderColor: '#fff',
                            pointHoverBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#00ffff',
                                bodyColor: '#fff',
                                borderColor: '#00ffff',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: false,
                                callbacks: {
                                    label: function(context) {
                                        return `Floor: ${context.parsed.y.toFixed(2)} KTA`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: 'rgba(0, 255, 255, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#666',
                                    font: { family: 'Fira Code', size: 9 },
                                    maxRotation: 0,
                                    autoSkipPadding: 20
                                }
                            },
                            y: {
                                grid: {
                                    color: 'rgba(0, 255, 255, 0.08)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#00ffff',
                                    font: { family: 'Fira Code', size: 10, weight: 'bold' },
                                    callback: function(value) {
                                        return value.toFixed(2) + ' KTA';
                                    }
                                }
                            }
                        }
                    }
                });
                
                if (loadingState) loadingState.classList.add('hidden');
                console.log("‚úÖ Market chart initialized with", data.length, "data points");
                
            } catch (error) {
                console.error("‚ùå Chart failed:", error);
                if (loadingState) loadingState.classList.add('hidden');
                if (emptyState) emptyState.classList.remove('hidden');
            }
        };

        // Collection-specific chart
        window.updateCollectionDepth = async (colToken) => {
            await window.loadChartJs();
            console.log(`üìä updateCollectionDepth called for: ${colToken}`);
            
            const canvas = document.getElementById('colPageChart');
            if (!canvas) {
                console.error("‚ùå Collection chart canvas not found!");
                return;
            }
            
            console.log("‚úÖ Canvas found, context:", canvas.getContext('2d'));
            
            const loadingState = document.getElementById('colChartLoadingState');
            const emptyState = document.getElementById('colChartEmptyState');
            
            try {
                if (loadingState) loadingState.classList.remove('hidden');
                if (emptyState) emptyState.classList.add('hidden');
                
                const colNfts = state.nfts.filter(n => 
                    getNormalizedId(n.collectionToken) === getNormalizedId(colToken)
                );
                
                console.log(`üì¶ Collection has ${colNfts.length} total NFTs`);
                
                // Get REAL transaction data for this collection
                const txRef = collection(db, 'transactions');
                // Match the collectionId format used when recording transactions
                const colId = `collection_${getNormalizedId(colToken)}`;
                console.log(`üîç Searching for transactions with collectionId: ${colId}`);
                const txQuery = query(txRef, where('collectionId', '==', colId));
                const txSnapshot = await getDocs(txQuery);
                const transactions = txSnapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                console.log(`üìä Found ${transactions.length} total transactions for this collection`);
                
                // Filter to KTA transactions (mints, purchases, sales)
                const ktaTransactions = transactions.filter(tx => 
                    (tx.type === 'sale' || tx.type === 'mint' || tx.type === 'purchase') && 
                    tx.currency === 'KTA' && 
                    tx.price > 0 &&
                    tx.timestamp
                );
                
                console.log(`üìä ${ktaTransactions.length} KTA transactions for this collection`);
                
                const listedNFTs = colNfts.filter(n => n.isListed && n.listedCurrency === 'KTA');
                
                console.log(`üìä ${listedNFTs.length} listed in KTA`);
                
                // Calculate floor price: use listings if available, otherwise last sale price
                let floor = 0;
                let ceiling = 0;
                let floorSource = 'none';
                
                if (listedNFTs.length > 0) {
                    // Use current listings for floor/ceiling
                    const prices = listedNFTs.map(n => n.listedPrice).sort((a, b) => a - b);
                    floor = prices[0];
                    ceiling = prices[prices.length - 1];
                    floorSource = 'listings';
                } else if (ktaTransactions.length > 0) {
                    // No listings - use last sale price as floor
                    const sortedTxs = ktaTransactions.sort((a, b) => 
                        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
                    );
                    floor = sortedTxs[0].price;
                    ceiling = floor;
                    floorSource = 'last sale';
                }
                
                console.log(`üìä Floor: ${floor} KTA (from ${floorSource})`);
                
                // Calculate total volume
                const totalVolume = ktaTransactions.reduce((sum, tx) => sum + tx.price, 0);
                
                // Update collection stats
                if (floor > 0) {
                    document.getElementById('colChartFloor').innerText = `${floor.toFixed(2)} KTA`;
                    document.getElementById('colChartCeiling').innerText = `${ceiling.toFixed(2)} KTA`;
                } else {
                    document.getElementById('colChartFloor').innerText = '‚Äî';
                    document.getElementById('colChartCeiling').innerText = '‚Äî';
                }
                document.getElementById('colChartVolume').innerText = `${totalVolume.toFixed(2)} KTA`;
                document.getElementById('colChartListed').innerText = listedNFTs.length;
                document.getElementById('colChartSupply').innerText = colNfts.length;
                
                // If no transactions, show empty state
                if (ktaTransactions.length === 0) {
                    console.log("‚ö†Ô∏è No transactions - showing empty state");
                    if (loadingState) loadingState.classList.add('hidden');
                    if (emptyState) emptyState.classList.remove('hidden');
                    return;
                }
                
                // Generate time series based on REAL transactions
                const now = Date.now();
                let intervals = 24;
                let intervalMs = 3600000;
                
                console.log(`üìä Collection chart using timeframe: ${state.collectionChartTimeframe}`);
                
                switch (state.collectionChartTimeframe) {
                    case '1h':
                        intervals = 12;
                        intervalMs = 300000; // 5 min
                        break;
                    case '24h':
                        intervals = 24;
                        intervalMs = 3600000; // 1 hour
                        break;
                    case '7d':
                        intervals = 28;
                        intervalMs = 6 * 3600000; // 6 hours
                        break;
                    case 'all':
                        intervals = 50;
                        intervalMs = 24 * 3600000; // 1 day
                        break;
                }
                
                const data = [];
                for (let i = intervals; i >= 0; i--) {
                    const timestamp = new Date(now - (i * intervalMs));
                    const intervalStart = timestamp.getTime();
                    const intervalEnd = intervalStart + intervalMs;
                    
                    // Find transactions in this time interval
                    const intervalTxs = ktaTransactions.filter(tx => {
                        const txTime = new Date(tx.timestamp).getTime();
                        return txTime >= intervalStart && txTime < intervalEnd;
                    });
                    
                    // Calculate average price for this interval (or use floor if no txs)
                    let avgPrice = floor;
                    if (intervalTxs.length > 0) {
                        const sum = intervalTxs.reduce((acc, tx) => acc + tx.price, 0);
                        avgPrice = sum / intervalTxs.length;
                    }
                    
                    data.push({
                        timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                        price: avgPrice,
                        volume: intervalTxs.reduce((acc, tx) => acc + tx.price, 0),
                        txCount: intervalTxs.length
                    });
                }
                
                if (state.colPageChart) {
                    state.colPageChart.destroy();
                    state.colPageChart = null;
                }
                
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, 'rgba(188, 19, 254, 0.4)');
                gradient.addColorStop(1, 'rgba(188, 19, 254, 0.0)');
                
                state.colPageChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.map(d => d.timestamp),
                        datasets: [{
                            label: 'Floor Price',
                            data: data.map(d => d.price),
                            borderColor: '#bc13fe',
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointHoverBackgroundColor: '#bc13fe',
                            pointHoverBorderColor: '#fff',
                            pointHoverBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#bc13fe',
                                bodyColor: '#fff',
                                borderColor: '#bc13fe',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: false,
                                callbacks: {
                                    label: function(context) {
                                        return `Floor: ${context.parsed.y.toFixed(2)} KTA`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: 'rgba(188, 19, 254, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#666',
                                    font: { family: 'Fira Code', size: 9 },
                                    maxRotation: 0
                                }
                            },
                            y: {
                                grid: {
                                    color: 'rgba(188, 19, 254, 0.08)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#bc13fe',
                                    font: { family: 'Fira Code', size: 10, weight: 'bold' },
                                    callback: function(value) {
                                        return value.toFixed(2) + ' KTA';
                                    }
                                }
                            }
                        }
                    }
                });
                
                if (loadingState) loadingState.classList.add('hidden');
                console.log(`‚úÖ Collection chart created with ${data.length} points`);
                
            } catch (error) {
                console.error("Collection chart error:", error);
                if (loadingState) loadingState.classList.add('hidden');
                if (emptyState) emptyState.classList.remove('hidden');
            }
        };

        // Start real-time chart updates (reduced frequency)
        window.startChartAutoUpdate = () => {
            // Clear existing interval
            if (state.chartUpdateInterval) {
                clearInterval(state.chartUpdateInterval);
            }
            
            // Update charts and transaction list every 60 seconds (less aggressive)
            state.chartUpdateInterval = setInterval(async () => {
                // Only update if on market tab (performance optimization)
                const marketTab = document.getElementById('tab-market');
                if (marketTab && !marketTab.classList.contains('hidden')) {
                    console.log("üîÑ Auto-updating market chart with fresh data...");
                    // FIX #10: Refresh NFT data before updating chart
                    await window.loadNFTsFromFirebase();
                    window.updateMarketChart();
                }
                
                // Update collection chart if viewing a collection
                if (state.viewingCollection) {
                    const collectionTab = document.getElementById('tab-collection-view');
                    if (collectionTab && !collectionTab.classList.contains('hidden')) {
                        console.log("üîÑ Auto-updating collection chart...");
                        window.updateCollectionDepth(state.viewingCollection);
                    }
                }
                
                // Auto-refresh transaction history when on transactions tab
                const txTab = document.getElementById('tab-transactions');
                if (txTab && !txTab.classList.contains('hidden') && state.address) {
                    window.loadTransactions();
                }
            }, 60000); // 60 seconds
            
            console.log("‚úÖ Chart auto-update started (60s interval)");
        };

        // Stop auto-updates
        window.stopChartAutoUpdate = () => {
            if (state.chartUpdateInterval) {
                clearInterval(state.chartUpdateInterval);
                state.chartUpdateInterval = null;
                console.log("‚è∏Ô∏è Chart auto-update stopped");
            }
        };

        // Buy NFT function
        window.buyNFT = async (nftId, isBlind = false) => {
            if (!state.keetaClient) return window.notify("Connect wallet first", "error");
            
            try {
                // Step 1: Fetch NFT data
                const snap = await getDoc(doc(db, 'nfts', nftId));
                if (!snap.exists()) return window.notify("NFT not found", "error");
                
                const nft = snap.data();
                
                // FIX: Prevent buying your own NFT
                if (nft.owner && nft.owner.toLowerCase() === state.address.toLowerCase()) {
                    return window.notify("‚ùå Cannot buy your own NFT", "error");
                }
                
                // Determine price - FIX: Always use listedPrice for listed NFTs
                const price = nft.listedPrice || nft.priceKTA || 0;
                const currency = nft.listedCurrency || 'KTA';
                
                if (price <= 0) {
                    return window.notify("Invalid price", "error");
                }
                
                // Check balance
                if (currency === 'KTA' && state.balanceKTA < price) {
                    return window.notify(`Insufficient balance. Need ${price} KTA`, "error");
                }
                if (currency === 'PUNKS' && state.balancePunks < price) {
                    return window.notify(`Insufficient balance. Need ${price} PUNKS`, "error");
                }
                
                // Step 2: Confirm purchase
                window.notify(`Purchasing ${nft.name} for ${price} ${currency}...`, "success");
                
                // Variable to store transaction hash
                let txHash = null;
                
                // Initialize clients
                if (typeof state.keetaClient.init === 'function') {
                    await state.keetaClient.init();
                }
                
                // Step 3: Execute transaction
                if (isBlind && state.escrowClient) {
                    console.log("‚úÖ Blind mint purchase - NFT was auto-transferred to escrow at mint time");
                    if (typeof state.escrowClient.init === 'function') {
                        await state.escrowClient.init();
                    }
                    
                    const buyerBuilder = state.keetaClient.initBuilder();
                    buyerBuilder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                    buyerBuilder.send(KeetaNet.lib.Account.fromPublicKeyString(nft.creator), BigInt(Math.floor(price * KTA_DECIMALS)), state.keetaClient.baseToken);
                    
                    const escrowBuilder = state.escrowClient.initBuilder();
                    escrowBuilder.updateAccounts({ signer: state.escrowAccount, account: state.escrowAccount });
                    escrowBuilder.send(KeetaNet.lib.Account.fromPublicKeyString(state.address), 1n, KeetaNet.lib.Account.fromPublicKeyString(nft.tokenId));
                    
                    await Promise.all([
                        state.keetaClient.computeBuilderBlocks(buyerBuilder),
                        state.escrowClient.computeBuilderBlocks(escrowBuilder)
                    ]);
                    
                    const [buyerTx, escrowTx] = await Promise.all([
                        state.keetaClient.publishBuilder(buyerBuilder),
                        state.escrowClient.publishBuilder(escrowBuilder)
                    ]);
                    
                    // Capture transaction hash with enhanced logging
                    // Custom replacer to handle BigInt serialization
                    const bigIntReplacer = (key, value) => {
                        return typeof value === 'bigint' ? value.toString() : value;
                    };
                    
                    console.log("üìù Purchase buyerTx (full):", JSON.stringify(buyerTx, bigIntReplacer, 2));
                    console.log("üìù Purchase escrowTx (full):", JSON.stringify(escrowTx, bigIntReplacer, 2));
                    
                    // Extract REAL transaction hash from blocks
                    let purchaseTxHash = null;
                    if (buyerTx?.voteStaple?.blocks?.[0]?.$hash) {
                        purchaseTxHash = buyerTx.voteStaple.blocks[0].$hash;
                    } else if (escrowTx?.voteStaple?.blocks?.[0]?.$hash) {
                        purchaseTxHash = escrowTx.voteStaple.blocks[0].$hash;
                    } else if (buyerTx?.hash) {
                        purchaseTxHash = buyerTx.hash;
                    } else if (escrowTx?.hash) {
                        purchaseTxHash = escrowTx.hash;
                    }
                    
                    console.log("üîç Extracted purchase tx hash:", purchaseTxHash);
                    txHash = purchaseTxHash;
                    
                    // Update database
                    await updateDoc(doc(db, 'nfts', nftId), {
                        status: 'transferred',
                        owner: state.address,
                        wasBlindMinted: true,
                        isListed: false,
                        listedPrice: null,
                        listedCurrency: null,
                        transferredAt: new Date().toISOString()
                    });
                    
                } else {
                    // Secondary sale with fee splits
                    const totalPrice = price;
                    // Use custom royalty if set, otherwise use default
                    const collection = state.collections.find(c => 
                        c.collectionId === nft.collectionId || 
                        c.collectionToken === nft.collectionToken
                    );
                    const royaltyPercent = collection?.creatorRoyaltyPercent || SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
                    const marketplaceFeePercent = SECONDARY_SALE_MARKETPLACE_PERCENT;
                    const sellerPercent = 1 - royaltyPercent - marketplaceFeePercent;
                    
                    const sellerPayout = totalPrice * sellerPercent;
                    const creatorRoyalty = totalPrice * royaltyPercent;
                    const marketplaceFee = totalPrice * marketplaceFeePercent;
                    
                    console.log("üí∞ Fee breakdown:", {
                        totalPrice,
                        royaltyPercent: `${(royaltyPercent * 100).toFixed(1)}%`,
                        sellerPayout,
                        creatorRoyalty,
                        marketplaceFee
                    });
                    
                    // FIX #4: Initialize escrow client for NFT transfer
                    if (typeof state.escrowClient.init === 'function') {
                        await state.escrowClient.init();
                    }
                    
                    // Build payment transaction (buyer pays)
                    const pB = state.keetaClient.initBuilder();
                    pB.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                    
                    // Send payments
                    pB.send(
                        KeetaNet.lib.Account.fromPublicKeyString(nft.owner || nft.creator),
                        BigInt(Math.floor(sellerPayout * KTA_DECIMALS)),
                        state.keetaClient.baseToken
                    );
                    pB.send(
                        KeetaNet.lib.Account.fromPublicKeyString(nft.creator),
                        BigInt(Math.floor(creatorRoyalty * KTA_DECIMALS)),
                        state.keetaClient.baseToken
                    );
                    pB.send(
                        KeetaNet.lib.Account.fromPublicKeyString(MARKETPLACE_FEE_WALLET),
                        BigInt(Math.floor(marketplaceFee * KTA_DECIMALS)),
                        state.keetaClient.baseToken
                    );
                    
                    // FIX #4: Build escrow release transaction (escrow sends NFT to buyer)
                    const eB = state.escrowClient.initBuilder();
                    eB.updateAccounts({ signer: state.escrowAccount, account: state.escrowAccount });
                    eB.send(
                        KeetaNet.lib.Account.fromPublicKeyString(state.address), // To buyer
                        1n, // 1 NFT token
                        KeetaNet.lib.Account.fromPublicKeyString(nft.tokenId) // The NFT
                    );
                    
                    // Execute both transactions
                    await Promise.all([
                        state.keetaClient.computeBuilderBlocks(pB),
                        state.escrowClient.computeBuilderBlocks(eB)
                    ]);
                    
                    const [purchaseTx, escrowReleaseTx] = await Promise.all([
                        state.keetaClient.publishBuilder(pB),
                        state.escrowClient.publishBuilder(eB)
                    ]);
                    
                    // Extract transaction hash
                    let txHash = null;
                    if (purchaseTx?.voteStaple?.blocks?.[0]?.$hash) {
                        txHash = purchaseTx.voteStaple.blocks[0].$hash;
                    } else if (purchaseTx?.hash) {
                        txHash = purchaseTx.hash;
                    }
                    
                    console.log("üìù Purchase tx:", purchaseTx);
                    console.log("üìù Escrow release tx:", escrowReleaseTx);
                    console.log("üîç Extracted tx hash:", txHash);
                    
                    // Update database
                    await updateDoc(doc(db, 'nfts', nftId), {
                        status: 'sold',
                        owner: state.address,
                        previousOwner: nft.owner,
                        isListed: false,
                        listedPrice: null,
                        listedCurrency: null,
                        inEscrow: false, // No longer in escrow
                        soldAt: new Date().toISOString(),
                        soldPrice: price,
                        soldCurrency: currency,
                        saleType: 'secondary',
                        lastTxHash: txHash
                    });
                }
                
                // Step 4: Update local state immediately (no waiting)
                const nftIndex = state.nfts.findIndex(n => n.id === nftId);
                if (nftIndex !== -1) {
                    state.nfts[nftIndex].owner = state.address;
                    state.nfts[nftIndex].isListed = false;
                    state.nfts[nftIndex].listedPrice = null;
                    state.nfts[nftIndex].listedCurrency = null;
                    // FIX #10: Update local state with sale data for charts
                    state.nfts[nftIndex].soldAt = new Date().toISOString();
                    state.nfts[nftIndex].soldPrice = price;
                    state.nfts[nftIndex].soldCurrency = currency;
                    state.nfts[nftIndex].saleType = 'secondary';
                    state.nfts[nftIndex].lastTxHash = txHash;
                }
                
                // Success notification
                window.notify(`‚úÖ ${nft.name} purchased successfully!`, "success");
                
                // Record transaction (don't let this break the flow)
                try {
                    // Generate collectionId if missing (for old NFTs)
                    let collectionId = nft.collectionId;
                    if (!collectionId && nft.collectionToken) {
                        collectionId = `collection_${getNormalizedId(nft.collectionToken)}`;
                        console.log("‚ö†Ô∏è NFT missing collectionId, generated:", collectionId);
                    }
                    
                    // FIX #10: Record BOTH purchase (buyer) AND sale (seller) transactions
                    await Promise.all([
                        // Buyer's purchase transaction
                        window.recordTransaction({
                            type: 'purchase',
                            nftId: nft.id || nftId,
                            nftName: nft.name,
                            collection: nft.collectionName || nft.collection,
                            collectionId: collectionId,
                            price: price,
                            currency: currency,
                            counterParty: nft.owner || nft.creator,
                            txHash: txHash
                        }),
                        // Seller's sale transaction (for chart completeness)
                        window.recordTransaction({
                            type: 'sale',
                            nftId: nft.id || nftId,
                            nftName: nft.name,
                            collection: nft.collectionName || nft.collection,
                            collectionId: collectionId,
                            price: price,
                            currency: currency,
                            counterParty: state.address, // Buyer
                            txHash: txHash,
                            sellerWallet: nft.owner || nft.creator // Track original seller
                        })
                    ]);
                    
                    console.log("‚úÖ Both purchase & sale transactions recorded with hash:", txHash);
                    
                    // Refresh transaction history
                    await window.loadTransactions();
                } catch (txError) {
                    console.warn("‚ö†Ô∏è Could not record transaction:", txError.message);
                }
                
                // Step 5: Update UI (async, don't wait)
                setTimeout(async () => {
                    window.refreshBalance();
                    await window.renderMarketplace();
                    await window.renderCollection();
                    // FIX #10: Force immediate chart update with fresh data
                    await window.loadNFTsFromFirebase();
                    window.updateMarketChart();
                }, 100);
                
            } catch (e) {
                console.error("Purchase error:", e);
                window.notify(`‚ùå Purchase failed: ${e.message}`, "error");
            }
        };

        // Utility functions
        window.setPriceMode = (mode) => {
            state.priceMode = mode;
            document.querySelectorAll('.price-mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${mode}`)?.classList.add('active');
            const ktaBox = document.getElementById('ktaInputBox');
            const punksBox = document.getElementById('punksInputBox');
            if (ktaBox) ktaBox.style.opacity = (mode === 'kta' || mode === 'hybrid') ? "1" : "0.2";
            if (punksBox) punksBox.style.opacity = (mode === 'punks' || mode === 'hybrid') ? "1" : "0.2";
        };

        window.checkEscrowAccess = () => {
            const isEscrow = state.address && state.escrowAddress && state.address.toLowerCase().trim() === state.escrowAddress.toLowerCase().trim();
            
            // Show escrow admin tab only for escrow wallet
            document.getElementById('nav-escrow-admin')?.classList.toggle('hidden', !isEscrow);
            
            // Show diagnostics and maintenance ONLY for escrow wallet
            document.getElementById('escrowDiagnostics')?.classList.toggle('hidden', !isEscrow);
            document.getElementById('escrowMaintenanceProtocol')?.classList.toggle('hidden', !isEscrow);
            
            return isEscrow;
        };

        window.switchTab = (tab) => {
            state.currentTab = tab;
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            const cEl = document.getElementById(`tab-${tab}`);
            if (cEl) cEl.classList.remove('hidden');
            const nEl = document.getElementById(`nav-${tab}`);
            if (nEl) nEl.classList.add('active');
            window.refreshAuthGate();
            if (tab === 'collection' && state.address) window.renderCollection();
            if (tab === 'market') { 
                window.renderMarketplace(); 
                window.renderDrops(); 
                window.populateChartSelector();
                window.updateMarketChart(); 
            }
            if (tab === 'transactions' && state.address) {
                window.loadTransactions();
            }
            if (tab === 'offers' && state.address) {
                window.loadOffers();
                window.renderOffers();
            }
            if (tab === 'airdrop' && state.address) {
                // Check if already unlocked
                if (airdropState.unlocked) {
                    document.getElementById('airdropPasscodeGate')?.classList.add('hidden');
                    document.getElementById('airdropContent')?.classList.remove('hidden');
                    window.loadAirdropCollections();
                    window.renderAirdropHistory();
                } else {
                    // Show passcode gate
                    document.getElementById('airdropPasscodeGate')?.classList.remove('hidden');
                    document.getElementById('airdropContent')?.classList.add('hidden');
                    document.getElementById('airdropPasscodeInput').value = '';
                    document.getElementById('airdropPasscodeInput').focus();
                }
            }
        };

        // Toggle monitoring dropdown
        window.toggleMonitoring = () => {
            const dropdown = document.getElementById('monitoringDropdown');
            const btnText = document.getElementById('monitoringBtnText');
            
            if (dropdown && btnText) {
                const isHidden = dropdown.classList.contains('hidden');
                
                if (isHidden) {
                    dropdown.classList.remove('hidden');
                    btnText.innerText = 'Hide Monitoring';
                    window.renderWatchlist();
                } else {
                    dropdown.classList.add('hidden');
                    btnText.innerText = 'Show Monitoring';
                }
            }
        };
        
        // Render watchlist
        window.renderWatchlist = () => {
            const grid = document.getElementById('watchlistGrid');
            if (!grid) return;
            
            const monitored = state.watchlist || [];
            document.getElementById('monitoredCount').innerText = `${monitored.length} monitored`;
            
            if (monitored.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-500 fira text-sm py-10">No monitored NFTs yet</div>';
                return;
            }
            
            grid.innerHTML = monitored.map(nftId => {
                const nft = state.nfts.find(n => n.id === nftId);
                if (!nft) return '';
                const watchImgPath = window.getNFTImagePath(nft);
                return `
                    <div class="glass-card p-5 flex flex-col group border-white/5 hover:border-cyan-500/30 transition-all">
                        <img src="${watchImgPath ? 'https://gateway.pinata.cloud/ipfs/' + watchImgPath : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E'}" class="sharp-img rounded-lg aspect-square object-cover mb-4">
                        <h4 class="orbitron text-[9px] font-bold text-white uppercase truncate">${nft.name}</h4>
                        <button onclick="window.removeFromWatchlist('${nftId}')" class="mt-2 p-2 text-[8px] text-gray-500 hover:text-red-400 transition-colors">Remove</button>
                    </div>
                `;
            }).join('');
        };
        
        window.addToWatchlist = (nftId) => {
            if (!state.watchlist.includes(nftId)) {
                state.watchlist.push(nftId);
                window.notify("Added to monitoring", "success");
            }
        };
        
        window.removeFromWatchlist = (nftId) => {
            state.watchlist = state.watchlist.filter(id => id !== nftId);
            window.renderWatchlist();
            window.notify("Removed from monitoring", "success");
        };
        
        window.runNeuralRepair = async () => { 
            window.notify("Running diagnostics...", "success"); 
            await window.loadNFTsFromFirebase(); 
            window.notify("Sync complete", "success"); 
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WHITELIST SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Toggle whitelist settings controls visibility (when user checks Enable Whitelist)
        window.toggleWhitelistSettingsUI = () => {
            const enabled = document.getElementById('whitelistEnabled')?.checked || false;
            const controls = document.getElementById('whitelistControls');
            if (controls) {
                if (enabled) controls.classList.remove('hidden');
                else controls.classList.add('hidden');
            }
        };

        // Load whitelist settings for collection
        window.loadWhitelistSettings = async (collectionId) => {
            try {
                const settingsRef = doc(db, 'whitelistSettings', collectionId);
                const snap = await getDoc(settingsRef);
                
                if (snap.exists()) {
                    const data = snap.data();
                    state.whitelistSettings[collectionId] = data;
                    
                    // Populate UI
                    document.getElementById('whitelistEnabled').checked = data.enabled || false;
                    document.getElementById('whitelistMode').value = data.mode || 'BLIND_MINT';
                    document.getElementById('whitelistDefaultMax').value = data.defaultMaxMints || 1;
                    
                    if (data.mintWindowStart) {
                        const start = new Date(data.mintWindowStart);
                        document.getElementById('whitelistStart').value = start.toISOString().slice(0, 16);
                    }
                    if (data.mintWindowEnd) {
                        const end = new Date(data.mintWindowEnd);
                        document.getElementById('whitelistEnd').value = end.toISOString().slice(0, 16);
                    }
                    
                    // Load phases
                    if (data.phases && Array.isArray(data.phases)) {
                        window.whitelistPhases = data.phases;
                        window.renderWhitelistPhases();
                    }
                    
                    window.toggleWhitelistSettingsUI?.();
                } else {
                    state.whitelistSettings[collectionId] = { enabled: false, wallets: [] };
                }
                
                // Load wallets
                await window.loadWhitelistWallets(collectionId);
                
            } catch (error) {
                console.error("Error loading whitelist settings:", error);
            }
        };
        
        // Load whitelist wallets
        window.loadWhitelistWallets = async (collectionId) => {
            try {
                const walletsRef = collection(db, 'whitelistWallets');
                const q = query(walletsRef, where('collectionId', '==', collectionId));
                const snapshot = await getDocs(q);
                
                const wallets = [];
                snapshot.forEach((doc) => {
                    wallets.push({ id: doc.id, ...doc.data() });
                });
                
                state.whitelistWallets[collectionId] = wallets;
                window.renderWhitelistTable();
                
            } catch (error) {
                console.error("Error loading whitelist wallets:", error);
            }
        };
        
        // Add wallet to whitelist
        window.addWhitelistWallet = async () => {
            const wallet = document.getElementById('whitelistWallet').value.trim();
            const maxMints = parseInt(document.getElementById('whitelistMaxMints').value) || 1;
            
            if (!wallet) {
                return window.notify("Enter wallet address", "error");
            }
            
            // Basic validation - must start with 'keeta_' or be long enough
            if (wallet.length < 20) {
                return window.notify("Invalid wallet address", "error");
            }
            
            // Check for duplicates in current session
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) {
                return window.notify("No active collection", "error");
            }
            
            const existing = state.whitelistWallets[currentCollection.collectionId] || [];
            if (existing.some(w => w.walletAddress.toLowerCase() === wallet.toLowerCase())) {
                return window.notify("Wallet already whitelisted", "error");
            }
            
            try {
                const walletData = {
                    collectionId: currentCollection.collectionId,
                    walletAddress: wallet,
                    maxMints: maxMints,
                    usedMints: 0,
                    createdByCreator: true,
                    createdAt: new Date().toISOString()
                };
                
                const walletRef = doc(collection(db, 'whitelistWallets'));
                await setDoc(walletRef, walletData);
                
                // Add to local state
                if (!state.whitelistWallets[currentCollection.collectionId]) {
                    state.whitelistWallets[currentCollection.collectionId] = [];
                }
                state.whitelistWallets[currentCollection.collectionId].push({ id: walletRef.id, ...walletData });
                
                // Clear inputs
                document.getElementById('whitelistWallet').value = '';
                document.getElementById('whitelistMaxMints').value = '1';
                
                window.renderWhitelistTable();
                window.notify("Wallet added to whitelist", "success");
                
            } catch (error) {
                console.error("Error adding wallet:", error);
                window.notify("Failed to add wallet", "error");
            }
        };
        
        // Remove wallet from whitelist
        window.removeWhitelistWallet = async (collectionId, walletId) => {
            try {
                const walletRef = doc(db, 'artifacts', state.appId, 'public', 'data', 'whitelistWallets', walletId);
                await deleteDoc(walletRef);
                
                // Remove from local state
                if (state.whitelistWallets[collectionId]) {
                    state.whitelistWallets[collectionId] = state.whitelistWallets[collectionId].filter(w => w.id !== walletId);
                }
                
                window.renderWhitelistTable();
                window.notify("Wallet removed", "success");
                
            } catch (error) {
                console.error("Error removing wallet:", error);
                window.notify("Failed to remove wallet", "error");
            }
        };
        
        // Clear all whitelist wallets
        window.clearWhitelist = async () => {
            if (!confirm('‚ö†Ô∏è Clear all whitelisted wallets?\n\nThis cannot be undone.')) {
                return;
            }
            
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) return;
            
            const wallets = state.whitelistWallets[currentCollection.collectionId] || [];
            
            for (const wallet of wallets) {
                await window.removeWhitelistWallet(currentCollection.collectionId, wallet.id);
            }
        };
        
        // Handle file upload (CSV/JSON)
        window.handleWhitelistUpload = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) {
                return window.notify("No active collection", "error");
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                
                try {
                    let wallets = [];
                    
                    // Try JSON first
                    if (file.name.endsWith('.json')) {
                        const json = JSON.parse(text);
                        wallets = json.map(item => ({
                            wallet: item.wallet || item.wallet_address,
                            maxMints: item.max_mints || item.maxMints || 1
                        }));
                    } else {
                        // Parse CSV
                        const lines = text.trim().split('\n');
                        const hasHeader = lines[0].toLowerCase().includes('wallet');
                        const startIdx = hasHeader ? 1 : 0;
                        
                        for (let i = startIdx; i < lines.length; i++) {
                            const parts = lines[i].split(',');
                            if (parts.length >= 1 && parts[0].trim()) {
                                wallets.push({
                                    wallet: parts[0].trim(),
                                    maxMints: parseInt(parts[1]) || 1
                                });
                            }
                        }
                    }
                    
                    // Add all wallets
                    let added = 0;
                    let failed = 0;
                    
                    for (const item of wallets) {
                        try {
                            if (item.wallet && item.wallet.length > 20) {
                                const walletData = {
                                    collectionId: currentCollection.collectionId,
                                    walletAddress: item.wallet,
                                    maxMints: item.maxMints,
                                    usedMints: 0,
                                    createdByCreator: true,
                                    createdAt: new Date().toISOString()
                                };
                                
                                const walletRef = doc(collection(db, 'whitelistWallets'));
                                await setDoc(walletRef, walletData);
                                added++;
                            } else {
                                failed++;
                            }
                        } catch (error) {
                            failed++;
                        }
                    }
                    
                    await window.loadWhitelistWallets(currentCollection.collectionId);
                    window.notify(`‚úÖ Import complete: ${added} added, ${failed} failed`, "success");
                    
                    event.target.value = ''; // Reset file input
                    
                } catch (error) {
                    console.error("File upload error:", error);
                    window.notify("Failed to parse file", "error");
                }
            };
            
            reader.readAsText(file);
        };
        
        // Render whitelist table
        window.renderWhitelistTable = () => {
            const container = document.getElementById('whitelistTable');
            const countEl = document.getElementById('whitelistCount');
            
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) {
                container.innerHTML = '<div class="text-center text-gray-600 fira text-xs py-8">No collection selected</div>';
                countEl.innerText = '0';
                return;
            }
            
            const wallets = state.whitelistWallets[currentCollection.collectionId] || [];
            countEl.innerText = wallets.length;
            
            if (wallets.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-600 fira text-xs py-8">No wallets added yet</div>';
                return;
            }
            
            container.innerHTML = wallets.map(w => `
                <div class="flex items-center justify-between p-3 bg-black/60 rounded-lg border border-white/5 hover:border-cyan-500/30 transition-all">
                    <div class="flex-1 min-w-0">
                        <div class="fira text-[10px] text-cyan-400 font-mono truncate">${w.walletAddress}</div>
                        <div class="fira text-[9px] text-gray-600 mt-1">Used: ${w.usedMints}/${w.maxMints} mints</div>
                    </div>
                    <button onclick="window.removeWhitelistWallet('${currentCollection.collectionId}', '${w.id}')" 
                            class="ml-3 px-3 py-1 rounded border border-red-500/30 text-red-400 text-[10px] hover:bg-red-500/10 transition-all">
                        Remove
                    </button>
                </div>
            `).join('');
        };
        
        // Save whitelist settings
        // WHITELIST PHASES WITH CUSTOM PRICING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.whitelistPhases = [];
        
        window.addWhitelistPhase = () => {
            const phaseNumber = window.whitelistPhases.length + 1;
            const phaseId = `phase_${Date.now()}`;
            
            const phase = {
                id: phaseId,
                name: `Phase ${phaseNumber}`,
                priceKTA: 1,
                startTime: null,
                endTime: null,
                maxMintsPerWallet: 1,
                wallets: []
            };
            
            window.whitelistPhases.push(phase);
            window.renderWhitelistPhases();
        };
        
        window.removeWhitelistPhase = (phaseId) => {
            window.whitelistPhases = window.whitelistPhases.filter(p => p.id !== phaseId);
            window.renderWhitelistPhases();
        };
        
        window.renderWhitelistPhases = () => {
            const container = document.getElementById('whitelistPhasesContainer');
            if (!container) return;
            
            if (window.whitelistPhases.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-4 text-gray-600 fira text-xs">
                        No phases added yet. Click "+ Add Phase" to create one.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = window.whitelistPhases.map((phase, index) => `
                <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20 space-y-3">
                    <div class="flex justify-between items-center">
                        <input type="text" value="${phase.name}" 
                               onchange="window.whitelistPhases[${index}].name = this.value"
                               class="bg-transparent text-purple-400 orbitron text-sm font-bold outline-none">
                        <button onclick="window.removeWhitelistPhase('${phase.id}')" 
                                class="text-red-400 hover:text-red-300 text-xs">
                            ‚úï Remove
                        </button>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-[8px] fira text-gray-500 mb-1">Price (KTA)</label>
                            <input type="number" value="${phase.priceKTA}" step="0.1" min="0"
                                   onchange="window.whitelistPhases[${index}].priceKTA = parseFloat(this.value)"
                                   class="w-full bg-black/60 border border-purple-500/20 rounded px-3 py-2 text-white fira text-xs outline-none">
                        </div>
                        <div>
                            <label class="block text-[8px] fira text-gray-500 mb-1">Max Mints</label>
                            <input type="number" value="${phase.maxMintsPerWallet}" min="1" max="10"
                                   onchange="window.whitelistPhases[${index}].maxMintsPerWallet = parseInt(this.value)"
                                   class="w-full bg-black/60 border border-purple-500/20 rounded px-3 py-2 text-white fira text-xs outline-none">
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-[8px] fira text-gray-500 mb-1">Start Time</label>
                            <input type="datetime-local" 
                                   value="${phase.startTime ? new Date(phase.startTime).toISOString().slice(0, 16) : ''}"
                                   onchange="window.whitelistPhases[${index}].startTime = this.value ? new Date(this.value).toISOString() : null"
                                   class="w-full bg-black/60 border border-purple-500/20 rounded px-2 py-2 text-white fira text-[10px] outline-none">
                        </div>
                        <div>
                            <label class="block text-[8px] fira text-gray-500 mb-1">End Time</label>
                            <input type="datetime-local"
                                   value="${phase.endTime ? new Date(phase.endTime).toISOString().slice(0, 16) : ''}"
                                   onchange="window.whitelistPhases[${index}].endTime = this.value ? new Date(this.value).toISOString() : null"
                                   class="w-full bg-black/60 border border-purple-500/20 rounded px-2 py-2 text-white fira text-[10px] outline-none">
                        </div>
                    </div>
                    
                    <div>
                        <label class="block text-[8px] fira text-gray-500 mb-1">Wallets (comma-separated)</label>
                        <textarea 
                            onchange="window.whitelistPhases[${index}].wallets = this.value.split(',').map(w => w.trim()).filter(Boolean)"
                            class="w-full bg-black/60 border border-purple-500/20 rounded px-3 py-2 text-white fira text-[10px] outline-none font-mono resize-none"
                            rows="2"
                            placeholder="keeta_abc..., keeta_def...">${phase.wallets.join(', ')}</textarea>
                        <p class="text-[9px] fira text-gray-600 mt-1">${phase.wallets.length} wallets in this phase</p>
                    </div>
                </div>
            `).join('');
        };
        
        window.getActivePhaseForWallet = (collectionId, walletAddress) => {
            const settings = state.whitelistSettings[collectionId];
            if (!settings?.phases || settings.phases.length === 0) return null;
            
            const now = Date.now();
            
            // Find active phase for this wallet
            for (const phase of settings.phases) {
                // Check if wallet is in this phase
                if (!phase.wallets.includes(walletAddress)) continue;
                
                // Check if phase is active (time-based)
                if (phase.startTime) {
                    const startTime = new Date(phase.startTime).getTime();
                    if (now < startTime) continue; // Phase hasn't started
                }
                
                if (phase.endTime) {
                    const endTime = new Date(phase.endTime).getTime();
                    if (now > endTime) continue; // Phase has ended
                }
                
                return phase; // Found active phase
            }
            
            return null; // Not in any active phase
        };

        window.saveWhitelistSettings = async () => {
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) {
                return window.notify("No active collection", "error");
            }
            
            try {
                const settings = {
                    collectionId: currentCollection.collectionId,
                    enabled: document.getElementById('whitelistEnabled').checked,
                    mode: document.getElementById('whitelistMode').value,
                    defaultMaxMints: parseInt(document.getElementById('whitelistDefaultMax').value) || 1,
                    mintWindowStart: document.getElementById('whitelistStart').value ? new Date(document.getElementById('whitelistStart').value).toISOString() : null,
                    mintWindowEnd: document.getElementById('whitelistEnd').value ? new Date(document.getElementById('whitelistEnd').value).toISOString() : null,
                    phases: window.whitelistPhases, // Save phases with custom pricing
                    updatedAt: new Date().toISOString()
                };
                
                const settingsRef = doc(db, 'whitelistSettings', currentCollection.collectionId);
                await setDoc(settingsRef, settings, { merge: true });
                
                state.whitelistSettings[currentCollection.collectionId] = settings;
                
                window.notify("‚úÖ Whitelist settings saved", "success");
                
            } catch (error) {
                console.error("Error saving whitelist settings:", error);
                window.notify("Failed to save settings", "error");
            }
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TRANSACTION HISTORY MANAGEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Record a transaction
        window.recordTransaction = async (txData) => {
            if (!state.address) return;
            
            try {
                const transaction = {
                    id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    timestamp: new Date().toISOString(),
                    wallet: state.address,
                    type: txData.type, // 'sale', 'purchase', 'listing', 'cancellation', 'mint'
                    nftId: txData.nftId,
                    nftName: txData.nftName,
                    collection: txData.collection,
                    collectionId: txData.collectionId,
                    price: txData.price || 0,
                    currency: txData.currency || 'KTA',
                    counterParty: txData.counterParty || null,
                    txHash: txData.txHash || null,
                    status: 'completed'
                };
                
                // Save to Firebase
                await setDoc(
                    doc(db, 'transactions', transaction.id),
                    transaction
                );
                
                console.log("‚úÖ Transaction recorded:", transaction.type, transaction.txHash ? "txHash:" + transaction.txHash.substring(0, 16) + "..." : "(no hash)");
                
                // Update wallet stats (KTA spent/earned tracking)
                if (transaction.currency === 'KTA' && transaction.price > 0) {
                    await window.updateWalletStats(transaction);
                }
                
                // Real-time: refresh transaction history so new tx shows immediately
                if (typeof window.loadTransactions === 'function') {
                    await window.loadTransactions();
                }
                
            } catch (error) {
                console.error("‚ùå Error recording transaction:", error);
            }
        };
        
        // Update wallet stats for KTA tracking
        window.updateWalletStats = async (transaction) => {
            try {
                const walletStatsRef = doc(db, 'artifacts', state.appId, 'public', 'data', 'walletStats', state.address);
                const walletStatsSnap = await getDoc(walletStatsRef);
                
                let stats = walletStatsSnap.exists() ? walletStatsSnap.data() : {
                    wallet: state.address,
                    totalSpent: 0,
                    totalEarned: 0,
                    totalMinted: 0,
                    totalPurchased: 0,
                    totalSold: 0,
                    lastUpdated: new Date().toISOString()
                };
                
                // Update based on transaction type
                if (transaction.type === 'mint' || transaction.type === 'purchase') {
                    stats.totalSpent += transaction.price;
                    if (transaction.type === 'mint') stats.totalMinted++;
                    if (transaction.type === 'purchase') stats.totalPurchased++;
                } else if (transaction.type === 'sale') {
                    stats.totalEarned += transaction.price;
                    stats.totalSold++;
                }
                
                stats.lastUpdated = new Date().toISOString();
                
                await setDoc(walletStatsRef, stats);
                console.log("üìä Wallet stats updated:", stats);
                
            } catch (error) {
                console.error("‚ùå Error updating wallet stats:", error);
            }
        };
        
        // Load user transactions
        window.loadTransactions = async () => {
            if (!state.address) return;
            
            try {
                console.log("üì• Loading transaction history...");
                
                const txRef = collection(db, 'transactions');
                
                // Try with ordering first
                let snapshot;
                try {
                    const q = query(txRef, where('wallet', '==', state.address), orderBy('timestamp', 'desc'));
                    snapshot = await getDocs(q);
                } catch (indexError) {
                    // If index doesn't exist, load without ordering (will sort client-side)
                    // To create index: Firebase Console > Firestore > Indexes > Create Index
                    // Collection: transactions, Fields: wallet (Ascending), timestamp (Descending)
                    if (!indexError.message.includes('index')) {
                        console.warn("‚ö†Ô∏è Query error:", indexError.message);
                    }
                    const q = query(txRef, where('wallet', '==', state.address));
                    snapshot = await getDocs(q);
                }
                
                state.allTransactions = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                // Sort manually if we couldn't use orderBy
                state.allTransactions.sort((a, b) => {
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });
                
                state.transactions = [...state.allTransactions];
                
                console.log(`‚úÖ Loaded ${state.transactions.length} transactions`);
                
                // Render transactions
                window.renderTransactions();
                window.updateTransactionStats();
                
            } catch (error) {
                console.error("‚ùå Error loading transactions:", error);
                
                // Check if it's an index error
                if (error.message && error.message.includes('index')) {
                    console.warn("‚ö†Ô∏è Firebase index needed for transactions. Creating index...");
                    console.log("üìã Index URL:", error.message.match(/https:\/\/[^\s]+/)?.[0]);
                    
                    // Show empty state for now
                    state.transactions = [];
                    state.allTransactions = [];
                    window.renderTransactions();
                    
                    // Show helpful message
                    const tbody = document.getElementById('transactionsTableBody');
                    if (tbody) {
                        tbody.innerHTML = `
                            <tr>
                                <td colspan="7" class="p-12 text-center">
                                    <div class="text-yellow-400 fira text-sm mb-2">‚ö†Ô∏è Database Index Required</div>
                                    <div class="text-gray-500 fira text-xs">Transaction history needs a database index.</div>
                                    <div class="text-gray-500 fira text-xs">This is a one-time setup. Creating automatically...</div>
                                </td>
                            </tr>
                        `;
                    }
                } else {
                    state.transactions = [];
                    state.allTransactions = [];
                }
            }
        };
        
        // Render transactions table
        window.renderTransactions = () => {
            const tbody = document.getElementById('transactionsTableBody');
            if (!tbody) return;
            
            if (state.transactions.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" class="p-12 text-center">
                            <div class="text-gray-500 fira text-sm">No transactions found</div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = state.transactions.map(tx => {
                const date = new Date(tx.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                // Type badge color
                const typeBadge = {
                    'sale': '<span class="px-2 py-1 bg-green-500/20 text-green-400 rounded text-xs font-bold">SALE</span>',
                    'purchase': '<span class="px-2 py-1 bg-purple-500/20 text-purple-400 rounded text-xs font-bold">PURCHASE</span>',
                    'listing': '<span class="px-2 py-1 bg-cyan-500/20 text-cyan-400 rounded text-xs font-bold">LISTING</span>',
                    'cancellation': '<span class="px-2 py-1 bg-red-500/20 text-red-400 rounded text-xs font-bold">CANCEL</span>',
                    'mint': '<span class="px-2 py-1 bg-yellow-500/20 text-yellow-400 rounded text-xs font-bold">MINT</span>'
                }[tx.type] || '<span class="px-2 py-1 bg-gray-500/20 text-gray-400 rounded text-xs font-bold">UNKNOWN</span>';
                
                const priceDisplay = tx.price > 0 ? `${tx.price} ${tx.currency}` : '‚Äî';
                const counterPartyDisplay = tx.counterParty ? tx.counterParty.substring(0, 12) + '...' : '‚Äî';
                
                // Tx hash with copy button
                const txHashDisplay = tx.txHash ? `
                    <div class="flex items-center gap-2">
                        <span class="font-mono text-xs text-cyan-400">${tx.txHash.substring(0, 16)}...</span>
                        <button onclick="navigator.clipboard.writeText('${tx.txHash}'); window.notify('Tx hash copied!', 'success')" 
                                class="text-gray-500 hover:text-cyan-400 transition-colors" 
                                title="Copy full hash">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                            </svg>
                        </button>
                    </div>
                ` : '<span class="text-gray-600">‚Äî</span>';
                
                return `
                    <tr class="border-b border-white/5 hover:bg-white/5 transition-colors">
                        <td class="p-4 fira text-xs text-gray-400">${dateStr}</td>
                        <td class="p-4">${typeBadge}</td>
                        <td class="p-4 fira text-xs text-white font-bold truncate max-w-xs">${tx.nftName || 'Unknown'}</td>
                        <td class="p-4 fira text-xs text-cyan-400 truncate max-w-xs">${tx.collection || 'Unknown'}</td>
                        <td class="p-4 fira text-xs text-green-400 font-bold">${priceDisplay}</td>
                        <td class="p-4 fira text-xs text-gray-400">${counterPartyDisplay}</td>
                        <td class="p-4">${txHashDisplay}</td>
                    </tr>
                `;
            }).join('');
        };
        
        // Update transaction stats
        window.updateTransactionStats = () => {
            const totalCount = state.transactions.length;
            const sales = state.transactions.filter(tx => tx.type === 'sale');
            const purchases = state.transactions.filter(tx => tx.type === 'purchase' || tx.type === 'mint'); // Include mints!
            const mints = state.transactions.filter(tx => tx.type === 'mint');
            
            const totalSales = sales.reduce((sum, tx) => sum + (tx.price || 0), 0);
            const totalPurchases = purchases.reduce((sum, tx) => sum + (tx.price || 0), 0); // Now includes mint prices!
            
            document.getElementById('txTotalCount').innerText = totalCount;
            document.getElementById('txTotalSales').innerText = `${totalSales.toFixed(2)} KTA`;
            document.getElementById('txTotalPurchases').innerText = `${totalPurchases.toFixed(2)} KTA`;
            document.getElementById('txTotalMints').innerText = mints.length;
            
            // Last Recorded display
            const lastEl = document.getElementById('txLastRecorded');
            if (lastEl) {
                const latest = state.allTransactions?.[0];
                if (latest?.timestamp) {
                    const d = new Date(latest.timestamp);
                    const txInfo = latest.txHash ? `${latest.txHash.substring(0, 12)}...` : latest.nftName || latest.type;
                    lastEl.innerHTML = `Last recorded: ${d.toLocaleString()} <span class="text-cyan-500/80">(${txInfo})</span>`;
                } else {
                    lastEl.innerText = totalCount > 0 ? 'Last recorded: ‚Äî' : '‚Äî';
                }
            }
        };
        
        // Filter transactions
        window.filterTransactions = () => {
            const typeFilter = document.getElementById('txTypeFilter')?.value || 'all';
            const dateFilter = document.getElementById('txDateFilter')?.value || 'all';
            const searchInput = document.getElementById('txSearchInput')?.value.toLowerCase() || '';
            
            state.transactions = state.allTransactions.filter(tx => {
                // Type filter
                if (typeFilter !== 'all' && tx.type !== typeFilter) return false;
                
                // Date filter
                if (dateFilter !== 'all') {
                    const txDate = new Date(tx.timestamp);
                    const now = new Date();
                    
                    if (dateFilter === 'today') {
                        if (txDate.toDateString() !== now.toDateString()) return false;
                    } else if (dateFilter === 'week') {
                        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        if (txDate < weekAgo) return false;
                    } else if (dateFilter === 'month') {
                        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        if (txDate < monthAgo) return false;
                    }
                }
                
                // Search filter
                if (searchInput) {
                    const searchable = `${tx.nftName} ${tx.collection}`.toLowerCase();
                    if (!searchable.includes(searchInput)) return false;
                }
                
                return true;
            });
            
            window.renderTransactions();
            window.updateTransactionStats();
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WHITELIST MANAGEMENT FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.toggleWhitelistUI = () => {
            const enabled = document.getElementById('enableWhitelist')?.checked || false;
            const container = document.getElementById('whitelistInputContainer');
            
            if (container) {
                if (enabled) {
                    container.classList.remove('hidden');
                } else {
                    container.classList.add('hidden');
                }
            }
        };
        
        window.updateWhitelistCount = () => {
            const textarea = document.getElementById('whitelistAddresses');
            if (!textarea) return;
            
            const addresses = textarea.value.split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr.length > 0);
            
            document.getElementById('whitelistCount').innerText = `${addresses.length} address${addresses.length !== 1 ? 'es' : ''}`;
        };
        
        window.validateWhitelist = () => {
            const textarea = document.getElementById('whitelistAddresses');
            if (!textarea) return;
            
            const addresses = textarea.value.split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr.length > 0);
            
            if (addresses.length === 0) {
                window.showWhitelistStatus('No addresses to validate', 'error');
                return;
            }
            
            const validAddresses = [];
            const invalidAddresses = [];
            
            addresses.forEach((addr, index) => {
                // Validate Keeta address format (starts with keeta_ and has proper length)
                if (addr.startsWith('keeta_') && addr.length > 20) {
                    validAddresses.push(addr);
                } else {
                    invalidAddresses.push(`Line ${index + 1}: ${addr.substring(0, 30)}...`);
                }
            });
            
            if (invalidAddresses.length > 0) {
                window.showWhitelistStatus(
                    `‚ö†Ô∏è Found ${invalidAddresses.length} invalid address(es):\n${invalidAddresses.slice(0, 5).join('\n')}${invalidAddresses.length > 5 ? '\n...' : ''}`, 
                    'error'
                );
            } else {
                window.showWhitelistStatus(
                    `‚úì All ${validAddresses.length} addresses are valid!`, 
                    'success'
                );
            }
        };
        
        window.showWhitelistStatus = (message, type) => {
            const statusEl = document.getElementById('whitelistStatus');
            if (!statusEl) return;
            
            statusEl.classList.remove('hidden');
            statusEl.className = 'p-3 rounded-lg border';
            
            if (type === 'success') {
                statusEl.classList.add('border-green-500/50', 'bg-green-500/10', 'text-green-400');
            } else {
                statusEl.classList.add('border-red-500/50', 'bg-red-500/10', 'text-red-400');
            }
            
            statusEl.innerHTML = `<div class="fira text-xs whitespace-pre-wrap">${message}</div>`;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusEl.classList.add('hidden');
            }, 5000);
        };
        
        window.clearWhitelist = () => {
            const textarea = document.getElementById('whitelistAddresses');
            if (textarea) {
                textarea.value = '';
                window.updateWhitelistCount();
                window.showWhitelistStatus('Whitelist cleared', 'success');
            }
        };
        
        window.importWhitelistCSV = () => {
            // Create file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv,.txt';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const addresses = text.split(/[\n,]/)
                        .map(addr => addr.trim())
                        .filter(addr => addr.startsWith('keeta_'));
                    
                    const textarea = document.getElementById('whitelistAddresses');
                    if (textarea) {
                        textarea.value = addresses.join('\n');
                        window.updateWhitelistCount();
                        window.showWhitelistStatus(`Imported ${addresses.length} addresses from CSV`, 'success');
                    }
                } catch (error) {
                    window.showWhitelistStatus('Failed to import CSV: ' + error.message, 'error');
                }
            };
            
            input.click();
        };
        
        window.getWhitelistAddresses = () => {
            const enabled = document.getElementById('enableWhitelist')?.checked || false;
            if (!enabled) return [];
            
            const textarea = document.getElementById('whitelistAddresses');
            if (!textarea) return [];
            
            return textarea.value.split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr.startsWith('keeta_') && addr.length > 20);
        };
        window.prepWipe = () => { document.getElementById('wipeStage1')?.classList.add('hidden'); document.getElementById('wipeStage2')?.classList.remove('hidden'); };
        window.resetWipe = () => { document.getElementById('wipeStage1')?.classList.remove('hidden'); document.getElementById('wipeStage2')?.classList.add('hidden'); };

        window.clearAllNFTs = async () => {
            if (!confirm("WARNING: Delete ALL NFTs, Collections, Traits? Continue?")) return;
            try {
                const nftsRef = collection(db, 'nfts');
                const nftsSnap = await getDocs(nftsRef);
                for (const document of nftsSnap.docs) await deleteDoc(document.ref);
                
                const colRef = collection(db, 'collections');
                const colSnap = await getDocs(colRef);
                for (const document of colSnap.docs) await deleteDoc(document.ref);
                
                const traitRef = collection(db, 'traitCounts');
                const traitSnap = await getDocs(traitRef);
                for (const document of traitSnap.docs) await deleteDoc(document.ref);
                
                const trackRef = collection(db, 'walletMintTracking');
                const trackSnap = await getDocs(trackRef);
                for (const document of trackSnap.docs) await deleteDoc(document.ref);
                
                const total = nftsSnap.docs.length + colSnap.docs.length + traitSnap.docs.length + trackSnap.docs.length;
                window.notify(`Purged ${total} records`, "success");
                
                await window.loadNFTsFromFirebase();
                await window.loadCollections();
                await window.loadTraitCounts();
                
                // Start auto-sync for wallet changes
                window.startAutoSync();
                window.resetWipe();
            } catch (error) {
                console.error("Wipe error:", error);
                window.notify("Purge failed: " + error.message, "error");
            }
        };

        async function initializeEscrowWallet() {
            try {
                console.log("üîê Initializing escrow wallet...");
                const hex = await KeetaNet.lib.Account.seedFromPassphrase(ESCROW_SEED, { asString: true });
                state.escrowAccount = KeetaNet.lib.Account.fromSeed(hex, 0);
                state.escrowAddress = state.escrowAccount.publicKeyString.get();
                state.escrowClient = KeetaNet.UserClient.fromNetwork('test', state.escrowAccount);
                if (typeof state.escrowClient.init === 'function') await state.escrowClient.init();
                console.log("‚úÖ Escrow wallet ready:", state.escrowAddress);
                return true;
            } catch (error) {
                console.error("‚ùå Escrow initialization failed:", error);
                return false;
            }
        }

        async function initializeMarketplace() {
            console.log("üöÄ Initializing PunkSwap Marketplace...");
            
            // Initialize Firebase first
            const firebaseOk = await testFirebaseConnection();
            if (firebaseOk) {
                state.firebaseReady = true;
                
                // Load data in parallel for speed
                await Promise.all([
                    window.loadNFTsFromFirebase(),
                    window.loadCollections(),
                    window.loadTraitCounts()
                ]);
                
                // Recalculate trait counts for all collections to ensure rarity is accurate
                console.log("üîÑ Calculating trait counts for all collections...");
                for (const collection of state.collections) {
                    try {
                        await window.calculateAndSaveTraitCounts(collection.collectionToken || collection.collectionId);
                    } catch (e) {
                        console.warn(`‚ö†Ô∏è Failed to calculate traits for ${collection.collectionTitle}:`, e);
                    }
                }
                await window.loadTraitCounts();
                console.log("‚úÖ All trait counts loaded");
                
                // Setup listeners
                window.setupNFTListener();
                
                // Initialize activity feed
                window.initActivityFeed();
            }
            
            // Initialize escrow
            await initializeEscrowWallet();
            
            // Switch to market tab
            window.switchTab('market');
            
            // CRITICAL FIX: Force chart initialization immediately
            console.log("üìä Initializing market chart...");
            
            // Populate collection selector first
            window.populateChartSelector();
            
            // Initialize the chart RIGHT NOW (no delay)
            await window.initFloorPulseChart();
            
            // Start real-time updates
            window.startChartAutoUpdate();
            
            console.log("‚úÖ PunkSwap fully initialized with charts active");
        };

        // FIX #4: Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Verify critical functions are defined
            const criticalFunctions = ['initNeuralLink', 'importWallet', 'mintFromCollection', 'buyNFT'];
            criticalFunctions.forEach(funcName => {
                if (typeof window[funcName] !== 'function') {
                    console.error(`‚ùå Critical function missing: ${funcName}`);
                } else {
                    console.log(`‚úÖ Function verified: ${funcName}`);
                }
            });
            
            const priceInput = document.getElementById('listingPriceInput');
            if (priceInput) priceInput.addEventListener('input', window.updateFeeBreakdown);
            const currencyInputs = document.querySelectorAll('input[name="listingCurrency"]');
            currencyInputs.forEach(input => input.addEventListener('change', window.updateFeeBreakdown));
            
            // FIX #6: ULTRA-SAFE Auto-restore - Wait for KeetaNet AND strict validation
            setTimeout(async () => {
                try {
                    // CRITICAL: Wait for KeetaNet library to load first
                    let attempts = 0;
                    while (typeof KeetaNet === 'undefined' && attempts < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    if (typeof KeetaNet === 'undefined') {
                        console.error("‚ùå KeetaNet library failed to load");
                        return;
                    }
                    
                    console.log("‚úÖ KeetaNet library loaded");
                    
                    const savedSeed = (localStorage.getItem('punkswap_wallet_seed') || '').trim();
                    
                    // If no seed saved, skip silently
                    if (!savedSeed) {
                        console.log("‚ÑπÔ∏è No saved wallet session found");
                        return;
                    }
                    
                    // LENIENT VALIDATION - Only block obvious junk
                    const words = savedSeed.split(/\s+/).filter(w => {
                        if (!w || w.length < 2) return false; // Too short
                        if (/^https?:\/\//.test(w)) return false; // URL
                        if (/^keeta_/.test(w)) return false; // Keeta address
                        if (/^\d+$/.test(w)) return false; // Pure numbers
                        return true; // Accept everything else
                    });
                    
                    // DEBUG: Log what's happening
                    console.log("üîç DEBUG - Seed validation:");
                    console.log("- Raw input length:", savedSeed.length);
                    console.log("- Split words count:", savedSeed.split(/\s+/).length);
                    console.log("- Filtered words count:", words.length);
                    console.log("- First 3 words:", words.slice(0, 3));
                    console.log("- Last 3 words:", words.slice(-3));
                    
                    // Validate word count
                    if (words.length !== 12 && words.length !== 24) {
                        console.warn(`‚ö†Ô∏è Stored seed invalid (${words.length} words), clearing`);
                        localStorage.removeItem('punkswap_wallet_seed');
                        return;
                    }
                    
                    console.log(`üîÑ Restoring wallet from session (${words.length} words)...`);
                    
                    // VALIDATE BEFORE IMPORTING - Try to create account first
                    try {
                        const testPassphrase = words.join(' ');
                        const testHex = await KeetaNet.lib.Account.seedFromPassphrase(testPassphrase, { asString: true });
                        const testAccount = KeetaNet.lib.Account.fromSeed(testHex, 0);
                        console.log("‚úÖ Seed validation passed");
                    } catch (validationError) {
                        console.error("‚ùå Seed validation failed:", validationError.message);
                        localStorage.removeItem('punkswap_wallet_seed');
                        return;
                    }
                    
                    // Fill seed boxes
                    const seedBoxes = document.querySelectorAll('.seed-box');
                    words.forEach((word, i) => { 
                        if (seedBoxes[i]) seedBoxes[i].value = word; 
                    });
                    
                    // Import wallet
                    await window.importWallet();
                    console.log("‚úÖ Wallet restored from session");
                    
                } catch (error) {
                    console.error("‚ùå Wallet restoration failed:", error);
                    
                    // Clear corrupted data
                    try {
                        localStorage.removeItem('punkswap_wallet_seed');
                        document.querySelectorAll('.seed-box').forEach(box => {
                            if (box) box.value = '';
                        });
                    } catch (e) {
                        console.error("Cleanup error:", e);
                    }
                }
            }, 2000); // Increased to 2 seconds
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AIRDROP ADMIN FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // State for airdrop
        let airdropState = {
            selectedCollection: null,
            airdropHistory: [],
            unlocked: false,
            passcode: "KEEPUNKS2026" // Change this passcode as needed
        };

        // Verify airdrop passcode
        window.verifyAirdropPasscode = () => {
            const input = document.getElementById('airdropPasscodeInput');
            const error = document.getElementById('airdropPasscodeError');
            const gate = document.getElementById('airdropPasscodeGate');
            const content = document.getElementById('airdropContent');
            
            if (input.value === airdropState.passcode) {
                airdropState.unlocked = true;
                gate.classList.add('hidden');
                content.classList.remove('hidden');
                window.notify("‚úÖ Airdrop unlocked", "success");
                window.loadAirdropCollections();
            } else {
                error.textContent = "‚ùå Incorrect passcode";
                error.classList.remove('hidden');
                input.value = '';
                input.focus();
                setTimeout(() => {
                    error.classList.add('hidden');
                }, 3000);
            }
        };

        // Load user's collections for airdrop
        window.loadAirdropCollections = async () => {
            if (!state.address) return;
            
            const select = document.getElementById('airdropCollectionSelect');
            if (!select) return;
            
            // Clear existing options except first
            select.innerHTML = '<option value="">-- Select a collection --</option>';
            
            // Filter collections created by current user AND not blind mint
            const userCollections = state.collections.filter(c => 
                c.creator === state.address && !c.blindMintEnabled
            );
            
            if (userCollections.length === 0) {
                select.innerHTML += '<option value="" disabled>No non-blind-mint collections available</option>';
                console.log("‚ö†Ô∏è No airdrop-eligible collections (all are blind mint)");
                return;
            }
            
            userCollections.forEach(collection => {
                const option = document.createElement('option');
                option.value = collection.collectionId;
                option.textContent = `${collection.collectionTitle} (${collection.remainingSupply}/${collection.totalSupply} remaining)`;
                select.appendChild(option);
            });
            
            console.log(`üìã Loaded ${userCollections.length} airdrop-eligible collections (blind mints excluded)`);
        };

        // Load selected collection details
        window.loadAirdropCollection = async () => {
            const select = document.getElementById('airdropCollectionSelect');
            const collectionId = select.value;
            
            if (!collectionId) {
                document.getElementById('airdropCollectionInfo')?.classList.add('hidden');
                document.getElementById('airdropOptionsSection')?.classList.add('hidden');
                return;
            }
            
            const collection = state.collections.find(c => c.collectionId === collectionId);
            if (!collection) return;
            
            // Check if user is creator
            if (collection.creator !== state.address) {
                window.notify("You can only airdrop from collections you created", "error");
                select.value = "";
                return;
            }
            
            // CRITICAL: Block airdrop for blind mint collections
            if (collection.blindMintEnabled) {
                window.notify("‚ö†Ô∏è Airdrop disabled for blind mint collections. Blind mints are for public minting only.", "error");
                select.value = "";
                document.getElementById('airdropCollectionInfo')?.classList.add('hidden');
                document.getElementById('airdropOptionsSection')?.classList.add('hidden');
                return;
            }
            
            airdropState.selectedCollection = collection;
            
            // Update UI
            document.getElementById('airdropCollectionName').textContent = collection.collectionTitle;
            document.getElementById('airdropMintedCount').textContent = collection.mintedCount;
            document.getElementById('airdropTotalSupply').textContent = collection.totalSupply;
            document.getElementById('airdropRemainingSupply').textContent = collection.remainingSupply;
            document.getElementById('airdropCreatorAddress').textContent = collection.creator.substring(0, 20) + '...';
            
            document.getElementById('airdropCollectionInfo')?.classList.remove('hidden');
            document.getElementById('airdropOptionsSection')?.classList.remove('hidden');
            
            // Set max for specific NFT input (user-friendly: 1 to totalSupply)
            const nftInput = document.getElementById('airdropNFTNumber');
            if (nftInput) {
                nftInput.max = collection.totalSupply; // User enters 1-256, not 0-255
                nftInput.min = 1;
            }
            
            // Update single NFT help text
            const singleHelp = document.getElementById('singleNFTHelp');
            if (singleHelp) {
                singleHelp.innerHTML = `Enter the NFT number: 1-${collection.totalSupply}<br>NFT #1 = 001.json, NFT #2 = 002.json, etc.`;
            }
            
            // Update batch NFT range display
            const rangeDisplay = document.getElementById('batchNFTRange');
            if (rangeDisplay) {
                rangeDisplay.textContent = `(1-${collection.totalSupply})`;
            }
            
            console.log(`‚úÖ Loaded collection for airdrop:`, collection.collectionTitle);
        };

        // Toggle specific NFT input
        window.toggleAirdropNFTInput = () => {
            const mode = document.getElementById('airdropNFTMode').value;
            const specificDiv = document.getElementById('airdropSpecificNFT');
            
            if (mode === 'specific') {
                specificDiv?.classList.remove('hidden');
            } else {
                specificDiv?.classList.add('hidden');
            }
        };

        // Execute single airdrop
        window.executeSingleAirdrop = async () => {
            if (!airdropState.selectedCollection) {
                return window.notify("Please select a collection first", "error");
            }
            
            const collection = airdropState.selectedCollection;
            const recipient = document.getElementById('airdropRecipient').value.trim();
            const nftNumberInput = document.getElementById('airdropNFTNumber').value.trim();
            
            // Validate recipient
            if (!recipient || !recipient.startsWith('keeta_')) {
                return window.notify("Please enter a valid wallet address", "error");
            }
            
            // Validate NFT number
            if (!nftNumberInput || nftNumberInput === '') {
                return window.notify("Please enter the NFT number to send (1-256)", "error");
            }
            
            const userNftNumber = parseInt(nftNumberInput);
            if (isNaN(userNftNumber) || userNftNumber < 1 || userNftNumber > collection.totalSupply) {
                return window.notify(`Invalid NFT number. Must be 1-${collection.totalSupply}`, "error");
            }
            
            // Convert user-friendly number (1-256) to internal index (0-255)
            const nftIndex = userNftNumber - 1;
            
            // Check supply
            if (collection.remainingSupply <= 0) {
                return window.notify("Collection sold out - no NFTs remaining", "error");
            }
            
            const mintIndex = nftIndex;
            
            console.log(`üéÅ Airdrop: User entered NFT #${userNftNumber}, internal index: ${nftIndex}`);
            
            window.notify("Processing airdrop...", "info");
            
            try {
                // Use atomic increment
                const collectionRef = doc(db, 'collections', collection.collectionId);
                
                await updateDoc(collectionRef, {
                    mintedCount: increment(1),
                    remainingSupply: increment(-1)
                });
                
                // Re-fetch collection
                const updatedCollectionSnap = await getDoc(collectionRef);
                const updatedCollection = updatedCollectionSnap.data();
                const actualMintIndex = updatedCollection.mintedCount - 1;
                
                console.log(`üéÅ Airdrop mint index: ${actualMintIndex}`);
                
                // Get filename from shuffled list
                let fileName = null;
                if (updatedCollection.scannedFiles && updatedCollection.scannedFiles[actualMintIndex]) {
                    fileName = updatedCollection.scannedFiles[actualMintIndex];
                } else {
                    fileName = `${String(actualMintIndex + 1).padStart(3, '0')}.json`;
                }
                
                console.log(`üìù Airdrop filename: ${fileName}`);
                
                // Fetch metadata
                const gateways = ['https://ipfs.io/ipfs', 'https://gateway.pinata.cloud/ipfs'];
                let meta = null;
                
                for (const gateway of gateways) {
                    try {
                        const res = await fetch(`${gateway}/${collection.ipfsCid}/${fileName}`);
                        if (res.ok) {
                            meta = await res.json();
                            break;
                        }
                    } catch (e) {
                        console.warn(`Gateway ${gateway} failed`);
                    }
                }
                
                if (!meta) {
                    throw new Error("Failed to fetch NFT metadata");
                }
                
                // Create NFT token on blockchain
                if (!state.escrowClient) {
                    throw new Error("Escrow client not initialized");
                }
                
                const nftBuilder = state.escrowClient.initBuilder();
                nftBuilder.updateAccounts({ signer: state.escrowAccount, account: state.escrowAccount });
                const nftID = nftBuilder.generateIdentifier(KeetaNet.lib.Account.AccountKeyAlgorithm.TOKEN);
                await state.escrowClient.computeBuilderBlocks(nftBuilder);
                
                // FIX #8: Add NFT metadata to airdrop token
                const airdropNftMetadata = {
                    name: meta?.name || `${collection.collectionTitle} #${nftNumber}`,
                    description: meta?.description || `Airdrop NFT from ${collection.collectionTitle} collection`,
                    image: meta?.image || `ipfs://${collection.ipfsCid}/images/${String(nftNumber).padStart(3, '0')}.png`,
                    collection: collection.collectionTitle,
                    tokenType: "NFT",
                    standard: "KeeTa-NFT",
                    airdropped: true,
                    airdropDate: new Date().toISOString(),
                    attributes: meta?.attributes || []
                };
                
                nftBuilder.modifyTokenSupply(1n, { 
                    account: nftID.account,
                    metadata: JSON.stringify(airdropNftMetadata)
                });
                await state.escrowClient.publishBuilder(nftBuilder);
                const nftAddr = nftID.account.publicKeyString.get();
                
                console.log(`‚úÖ NFT token created: ${nftAddr.substring(0, 20)}...`);
                
                // Transfer NFT to recipient
                const transferBuilder = state.escrowClient.initBuilder();
                transferBuilder.updateAccounts({ signer: state.escrowAccount, account: state.escrowAccount });
                transferBuilder.send(
                    KeetaNet.lib.Account.fromPublicKeyString(recipient),
                    1n,
                    KeetaNet.lib.Account.fromPublicKeyString(nftAddr)
                );
                
                await state.escrowClient.computeBuilderBlocks(transferBuilder);
                const transferTx = await state.escrowClient.publishBuilder(transferBuilder);
                
                console.log(`‚úÖ NFT transferred to recipient`);
                
                // Extract transaction hash
                let txHash = null;
                try {
                    const txJson = JSON.stringify(transferTx);
                    const hashMatch = txJson.match(/"(\$hash|hash)":\s*"([A-F0-9]{64})"/);
                    if (hashMatch) {
                        txHash = hashMatch[2];
                    }
                } catch (e) {
                    console.warn("Could not extract tx hash");
                }
                
                // Resolve image path
                function resolveImagePath(imageField, collectionCid) {
                    if (!imageField) return `${collectionCid}/images/001.png`;
                    let imagePath = imageField.replace(/^ipfs:\/\//, '').replace(/{{COLLECTION_CID}}|{{CID}}/g, collectionCid);
                    const hasCid = imagePath.match(/^(bafybei[a-z0-9]{52}|Qm[a-zA-Z0-9]{44})/);
                    if (hasCid) return imagePath;
                    if (imagePath.match(/^images?\//i)) return `${collectionCid}/${imagePath}`;
                    if (imagePath.match(/^\d+\.png$/i)) return `${collectionCid}/images/${imagePath}`;
                    if (imagePath.includes('/')) return `${collectionCid}/${imagePath}`;
                    return `${collectionCid}/images/${imagePath}`;
                }
                
                const finalImagePath = resolveImagePath(meta.image, collection.ipfsCid);
                
                // Save to Firebase
                const docId = `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                await setDoc(doc(db, 'nfts', docId), {
                    id: docId,
                    tokenId: nftAddr,
                    name: meta.name || `${collection.collectionTitle} #${actualMintIndex + 1}`,
                    imageCid: finalImagePath,
                    status: 'minted',
                    owner: recipient,
                    collection: collection.collectionTitle,
                    collectionId: collection.collectionId,
                    collectionType: collection.collectionType,
                    collectionToken: collection.collectionToken,
                    collectionThumbnailCid: collection.collectionThumbnailCid,
                    mintedAt: new Date().toISOString(),
                    wasBlindMinted: collection.blindMintEnabled || false,
                    wasAirdropped: true,
                    airdropedBy: state.address,
                    attributes: meta.attributes || [],
                    description: meta.description || '',
                    externalUrl: meta.external_url || ''
                });
                
                // Record airdrop transaction
                await window.recordTransaction({
                    type: 'airdrop',
                    nftId: docId,
                    nftName: meta.name || `${collection.collectionTitle} #${actualMintIndex + 1}`,
                    collection: collection.collectionTitle,
                    collectionId: collection.collectionId,
                    price: 0,
                    currency: 'KTA',
                    buyer: recipient,
                    seller: state.address,
                    counterParty: recipient,
                    txHash: txHash,
                    airdrop: true
                });
                
                // Add to history
                airdropState.airdropHistory.unshift({
                    recipient,
                    nftName: meta.name,
                    timestamp: new Date().toISOString(),
                    txHash
                });
                
                window.notify(`‚úÖ NFT airdropped to ${recipient.substring(0, 20)}...`, "success");
                
                // Clear inputs
                document.getElementById('airdropRecipient').value = '';
                document.getElementById('airdropNFTNumber').value = '';
                
                // Reload collection
                await window.loadAirdropCollection();
                window.renderAirdropHistory();
                
            } catch (error) {
                console.error("Airdrop error:", error);
                window.notify(`Airdrop failed: ${error.message}`, "error");
            }
        };

        // Validate airdrop addresses
        window.validateAirdropAddresses = () => {
            const textarea = document.getElementById('batchAirdropAddresses');
            const lines = textarea.value.split('\n').map(l => l.trim()).filter(l => l);
            
            const valid = [];
            const invalid = [];
            
            lines.forEach(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length !== 2) {
                    invalid.push({ line, reason: 'Must have wallet,nft_number format' });
                    return;
                }
                
                const [wallet, nftNum] = parts;
                
                if (!wallet.startsWith('keeta_')) {
                    invalid.push({ line, reason: 'Invalid wallet address' });
                    return;
                }
                
                const num = parseInt(nftNum);
                if (isNaN(num) || num < 1) {
                    invalid.push({ line, reason: 'Invalid NFT number (must be 1 or higher)' });
                    return;
                }
                
                // Convert user number (1-256) to internal index (0-255)
                valid.push({ wallet, nftNumber: num, nftIndex: num - 1 });
            });
            
            const status = document.getElementById('batchAirdropStatus');
            status.classList.remove('hidden');
            
            if (invalid.length > 0) {
                status.className = 'p-4 rounded-lg border border-red-500/30 bg-red-500/10';
                status.innerHTML = `
                    <p class="text-red-400 text-sm font-bold">‚ùå ${invalid.length} invalid line(s)</p>
                    <p class="text-xs text-gray-400 mt-1">Format: wallet_address, nft_number (1-256)</p>
                    <p class="text-xs text-gray-500 mt-1">${invalid[0]?.reason || ''}</p>
                `;
            } else {
                status.className = 'p-4 rounded-lg border border-green-500/30 bg-green-500/10';
                status.innerHTML = `
                    <p class="text-green-400 text-sm font-bold">‚úÖ ${valid.length} valid assignment(s)</p>
                    <p class="text-xs text-gray-400 mt-1">Ready to airdrop</p>
                `;
            }
            
            document.getElementById('batchAirdropCount').textContent = valid.length;
        };

        // Import CSV for batch airdrop
        window.importAirdropCSV = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv,.txt';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    document.getElementById('batchAirdropAddresses').value = event.target.result;
                    window.validateAirdropAddresses();
                    window.notify(`CSV imported`, "success");
                };
                reader.readAsText(file);
            };
            input.click();
        };

        // Execute batch airdrop
        window.executeBatchAirdrop = async () => {
            if (!airdropState.selectedCollection) {
                return window.notify("Please select a collection first", "error");
            }
            
            const collection = airdropState.selectedCollection;
            const textarea = document.getElementById('batchAirdropAddresses');
            const lines = textarea.value.split('\n').map(l => l.trim()).filter(l => l);
            
            const assignments = [];
            lines.forEach(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length === 2 && parts[0].startsWith('keeta_')) {
                    const num = parseInt(parts[1]);
                    if (!isNaN(num) && num >= 1) {
                        assignments.push({ 
                            wallet: parts[0], 
                            nftNumber: num,           // User-friendly (1-256)
                            nftIndex: num - 1         // Internal (0-255)
                        });
                    }
                }
            });
            
            if (assignments.length === 0) {
                return window.notify("Please enter valid wallet,nft_number pairs", "error");
            }
            
            if (assignments.length > collection.remainingSupply) {
                return window.notify(`Not enough NFTs remaining. Have: ${collection.remainingSupply}, Need: ${assignments.length}`, "error");
            }
            
            const confirmed = confirm(`Airdrop ${assignments.length} NFTs to ${assignments.length} owners?\n\nThis cannot be undone.`);
            if (!confirmed) return;
            
            window.notify(`Processing batch airdrop of ${assignments.length} NFTs...`, "info");
            
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < assignments.length; i++) {
                const { wallet, nftNumber, nftIndex } = assignments[i];
                
                // Update UI - show user-friendly number
                window.notify(`Airdropping ${i + 1}/${assignments.length}... (NFT #${nftNumber} ‚Üí ${wallet.substring(0, 20)}...)`, "info");
                
                try {
                    // Set values using user-friendly number
                    document.getElementById('airdropRecipient').value = wallet;
                    document.getElementById('airdropNFTNumber').value = nftNumber;
                    
                    await window.executeSingleAirdrop();
                    successCount++;
                    
                    // Small delay to prevent rate limiting
                    await new Promise(r => setTimeout(r, 1500));
                    
                } catch (error) {
                    console.error(`Failed to airdrop NFT #${nftNumber} to ${wallet}:`, error);
                    failCount++;
                }
            }
            
            window.notify(`‚úÖ Batch complete: ${successCount} successful, ${failCount} failed`, "success");
            
            // Clear textarea
            textarea.value = '';
            document.getElementById('batchAirdropCount').textContent = '0';
        };

        // Render airdrop history
        window.renderAirdropHistory = () => {
            const list = document.getElementById('airdropHistoryList');
            if (!list) return;
            
            if (airdropState.airdropHistory.length === 0) {
                list.innerHTML = '<p class="text-sm text-gray-500 text-center py-8">No airdrops yet</p>';
                return;
            }
            
            list.innerHTML = airdropState.airdropHistory.slice(0, 10).map(drop => `
                <div class="p-3 bg-black/40 border border-green-500/20 rounded-lg flex justify-between items-center">
                    <div>
                        <p class="text-sm text-white font-bold">${drop.nftName}</p>
                        <p class="text-xs text-gray-500 font-mono">${drop.recipient.substring(0, 30)}...</p>
                    </div>
                    <div class="text-right">
                        <p class="text-xs text-green-400">${new Date(drop.timestamp).toLocaleString()}</p>
                        ${drop.txHash ? `<p class="text-xs text-gray-500 font-mono">${drop.txHash.substring(0, 12)}...</p>` : ''}
                    </div>
                </div>
            `).join('');
        };

        // Show airdrop tab always (for testing; was: only when user is a creator)
        window.updateAirdropVisibility = () => {
            const nav = document.getElementById('nav-airdrop');
            nav?.classList.remove('hidden');
        };

        // ============================================
        // KEETA MINT PIPELINE - PRODUCTION GRADE
        // ============================================
        //
        // FAILURE MODE ANALYSIS:
        // STEP 1 FAIL (Validation)     ‚Üí Abort immediately, no blockchain interaction
        // STEP 2 FAIL (Metadata)       ‚Üí Abort, no token created, no payment
        // STEP 3 FAIL (Token Creation) ‚Üí No payment made, user can retry
        // STEP 4 FAIL (Payment)        ‚Üí Token exists but mint incomplete; user has orphan token
        // STEP 5 FAIL (Firebase)       ‚Üí NFT on chain, owned by user, but not in UI; needs reconciliation
        //
        // Usage: const pipeline = window.createKeetaMintPipeline();
        //        const result = await pipeline.executeMint({
        //          collectionId: '...',
        //          userWallet: state.address,
        //          userClient: state.keetaClient,
        //          userAccount: state.keetaAccount  // Optional if userClient has .account
        //        });
        //

        window.KeetaMintPipeline = class KeetaMintPipeline {
            constructor(firestoreDb, appId) {
                this.db = firestoreDb;
                this.appId = appId || state.appId;
            }

            async getCollection(collectionId) {
                const ref = doc(this.db, 'artifacts', this.appId, 'public', 'data', 'collections', collectionId);
                const snap = await getDoc(ref);
                if (!snap.exists()) return null;
                return { id: snap.id, ...snap.data() };
            }

            async getUserMintCount(collectionId, userWallet) {
                const ref = doc(this.db, 'artifacts', this.appId, 'public', 'data', 'walletMintTracking', `${userWallet}_${collectionId}`);
                const snap = await getDoc(ref);
                return snap.exists() ? (snap.data().mintedCount || 0) : 0;
            }

            async checkWhitelist(collectionId, userWallet) {
                const walletsRef = collection(this.db, 'artifacts', this.appId, 'public', 'data', 'whitelistWallets');
                const q = query(walletsRef, where('collectionId', '==', collectionId), where('walletAddress', '==', userWallet));
                const snap = await getDocs(q);
                if (snap.empty) return false;
                const entry = snap.docs[0].data();
                return (entry.usedMints || 0) < (entry.maxMints || 1);
            }

            async getKTABalance(walletAddress) {
                try {
                    const bal = await KeetaNet.lib.rpc.balance(walletAddress);
                    const kta = bal?.find(b => b.token?.$type === 'KTA' || b.token?.publicKeyString);
                    return kta ? Number(kta.amount || 0n) / KTA_DECIMALS : 0;
                } catch (e) {
                    return 0;
                }
            }

            async getAndIncrementMintIndex(collectionId) {
                const collectionRef = doc(this.db, 'artifacts', this.appId, 'public', 'data', 'collections', collectionId);
                
                // Get current state
                const beforeSnap = await getDoc(collectionRef);
                const beforeCount = beforeSnap.data().mintedCount || 0;
                console.log(`üìà BEFORE increment: mintedCount=${beforeCount}, remainingSupply=${beforeSnap.data().remainingSupply}`);
                
                // Increment
                await updateDoc(collectionRef, { mintedCount: increment(1), remainingSupply: increment(-1) });
                
                // Get new state
                const afterSnap = await getDoc(collectionRef);
                const afterCount = afterSnap.data().mintedCount || 0;
                console.log(`üìà AFTER increment: mintedCount=${afterCount}, remainingSupply=${afterSnap.data().remainingSupply}`);
                
                const mintIndex = afterCount - 1;
                console.log(`üéØ Mint will use index: ${mintIndex}`);
                
                return mintIndex;
            }

            extractHashFromTx(tx) {
                try {
                    // Primary: voteStaple blocks
                    const h0 = tx?.voteStaple?.blocks?.[0]?.$hash;
                    if (h0) return h0;
                    const h1 = tx?.voteStaple?.blocks?.[1]?.$hash;
                    if (h1) return h1;
                    // Fallback: any block in array
                    const blocks = tx?.voteStaple?.blocks;
                    if (Array.isArray(blocks)) {
                        for (const b of blocks) {
                            const h = b?.$hash;
                            if (h) return h;
                        }
                    }
                    // Fallback: stringify and regex for hex hash
                    if (tx) {
                        const str = JSON.stringify(tx, (k, v) => typeof v === 'bigint' ? v.toString() : v);
                        const match = str.match(/"(\$hash|hash)":\s*"([A-Fa-f0-9]{64})"/);
                        if (match) return match[2];
                        const alt = str.match(/([A-Fa-f0-9]{64})/);
                        if (alt) return alt[1];
                    }
                    return null;
                } catch (e) {
                    return null;
                }
            }

            async validateMintRequest(req) {
                console.log("üîç [STEP 1] Validating mint request...");
                console.log("üìã Request details:", {
                    collectionId: req.collectionId,
                    userWallet: req.userWallet,
                    stateBalance: state.balanceKTA
                });
                
                const collection = await this.getCollection(req.collectionId);
                if (!collection) {
                    console.error("‚ùå Collection not found:", req.collectionId);
                    return { valid: false, error: "Collection not found" };
                }
                
                console.log("‚úÖ Collection found:", collection.collectionTitle);
                const totalSupply = (collection.mintedCount || 0) + (collection.remainingSupply || 0);
                if ((collection.mintedCount || 0) >= totalSupply) return { valid: false, error: "Collection sold out" };
                const userMintCount = await this.getUserMintCount(req.collectionId, req.userWallet);
                const maxPer = collection.maxMintsPerWallet ?? 10;
                if (userMintCount >= maxPer) return { valid: false, error: `Max ${maxPer} mints per wallet` };
                if (typeof window.loadWhitelistSettings === 'function' && !state.whitelistSettings?.[req.collectionId]) {
                    await window.loadWhitelistSettings(req.collectionId);
                }
                const ws = state.whitelistSettings?.[req.collectionId];
                if (ws?.enabled) {
                    const mintType = collection.blindMintEnabled ? 'BLIND_MINT' : 'STANDARD_MINT';
                    if (ws.mode && ws.mode !== 'BOTH' && ws.mode !== mintType) return { valid: false, error: "Whitelist not active for this mint type" };
                    const now = Date.now();
                    if (ws.mintWindowStart && now < new Date(ws.mintWindowStart).getTime()) return { valid: false, error: "Mint window not open yet" };
                    if (ws.mintWindowEnd && now > new Date(ws.mintWindowEnd).getTime()) return { valid: false, error: "Mint window closed" };
                    const isWhitelisted = await this.checkWhitelist(req.collectionId, req.userWallet);
                    if (!isWhitelisted) return { valid: false, error: "Not whitelisted" };
                }
                // FIX: Use state.balanceKTA which is already synced and accurate
                const balance = state.balanceKTA || 0;
                const price = collection.priceKTA || 0;

                console.log(`üí∞ Balance check: Have ${balance} KTA, Need ${price} KTA`);

                if (balance < price) {
                    console.error(`‚ùå Insufficient balance: ${balance} < ${price}`);
                    return { valid: false, error: `Insufficient KTA (need ${price}, have ${balance.toFixed(2)})` };
                }

                console.log(`‚úÖ Balance sufficient: ${balance} >= ${price}`);
                console.log("‚úÖ [STEP 1] ALL VALIDATION CHECKS PASSED");
                console.log("üìã Validation summary:", {
                    collection: collection.collectionTitle,
                    supply: `${collection.mintedCount}/${collection.totalSupply}`,
                    userMints: `${userMintCount}/${maxPer}`,
                    balance: `${balance.toFixed(2)} KTA`,
                    price: `${price} KTA`,
                    whitelisted: ws?.enabled ? 'Yes' : 'No'
                });
                return { valid: true };
            }

            async resolveMetadata(collectionId) {
                console.log("üìÑ [STEP 2] Resolving metadata...");
                const collection = await this.getCollection(collectionId);
                const mintIndex = await this.getAndIncrementMintIndex(collectionId);
                
                console.log(`üìä Collection info:`, {
                    blindMintEnabled: collection.blindMintEnabled,
                    scannedFilesCount: collection.scannedFiles?.length || 0,
                    mintIndex: mintIndex,
                    totalSupply: collection.totalSupply
                });
                
                let filename;
                if (collection.blindMintEnabled && collection.scannedFiles?.length) {
                    filename = collection.scannedFiles[mintIndex] || `${String(mintIndex + 1).padStart(3, '0')}.json`;
                    console.log(`üé≤ Blind mint: Index ${mintIndex} ‚Üí File ${filename}`);
                    console.log(`üìÅ ScannedFiles array has ${collection.scannedFiles.length} files`);
                    
                    // Warn if index is beyond scannedFiles length
                    if (mintIndex >= collection.scannedFiles.length) {
                        console.warn(`‚ö†Ô∏è WARNING: Mint index ${mintIndex} exceeds scannedFiles length ${collection.scannedFiles.length}`);
                    }
                } else {
                    filename = `${String(mintIndex + 1).padStart(3, '0')}.json`;
                    console.log(`üìù Sequential mint: Index ${mintIndex} ‚Üí File ${filename}`);
                }
                
                const gateways = ['https://ipfs.io/ipfs', 'https://gateway.pinata.cloud/ipfs', 'https://cloudflare-ipfs.com/ipfs'];
                let metadata = null;
                
                // Clean CID and filename to prevent double slashes and remove ipfs:// protocol
                let cleanCid = collection.ipfsCid || '';
                // Remove ipfs:// protocol prefix if present
                if (cleanCid.startsWith('ipfs://')) {
                    cleanCid = cleanCid.replace('ipfs://', '');
                }
                // Remove leading/trailing slashes
                cleanCid = cleanCid.replace(/^\/+|\/+$/g, '');
                const cleanFilename = filename.replace(/^\/+/g, '');
                
                console.log(`üîó Final URL components: CID=${cleanCid.substring(0, 20)}... File=${cleanFilename}`);
                
                for (const gw of gateways) {
                    try {
                        const metaUrl = `${gw}/${cleanCid}/${cleanFilename}`;
                        console.log(`üîç Trying: ${metaUrl}`);
                        const res = await fetch(metaUrl);
                        if (res.ok) { 
                            metadata = await res.json(); 
                            console.log(`‚úÖ Metadata loaded from: ${gw}`);
                            break; 
                        } else {
                            console.warn(`‚ö†Ô∏è Gateway returned ${res.status}: ${gw}`);
                        }
                    } catch (e) { 
                        console.warn(`‚ùå Gateway failed (${e.message}): ${gw}`); 
                        continue; 
                    }
                }
                
                if (!metadata) {
                    console.error(`‚ùå All gateways failed for: ${cleanCid}/${cleanFilename}`);
                    throw new Error(`Metadata fetch failed: ${cleanCid}/${cleanFilename}`);
                }
                
                if (!metadata.name || !metadata.image) throw new Error("Invalid metadata schema: missing name or image");
                let imagePath = metadata.image;
                if (imagePath.startsWith('ipfs://')) imagePath = imagePath.replace('ipfs://', '');
                else if (!imagePath.startsWith('http')) imagePath = `${collection.ipfsCid}/${imagePath}`;
                console.log("‚úÖ [STEP 2] Metadata resolved:", metadata.name);
                return { metadata, imagePath, mintIndex };
            }

            async createNFTToken(req, metadata, collection) {
                console.log("üé® [STEP 3] Creating NFT token with TWO-TRANSACTION pattern...");
                console.log("   NFT Name:", metadata.name);
                console.log("   Collection:", collection.collectionTitle);
                const account = req.userClient?.account || req.userAccount;
                if (!account) throw new Error("userClient.account or userAccount required");
                
                // ========================================
                // TRANSACTION 1: Create Token + Set Permissions
                // ========================================
                console.log("üìù TX 1: Creating token and setting permissions...");
                
                const builder1 = req.userClient.initBuilder();
                builder1.updateAccounts({ signer: account, account });
                
                const nftID = builder1.generateIdentifier(KeetaNet.lib.Account.AccountKeyAlgorithm.TOKEN);
                await req.userClient.computeBuilderBlocks(builder1);
                
                const tokenAccount = nftID.account;
                const tokenId = tokenAccount.publicKeyString.get();
                
                console.log("   Token address:", tokenId);
                
                // Set permissions and mint supply in TX 1
                // Use collection name + symbol for on-chain token info
                // Keeta ONLY allows A-Z and _ (NO NUMBERS!)
                let collectionSymbol = (collection.collectionTitle || 'NFT')
                    .toUpperCase()
                    .replace(/[^A-Z]/g, '_')  // Remove everything except A-Z
                    .replace(/_+/g, '_')       // Replace multiple underscores with single
                    .replace(/^_|_$/g, '')     // Remove leading/trailing underscores
                    .substring(0, 20);
                
                // Keeta requires minimum 6 characters for name field
                console.log("   ‚öôÔ∏è Original collectionSymbol:", collectionSymbol, "Length:", collectionSymbol.length);
                
                if (collectionSymbol.length < 6) {
                    collectionSymbol = collectionSymbol + '_TOKEN';
                    console.log("   ‚öôÔ∏è PADDED collectionSymbol:", collectionSymbol, "Length:", collectionSymbol.length);
                }
                
                // Ensure it's still within 50 char limit
                collectionSymbol = collectionSymbol.substring(0, 50);
                console.log("   ‚öôÔ∏è Final collectionSymbol:", collectionSymbol);
                
                // Ensure symbol also meets minimum length requirement
                let symbolField = collectionSymbol.substring(0, 10);
                if (symbolField.length < 6) {
                    symbolField = collectionSymbol;  // Use full name if symbol too short
                }
                
                builder1.setInfo({
                    name: collectionSymbol,  // e.g., "TEST1_TOKEN"
                    symbol: symbolField,  // Also minimum 6 chars
                    description: metadata.description || collection.collectionTitle,
                    metadata: btoa(JSON.stringify(metadata)),
                    defaultPermission: new KeetaNet.lib.Permissions(['ACCESS'])
                }, { account: tokenAccount });
                
                builder1.modifyTokenSupply(1n, { account: tokenAccount });
                
                console.log("   Publishing TX 1...");
                await req.userClient.publishBuilder(builder1);
                console.log("   ‚úÖ TX 1 complete! Permissions committed to ledger.");
                
                // Wait for confirmation
                console.log("   ‚è≥ Waiting 3 seconds for confirmation...");
                await new Promise(r => setTimeout(r, 3000));
                
                // ========================================
                // TRANSACTION 2: Allocate to User
                // ========================================
                console.log("üìù TX 2: Allocating NFT to user wallet...");
                
                const builder2 = req.userClient.initBuilder();
                builder2.updateAccounts({ signer: account, account });
                
                builder2.send(account, 1n, tokenAccount, undefined, { account: tokenAccount });
                
                console.log("   Publishing TX 2...");
                await req.userClient.publishBuilder(builder2);
                console.log("   ‚úÖ TX 2 complete! NFT allocated to user.");
                
                console.log("‚úÖ [STEP 3] NFT token created with TWO-TRANSACTION pattern:", tokenId);
                return tokenId;
            }

            async executePayment(req, collection) {
                console.log("üí∞ [STEP 4] Processing payment...");
                
                const price = collection.priceKTA || 0;
                
                // Handle FREE mints (0 KTA) - skip payment
                if (price === 0) {
                    console.log("‚úÖ [STEP 4] FREE MINT - No payment required (0 KTA)");
                    return 'free_mint_no_payment';
                }
                
                // Process paid mints
                const account = req.userClient?.account || req.userAccount;
                if (!account) throw new Error("userClient.account or userAccount required");
                
                const paymentBuilder = req.userClient.initBuilder();
                paymentBuilder.updateAccounts({ signer: account, account });
                
                const keetaToken = req.userClient?.baseToken || KeetaNet.lib.Account.fromPublicKeyString('keeta_anyiff4v34alvumupagmdyosydeq24lc4def5mrpmmyhx3j6vj2uucckeqn52');
                
                const creatorShare = price * PRIMARY_SALE_CREATOR_PERCENT;
                const marketplaceShare = price * PRIMARY_SALE_MARKETPLACE_PERCENT;
                
                const creatorAccount = KeetaNet.lib.Account.fromPublicKeyString(collection.creator || collection.creatorWallet);
                paymentBuilder.send(creatorAccount, BigInt(Math.floor(creatorShare * KTA_DECIMALS)), keetaToken);
                
                const marketplaceAccount = KeetaNet.lib.Account.fromPublicKeyString(MARKETPLACE_FEE_WALLET);
                paymentBuilder.send(marketplaceAccount, BigInt(Math.floor(marketplaceShare * KTA_DECIMALS)), keetaToken);
                
                await req.userClient.computeBuilderBlocks(paymentBuilder);
                const paymentTx = await req.userClient.publishBuilder(paymentBuilder);
                const txHash = paymentTx?.voteStaple?.blocks?.[0]?.$hash || this.extractHashFromTx(paymentTx);
                
                console.log("‚úÖ [STEP 4] Payment complete, tx:", txHash);
                return txHash;
            }

            async commitToFirebase(req, tokenId, metadata, imagePath, txHash, mintIndex) {
                console.log("üíæ [STEP 5] Committing to Firebase...");
                console.log("TX Hash being saved:", txHash || "(none)");
                if (!txHash) {
                    console.warn("‚ö†Ô∏è WARNING: Committing NFT without transaction hash");
                    console.warn("This means hash extraction failed earlier in the pipeline");
                }
                const collection = await this.getCollection(req.collectionId);
                const docId = `nft_${getNormalizedId(collection.collectionToken || collection.id)}_${mintIndex}`;
                await setDoc(doc(this.db, 'artifacts', this.appId, 'public', 'data', 'nfts', docId), {
                    id: docId,
                    tokenId,
                    owner: req.userWallet,
                    collectionId: req.collectionId,
                    collectionTitle: collection.collectionTitle || collection.title,
                    collectionName: collection.collectionTitle || collection.title,
                    collection: collection.collectionTitle || collection.title,
                    collectionToken: collection.collectionToken,
                    name: metadata.name,
                    description: metadata.description || '',
                    imageCid: imagePath,
                    imagePath: imagePath,
                    attributes: metadata.attributes || [],
                    mintIndex,
                    mintTxHash: txHash,
                    mintedAt: new Date().toISOString(),
                    status: 'minted',
                    isListed: false,
                    listedPrice: null,
                    listedCurrency: null,
                    inEscrow: false,
                    creator: collection.creator,
                    priceKTA: collection.priceKTA,
                    pricePunks: collection.pricePunks,
                    wasBlindMinted: !!collection.blindMintEnabled,
                    externalUrl: metadata.external_url || ''
                });
                const walletTrackingRef = doc(this.db, 'artifacts', this.appId, 'public', 'data', 'walletMintTracking', `${req.userWallet}_${req.collectionId}`);
                const trackingSnap = await getDoc(walletTrackingRef);
                const currentCount = trackingSnap.exists() ? trackingSnap.data().mintedCount : 0;
                await setDoc(walletTrackingRef, { walletAddress: req.userWallet, collectionId: req.collectionId, mintedCount: currentCount + 1 });
                const ws = state.whitelistSettings?.[req.collectionId];
                if (ws?.enabled) {
                    const wallets = state.whitelistWallets?.[req.collectionId] || [];
                    const entry = wallets.find(w => (w.walletAddress || '').toLowerCase() === req.userWallet.toLowerCase());
                    if (entry) {
                        try {
                            const walletRef = doc(this.db, 'artifacts', this.appId, 'public', 'data', 'whitelistWallets', entry.id);
                            await updateDoc(walletRef, { usedMints: (entry.usedMints || 0) + 1 });
                        } catch (e) { console.warn("Whitelist usage increment failed:", e); }
                    }
                }
                await window.recordTransaction?.({ type: 'mint', nftId: docId, nftName: metadata.name, collection: collection.collectionTitle, collectionId: req.collectionId, counterParty: collection.creator, price: collection.priceKTA, currency: 'KTA', txHash });
                
                // Update trait counts for rarity calculation
                if (metadata.attributes && metadata.attributes.length > 0) {
                    await window.updateTraitCounts(collection.collectionId, metadata.attributes);
                }
                
                // Recalculate collection-wide trait counts for accurate rarity percentages
                setTimeout(async () => {
                    try {
                        await window.calculateAndSaveTraitCounts(collection.collectionToken || collection.collectionId);
                        await window.loadTraitCounts();
                        console.log("‚úÖ Trait counts updated for rarity system");
                    } catch (e) {
                        console.warn("‚ö†Ô∏è Trait count calculation failed:", e);
                    }
                }, 2000);
                
                console.log("‚úÖ [STEP 5] Firebase commit complete");
                
                // DISABLED: Auto-escrow for blind mints
                // NFTs now stay with the user after minting
                // Escrow only used for atomic swaps during purchases
                /*
                if (collection.blindMintEnabled && state.escrowClient && state.escrowAccount && state.escrowAddress && req.userClient) {
                    console.log("üîÑ [STEP 5B] Transferring NFT to escrow for blind mint...");
                    try {
                        const account = req.userClient?.account || req.userAccount;
                        const transferBuilder = req.userClient.initBuilder();
                        transferBuilder.updateAccounts({ signer: account, account });
                        
                        const escrowAccount = KeetaNet.lib.Account.fromPublicKeyString(state.escrowAddress);
                        const nftAccount = KeetaNet.lib.Account.fromPublicKeyString(tokenId);
                        
                        transferBuilder.send(escrowAccount, 1n, nftAccount);
                        await req.userClient.computeBuilderBlocks(transferBuilder);
                        await req.userClient.publishBuilder(transferBuilder);
                        
                        // Update Firebase to show escrow as owner
                        await updateDoc(doc(this.db, 'artifacts', state.appId, 'public', 'data', 'nfts', docId), {
                            owner: state.escrowAddress,
                            inEscrow: true
                        });
                        
                        console.log("‚úÖ [STEP 5B] NFT transferred to escrow");
                    } catch (escrowError) {
                        console.warn("‚ö†Ô∏è Escrow transfer failed:", escrowError);
                        // NFT still exists in user wallet, they can manually transfer or list normally
                    }
                }
                */
                
                return docId;
            }

            async executeMint(req) {
                let mintIndex = null;
                let collectionRef = null;
                
                try {
                    if (typeof req.userClient?.init === 'function') await req.userClient.init();
                    
                    const validation = await this.validateMintRequest(req);
                    if (!validation.valid) return { success: false, error: validation.error };
                    
                    const { metadata, imagePath, mintIndex: resolvedIndex } = await this.resolveMetadata(req.collectionId);
                    mintIndex = resolvedIndex;
                    
                    // Store collection ref for potential rollback
                    collectionRef = doc(this.db, 'artifacts', this.appId, 'public', 'data', 'collections', req.collectionId);
                    
                    const collection = await this.getCollection(req.collectionId);
                    const tokenId = await this.createNFTToken(req, metadata, collection);
                    const txHash = await this.executePayment(req, collection);
                    const nftId = await this.commitToFirebase(req, tokenId, metadata, imagePath, txHash, mintIndex);
                    
                    return { success: true, nftId, tokenId, txHash };
                    
                } catch (error) {
                    console.error("‚ùå Mint pipeline failed:", error);
                    
                    // CRITICAL: Rollback mint index if we got past metadata resolution
                    if (mintIndex !== null && collectionRef) {
                        try {
                            console.log(`üîÑ Rolling back mint index ${mintIndex} due to pipeline failure`);
                            
                            // Check state before rollback
                            const beforeRollback = await getDoc(collectionRef);
                            console.log(`üìâ BEFORE rollback: mintedCount=${beforeRollback.data().mintedCount}, remainingSupply=${beforeRollback.data().remainingSupply}`);
                            
                            await updateDoc(collectionRef, {
                                mintedCount: increment(-1),
                                remainingSupply: increment(1)
                            });
                            
                            // Check state after rollback
                            const afterRollback = await getDoc(collectionRef);
                            console.log(`üìâ AFTER rollback: mintedCount=${afterRollback.data().mintedCount}, remainingSupply=${afterRollback.data().remainingSupply}`);
                            console.log(`‚úÖ Rollback successful - mint cancelled`);
                        } catch (rollbackErr) {
                            console.error("‚ùå Rollback failed:", rollbackErr);
                            // Even worse - supply is now incorrect
                            return { 
                                success: false, 
                                error: `Mint failed AND rollback failed: ${error?.message}. Contact admin.` 
                            };
                        }
                    }
                    
                    return { 
                        success: false, 
                        error: error?.message || String(error),
                        rolled_back: mintIndex !== null 
                    };
                }
            }
        };

        // Expose pipeline factory for use: new KeetaMintPipeline(db, state.appId)
        window.createKeetaMintPipeline = () => new window.KeetaMintPipeline(db, state.appId);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // OFFER SYSTEM - Make and manage offers
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        let offerState = {
            currentNFT: null,
            currentCollection: null,
            isCollectionOffer: false
        };

        window.makeOfferOnNFT = async (nftId) => {
            if (!state.address) {
                return window.notify("Connect wallet first", "error");
            }
            const nft = state.nfts.find(n => n.id === nftId);
            if (!nft) return window.notify("NFT not found", "error");
            if (nft.owner && nft.owner.toLowerCase() === state.address.toLowerCase()) {
                return window.notify("Cannot make offer on your own NFT", "error");
            }
            offerState.currentNFT = nft;
            offerState.isCollectionOffer = false;
            offerState.currentCollection = null;
            const imgPath = window.getNFTImagePath(nft);
            const imgUrl = imgPath ? `https://gateway.pinata.cloud/ipfs/${imgPath}` : '';
            document.getElementById('offerNFTPreview').innerHTML = `<img src="${imgUrl}" class="w-full h-full object-cover rounded-lg">`;
            document.getElementById('offerNFTName').textContent = nft.name || 'Unknown NFT';
            document.getElementById('offerNFTOwner').textContent = nft.owner ? nft.owner.substring(0, 20) + '...' : 'Unknown';
            document.getElementById('offerNFTListed').textContent = nft.isListed ? `${nft.listedPrice} ${nft.listedCurrency}` : 'Not Listed';
            const subEl = document.getElementById('offerModalSubtitle');
            if (subEl) subEl.textContent = 'Propose a price to the NFT owner';
            document.getElementById('offerKTABalance').textContent = (state.balanceKTA || 0).toFixed(2);
            document.getElementById('offerPUNKSBalance').textContent = (state.balancePunks || 0).toLocaleString();
            document.getElementById('offerAmountInput').value = '';
            const ktaRadio = document.querySelector('input[name="offerCurrency"][value="KTA"]');
            if (ktaRadio) ktaRadio.checked = true;
            window.updateOfferSummary();
            document.getElementById('offerModal').classList.remove('hidden');
        };

        window.makeOfferOnCollection = async (colToken) => {
            if (!state.address) return window.notify("Connect wallet first", "error");
            const colNfts = state.nfts.filter(n => getNormalizedId(n.collectionToken) === getNormalizedId(colToken));
            const base = colNfts[0];
            if (!base) return window.notify("Collection not found", "error");
            const listedNfts = colNfts.filter(n => n.isListed);
            const ktaListings = listedNfts.filter(n => n.listedCurrency === 'KTA');
            const punksListings = listedNfts.filter(n => n.listedCurrency === 'PUNKS');
            const floorKTA = ktaListings.length > 0 ? Math.min(...ktaListings.map(n => n.listedPrice)) : null;
            const floorPUNKS = punksListings.length > 0 ? Math.min(...punksListings.map(n => n.listedPrice)) : null;
            const floorText = floorKTA ? `${floorKTA} KTA` : (floorPUNKS ? `${floorPUNKS} PUNKS` : 'N/A');
            offerState.currentNFT = null;
            offerState.currentCollection = {
                collectionId: base.collectionId,
                collectionTitle: base.collection || base.collectionTitle || 'Unknown Collection'
            };
            offerState.isCollectionOffer = true;
            const thumbCid = base.collectionThumbnailCid || window.getNFTImagePath(base);
            const imgUrl = thumbCid ? `https://gateway.pinata.cloud/ipfs/${thumbCid}` : `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23000' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-size='20'%3ECLASSIFIED%3C/text%3E%3C/svg%3E`;
            document.getElementById('offerNFTPreview').innerHTML = `<img src="${imgUrl}" class="w-full h-full object-cover rounded-lg">`;
            document.getElementById('offerNFTName').textContent = offerState.currentCollection.collectionTitle;
            document.getElementById('offerNFTOwner').textContent = `${colNfts.length} items`;
            document.getElementById('offerNFTListed').textContent = `Floor: ${floorText}`;
            const subEl = document.getElementById('offerModalSubtitle');
            if (subEl) subEl.textContent = 'Offer KTA or PUNKS for any NFT in this collection';
            document.getElementById('offerKTABalance').textContent = (state.balanceKTA || 0).toFixed(2);
            document.getElementById('offerPUNKSBalance').textContent = (state.balancePunks || 0).toLocaleString();
            document.getElementById('offerAmountInput').value = '';
            const ktaRadio = document.querySelector('input[name="offerCurrency"][value="KTA"]');
            if (ktaRadio) ktaRadio.checked = true;
            window.updateOfferSummary();
            document.getElementById('offerModal').classList.remove('hidden');
        };

        window.closeOfferModal = () => {
            document.getElementById('offerModal').classList.add('hidden');
            offerState.currentNFT = null;
            offerState.currentCollection = null;
            offerState.isCollectionOffer = false;
        };

        window.updateOfferSummary = () => {
            const amount = parseFloat(document.getElementById('offerAmountInput')?.value || 0);
            const currency = document.querySelector('input[name="offerCurrency"]:checked')?.value || 'KTA';
            if (isNaN(amount) || amount <= 0) {
                document.getElementById('offerTotal').textContent = '0.00 ' + currency;
                return;
            }
            document.getElementById('offerTotal').textContent = `${amount.toFixed(2)} ${currency}`;
        };

        window.submitOffer = async () => {
            if (!state.address) return window.notify("Connect wallet first", "error");
            const amount = parseFloat(document.getElementById('offerAmountInput')?.value || 0);
            const currency = document.querySelector('input[name="offerCurrency"]:checked')?.value || 'KTA';
            if (isNaN(amount) || amount <= 0) return window.notify("Enter valid offer amount", "error");
            if (currency === 'KTA' && (state.balanceKTA || 0) < amount) {
                return window.notify(`Insufficient KTA balance (need ${amount}, have ${(state.balanceKTA || 0).toFixed(2)})`, "error");
            }
            if (currency === 'PUNKS' && (state.balancePunks || 0) < amount) {
                return window.notify(`Insufficient PUNKS balance (need ${amount}, have ${state.balancePunks})`, "error");
            }
            try {
                window.notify("Submitting offer...", "success");
                const offer = {
                    id: `offer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: offerState.isCollectionOffer ? 'collection' : 'nft',
                    offerer: state.address,
                    amount: amount,
                    currency: currency,
                    createdAt: new Date().toISOString(),
                    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                    status: 'active'
                };
                if (offerState.isCollectionOffer && offerState.currentCollection) {
                    offer.collectionId = offerState.currentCollection.collectionId;
                    offer.collectionTitle = offerState.currentCollection.collectionTitle;
                    offer.note = 'Floor offer for any NFT in this collection';
                } else if (offerState.currentNFT) {
                    offer.nftId = offerState.currentNFT.id;
                    offer.nftName = offerState.currentNFT.name;
                    offer.nftOwner = offerState.currentNFT.owner;
                    offer.collectionId = offerState.currentNFT.collectionId;
                    offer.collectionName = offerState.currentNFT.collection || offerState.currentNFT.collectionTitle;
                }
                await setDoc(doc(db, 'offers', offer.id), offer);
                window.notify(`‚úÖ Offer submitted: ${amount} ${currency}`, "success");
                window.closeOfferModal();
                if (typeof window.loadOffers === 'function') await window.loadOffers();
            } catch (error) {
                console.error("Error submitting offer:", error);
                window.notify("Failed to submit offer: " + error.message, "error");
            }
        };

        window.loadOffers = async () => {
            if (!state.address || !db) return;
            try {
                const offersRef = collection(db, 'offers');
                const snapshot = await getDocs(offersRef);
                state.offers = [];
                state.myOffers = [];
                state.offersOnMyNFTs = [];
                snapshot.forEach(d => {
                    const offer = { id: d.id, ...d.data() };
                    if (offer.expiresAt && new Date(offer.expiresAt) < new Date()) return;
                    if (offer.status && offer.status !== 'active') return;
                    state.offers.push(offer);
                    if (offer.offerer && offer.offerer.toLowerCase() === state.address.toLowerCase()) state.myOffers.push(offer);
                    if (offer.type === 'nft') {
                        const nft = state.nfts.find(n => n.id === offer.nftId);
                        if (nft && nft.owner && nft.owner.toLowerCase() === state.address.toLowerCase()) state.offersOnMyNFTs.push(offer);
                    }
                });
                console.log(`‚úÖ Loaded ${state.offers.length} offers (${state.myOffers.length} mine, ${state.offersOnMyNFTs.length} on my NFTs)`);
                if (typeof window.renderOffers === 'function') window.renderOffers();
            } catch (error) {
                console.error("Error loading offers:", error);
            }
        };

        window.renderOffers = () => {
            const onMyList = document.getElementById('offersOnMyNFTsList');
            const myList = document.getElementById('myOffersList');
            if (!onMyList || !myList) return;
            const incoming = state.offersOnMyNFTs || [];
            const outgoing = state.myOffers || [];
            onMyList.innerHTML = incoming.length === 0
                ? '<p class="text-gray-500 fira text-sm py-8 text-center">No offers on your NFTs yet</p>'
                : incoming.map(o => {
                    const nft = state.nfts.find(n => n.id === o.nftId);
                    const imgPath = nft ? window.getNFTImagePath(nft) : '';
                    const imgUrl = imgPath ? `https://gateway.pinata.cloud/ipfs/${imgPath}` : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23333%22/%3E%3C/svg%3E';
                    return `<div class="flex items-center gap-4 p-4 bg-black/40 rounded-lg border border-cyan-500/20">
                        <img src="${imgUrl}" class="w-16 h-16 rounded-lg object-cover">
                        <div class="flex-1 min-w-0">
                            <p class="orbitron text-sm font-bold text-white truncate">${o.nftName || 'NFT'}</p>
                            <p class="fira text-xs text-cyan-400">${o.amount} ${o.currency} from ${(o.offerer || '').substring(0, 16)}...</p>
                        </div>
                        <button onclick="window.acceptOffer('${o.id}')" class="btn-primary !py-1 px-3 !text-[9px]">Accept</button>
                    </div>`;
                }).join('');
            myList.innerHTML = outgoing.length === 0
                ? '<p class="text-gray-500 fira text-sm py-8 text-center">No offers made yet</p>'
                : outgoing.map(o => {
                    const nft = state.nfts.find(n => n.id === o.nftId);
                    const imgPath = nft ? window.getNFTImagePath(nft) : '';
                    const imgUrl = imgPath ? `https://gateway.pinata.cloud/ipfs/${imgPath}` : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23333%22/%3E%3C/svg%3E';
                    return `<div class="flex items-center gap-4 p-4 bg-black/40 rounded-lg border border-purple-500/20">
                        <img src="${imgUrl}" class="w-16 h-16 rounded-lg object-cover">
                        <div class="flex-1 min-w-0">
                            <p class="orbitron text-sm font-bold text-white truncate">${o.nftName || 'NFT'}</p>
                            <p class="fira text-xs text-magenta-400">${o.amount} ${o.currency} ‚Ä¢ ${o.status || 'active'}</p>
                        </div>
                        <button onclick="window.cancelOffer('${o.id}')" class="p-2 text-red-400 hover:bg-red-500/10 rounded text-[9px]">Cancel</button>
                    </div>`;
                }).join('');
        };

        window.acceptOffer = async (offerId) => {
            const offer = state.offers.find(o => o.id === offerId);
            if (!offer) return window.notify("Offer not found", "error");
            
            const nft = state.nfts.find(n => n.id === offer.nftId);
            if (!nft || nft.owner.toLowerCase() !== state.address.toLowerCase()) {
                return window.notify("You don't own this NFT", "error");
            }
            
            if (!confirm(`Accept offer of ${offer.amount} ${offer.currency} for ${nft.name}?`)) return;
            
            try {
                window.notify("Processing offer acceptance...", "success");
                console.log("üí∞ Accepting offer:", offer);
                
                // Step 1: Transfer payment from buyer to seller
                const buyerWallet = offer.offerer;
                const sellerWallet = state.address;
                const paymentAmount = parseFloat(offer.amount);
                const currency = offer.currency;
                
                console.log(`üí∏ Transferring ${paymentAmount} ${currency} from ${buyerWallet} to ${sellerWallet}`);
                
                // Use KeetaNet to transfer funds
                if (!window.KeetaNet || !state.keetaWallet) {
                    throw new Error("Wallet not connected");
                }
                
                // Note: In a real implementation, the buyer would need to sign the transaction
                // For now, we'll simulate the transfer by updating the offer status
                // In production, this would require the buyer to approve the payment
                
                window.notify("Transferring NFT ownership...", "success");
                
                // Step 2: Transfer NFT ownership
                const nftRef = doc(db, 'nfts', nft.id);
                await updateDoc(nftRef, {
                    owner: buyerWallet,
                    previousOwner: sellerWallet,
                    lastTransferredAt: new Date().toISOString(),
                    isListed: false,
                    listedPrice: null,
                    listedCurrency: null
                });
                
                console.log("‚úÖ NFT ownership transferred");
                
                // Step 3: Create transaction record
                window.notify("Recording transaction...", "success");
                
                const transactionId = `tx_offer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const transactionData = {
                    id: transactionId,
                    type: 'offer_accepted',
                    nftId: nft.id,
                    nftName: nft.name,
                    nftImage: nft.imagePath || nft.imageCid,
                    collectionId: nft.collectionId || nft.collection,
                    collectionName: nft.collectionName || nft.collectionTitle,
                    price: paymentAmount,
                    currency: currency,
                    seller: sellerWallet,
                    buyer: buyerWallet,
                    wallet: sellerWallet, // For seller's transaction history
                    offerId: offerId,
                    timestamp: new Date().toISOString(),
                    txHash: `offer_${offerId}`,
                    status: 'completed'
                };
                
                // Save transaction for seller
                await setDoc(
                    doc(db, 'transactions', transactionId),
                    transactionData
                );
                
                // Save transaction for buyer
                const buyerTransactionId = `${transactionId}_buyer`;
                await setDoc(
                    doc(db, 'transactions', buyerTransactionId),
                    {
                        ...transactionData,
                        id: buyerTransactionId,
                        wallet: buyerWallet,
                        type: 'offer_purchase'
                    }
                );
                
                console.log("‚úÖ Transaction records created");
                
                // Step 4: Update offer status
                await updateDoc(
                    doc(db, 'offers', offerId),
                    {
                        status: 'accepted',
                        acceptedAt: new Date().toISOString(),
                        transactionId: transactionId
                    }
                );
                
                // Step 5: Update wallet stats for seller
                await window.updateWalletStats({
                    type: 'sale',
                    price: paymentAmount,
                    currency: currency,
                    timestamp: new Date().toISOString()
                });
                
                console.log("‚úÖ Offer acceptance complete!");
                window.notify("‚úÖ Offer accepted! NFT transferred.", "success");
                
                // Refresh data
                await window.loadOffers();
                await window.loadNFTsFromFirebase();
                await window.loadTransactions();
                window.renderMarketplace();
                
                // If user is on collection tab, refresh it
                const collectionTab = document.getElementById('tab-collection');
                if (collectionTab && !collectionTab.classList.contains('hidden')) {
                    window.renderCollection();
                }
                
                // Show helpful message
                setTimeout(() => {
                    window.notify(`üí∞ Check your transactions tab to see the sale record!`, "success");
                }, 2000);
                
            } catch (error) {
                console.error("‚ùå Error accepting offer:", error);
                window.notify("Failed to accept offer: " + error.message, "error");
            }
        };

        window.cancelOffer = async (offerId) => {
            const offer = state.offers.find(o => o.id === offerId);
            if (!offer || offer.offerer.toLowerCase() !== state.address.toLowerCase()) return window.notify("Can only cancel your own offers", "error");
            try {
                await updateDoc(doc(db, 'offers', offerId), { status: 'cancelled', cancelledAt: new Date().toISOString() });
                window.notify("Offer cancelled", "success");
                await window.loadOffers();
            } catch (error) {
                console.error("Error cancelling offer:", error);
                window.notify("Failed to cancel offer", "error");
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UI WIPE & RELOAD FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.updateCachedItemsDisplay = () => {
            const nftsCount = document.getElementById('cachedNFTsCount');
            const collectionsCount = document.getElementById('cachedCollectionsCount');
            const transactionsCount = document.getElementById('cachedTransactionsCount');
            const totalCount = document.getElementById('cachedItemsCount');
            
            if (nftsCount) nftsCount.textContent = state.nfts?.length || 0;
            if (collectionsCount) collectionsCount.textContent = state.collections?.length || 0;
            if (transactionsCount) transactionsCount.textContent = state.transactions?.length || 0;
            if (totalCount) {
                const total = (state.nfts?.length || 0) + (state.collections?.length || 0) + (state.transactions?.length || 0);
                totalCount.textContent = total;
            }
        };
        
        window.wipeUIAndReload = async (hardWipe = false) => {
            const confirmMsg = hardWipe 
                ? "‚ö†Ô∏è HARD WIPE: This will clear ALL cached data and force a complete reload. Continue?"
                : "üîÑ SOFT RELOAD: This will refresh data from database. Continue?";
            
            if (!confirm(confirmMsg)) return;
            
            try {
                console.log(`üî• ${hardWipe ? 'HARD' : 'SOFT'} WIPE INITIATED`);
                window.notify(`${hardWipe ? 'üí•' : 'üîÑ'} Wiping UI cache...`, "success");
                
                if (hardWipe) {
                    // HARD WIPE: Clear everything
                    console.log("üí• Clearing all state...");
                    
                    // Clear all state arrays
                    state.nfts = [];
                    state.collections = [];
                    state.transactions = [];
                    state.allTransactions = [];
                    state.offers = [];
                    state.offersOnMyNFTs = [];
                    state.myOffers = [];
                    state.traitCounts = {};
                    state.viewingCollection = null;
                    
                    // Clear session storage
                    try {
                        sessionStorage.clear();
                        console.log("‚úÖ Session storage cleared");
                    } catch (e) {
                        console.warn("‚ö†Ô∏è Could not clear session storage:", e);
                    }
                    
                    // Clear any chart data
                    if (window.currentChart) {
                        window.currentChart.destroy();
                        window.currentChart = null;
                    }
                    
                    console.log("‚úÖ State wiped clean");
                }
                
                // Force reload all data from Firebase
                window.notify("üì• Loading fresh data from database...", "success");
                console.log("üì• Loading fresh data from Firebase...");
                
                await window.loadNFTsFromFirebase();
                await window.loadCollections();
                await window.loadTraitCounts();
                
                if (state.address) {
                    await window.loadTransactions();
                    await window.loadOffers();
                }
                
                // Re-render all views
                window.notify("üé® Refreshing all views...", "success");
                console.log("üé® Re-rendering all views...");
                
                window.renderMarketplace();
                window.renderDrops();
                window.renderCollection();
                window.populateChartSelector();
                await window.initFloorPulseChart();
                
                // Update the cached items display
                window.updateCachedItemsDisplay();
                
                console.log("‚úÖ UI WIPE COMPLETE!");
                window.notify(`‚úÖ ${hardWipe ? 'Hard wipe' : 'Soft reload'} complete! UI synced with database.`, "success");
                
            } catch (error) {
                console.error("‚ùå Error during wipe:", error);
                window.notify("‚ùå Wipe failed: " + error.message, "error");
            }
        };
        
        window.hardRefreshPage = () => {
            if (confirm("üîÑ This will refresh the entire page (like pressing F5). Continue?")) {
                window.location.reload(true);
            }
        };
        
        window.forceReload = async () => {
            // Legacy function - redirect to new wipe function
            await window.wipeUIAndReload(false);
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FORCE SYNC & GHOST DATA CLEANUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.forceSyncCollections = async () => {
            if (!confirm("üîÑ Force sync collections from Firebase? This will clear cached collections and reload from database.")) return;
            
            try {
                console.log("üîÑ Force syncing collections...");
                window.notify("üîÑ Syncing collections from Firebase...", "success");
                
                // Clear current collections
                state.collections = [];
                console.log("‚úÖ Cleared cached collections");
                
                // Reload from Firebase
                await window.loadCollections();
                
                // Reload related data
                await window.loadTraitCounts();
                
                // Refresh UI
                window.renderCollections();
                window.renderMarketplace();
                window.updateCachedItemsDisplay();
                
                window.notify(`‚úÖ Synced ${state.collections.length} collections from Firebase`, "success");
                console.log(`‚úÖ Collections synced: ${state.collections.length} found`);
                
            } catch (error) {
                console.error("‚ùå Force sync failed:", error);
                window.notify("‚ùå Sync failed: " + error.message, "error");
            }
        };
        
        window.clearGhostData = async () => {
            if (!confirm("üëª Clear ghost data? This will:\n- Clear collections with 0 NFTs\n- Clear invalid collection references\n- Force reload from database")) return;
            
            try {
                console.log("üëª Clearing ghost data...");
                window.notify("üëª Clearing ghost data...", "success");
                
                // Count NFTs per collection
                const collectionNFTCounts = {};
                state.nfts.forEach(nft => {
                    const colId = nft.collectionId || nft.collection;
                    collectionNFTCounts[colId] = (collectionNFTCounts[colId] || 0) + 1;
                });
                
                // Filter out collections with no NFTs or invalid data
                const beforeCount = state.collections.length;
                state.collections = state.collections.filter(col => {
                    const colId = col.collectionId || col.id;
                    const nftCount = collectionNFTCounts[colId] || 0;
                    
                    // Keep if has NFTs or is actively listed
                    return nftCount > 0 || col.blindMintEnabled === true;
                });
                
                const removed = beforeCount - state.collections.length;
                console.log(`üëª Removed ${removed} ghost collections (had 0 NFTs)`);
                
                // Reload from Firebase to get fresh data
                await window.loadCollections();
                await window.loadNFTsFromFirebase();
                
                // Refresh UI
                window.renderCollections();
                window.renderMarketplace();
                window.updateCachedItemsDisplay();
                
                window.notify(`‚úÖ Cleared ${removed} ghost collections. ${state.collections.length} valid collections remain.`, "success");
                
            } catch (error) {
                console.error("‚ùå Ghost cleanup failed:", error);
                window.notify("‚ùå Cleanup failed: " + error.message, "error");
            }
        };

        // Call initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => initializeMarketplace());
        } else {
            initializeMarketplace();
        }
        
    </script>
<!-- OFFER MODAL -->
<div id="offerModal" class="listing-modal-overlay hidden">
    <div class="glass-card p-12 max-w-3xl w-full border-cyan-500/20 shadow-2xl">
        <div class="flex justify-between items-start mb-8">
            <div>
                <h2 class="orbitron text-2xl font-black uppercase text-cyan-400 tracking-tighter">Make an Offer</h2>
                <p id="offerModalSubtitle" class="fira text-xs text-gray-500 mt-2">Propose a price to the NFT owner</p>
            </div>
            <button onclick="window.closeOfferModal()" class="text-gray-500 hover:text-white transition-colors">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="grid grid-cols-2 gap-8 mb-8">
            <div>
                <div id="offerNFTPreview" class="w-full aspect-square bg-black/40 rounded-xl border border-white/10 mb-4 overflow-hidden"></div>
                <h3 id="offerNFTName" class="orbitron text-lg font-bold text-white mb-2">---</h3>
                <div class="space-y-1">
                    <div class="fira text-xs text-gray-400">Owner: <span id="offerNFTOwner" class="text-cyan-400 font-mono">---</span></div>
                    <div class="fira text-xs text-gray-400">Listed: <span id="offerNFTListed" class="text-green-400">---</span></div>
                </div>
            </div>
            <div class="space-y-6">
                <div>
                    <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Select Currency</label>
                    <div class="flex gap-3">
                        <label class="flex-1 cursor-pointer">
                            <input type="radio" name="offerCurrency" value="KTA" checked class="hidden peer" onchange="window.updateOfferSummary()">
                            <div class="p-4 rounded-lg border-2 border-cyan-500/30 bg-cyan-500/5 peer-checked:border-cyan-500 peer-checked:bg-cyan-500/20 transition-all text-center hover:border-cyan-500/50">
                                <div class="orbitron text-sm font-bold text-cyan-400">KTA</div>
                                <div class="fira text-[9px] text-gray-500 mt-1">Balance: <span id="offerKTABalance">0</span></div>
                            </div>
                        </label>
                        <label class="flex-1 cursor-pointer">
                            <input type="radio" name="offerCurrency" value="PUNKS" class="hidden peer" onchange="window.updateOfferSummary()">
                            <div class="p-4 rounded-lg border-2 border-magenta-500/30 bg-magenta-500/5 peer-checked:border-magenta-500 peer-checked:bg-magenta-500/20 transition-all text-center hover:border-magenta-500/50">
                                <div class="orbitron text-sm font-bold text-magenta-400">PUNKS</div>
                                <div class="fira text-[9px] text-gray-500 mt-1">Balance: <span id="offerPUNKSBalance">0</span></div>
                            </div>
                        </label>
                    </div>
                </div>
                <div>
                    <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Your Offer Amount</label>
                    <input type="number" id="offerAmountInput" step="0.1" min="0" placeholder="Enter amount..." class="w-full bg-black/60 border border-white/5 p-4 rounded-xl fira text-xl text-cyan-400 outline-none font-bold focus:border-cyan-500" oninput="window.updateOfferSummary()">
                </div>
                <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                    <div class="text-[9px] orbitron text-gray-500 uppercase font-black mb-3">Offer Summary</div>
                    <div class="space-y-2 fira text-xs">
                        <div class="flex justify-between"><span class="text-gray-400">Your offer</span><span id="offerTotal" class="text-white font-bold">0.00 KTA</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">Valid for</span><span class="text-cyan-400 font-bold">7 days</span></div>
                    </div>
                </div>
                <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-3">
                    <div class="flex items-start gap-2">
                        <span class="text-yellow-500 text-sm">üí°</span>
                        <p class="fira text-[9px] text-yellow-200">Offer will be visible to the NFT owner who can accept or decline it.</p>
                    </div>
                </div>
                <button onclick="window.submitOffer()" class="btn-primary w-full py-4 text-sm">Submit Offer</button>
            </div>
        </div>
    </div>
</div>
</body>
</html>
