<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PunkSwap v6.3 | Offers UI + All Features</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Preconnect to CDNs (reduces connection overhead, helps avoid ERR_INSUFFICIENT_RESOURCES) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://static.network.keeta.com">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind CDN production warning
        if (typeof window !== 'undefined') {
            const originalError = console.error;
            console.error = (...args) => {
                if (args[0] && typeof args[0] === 'string' && args[0].includes('cdn.tailwindcss.com should not be used in production')) {
                    return; // Suppress this specific warning
                }
                originalError.apply(console, args);
            };
        }
    </script>
    <!-- Chart.js - lazy loaded when charts are needed (saves ~200KB on initial load) -->
    <!-- Keeta SDK - critical for wallet/blockchain -->
    <script src="https://static.network.keeta.com/keetanet-browser.js" defer></script>
    
    <style>
        :root {
            --neon-cyan: #00ffff;
            --neon-magenta: #ff00ff;
            --neon-purple: #bc13fe;
            --carbon-bg: #010102;
            --sidebar-bg: #050508;
            --panel-bg: rgba(8, 8, 12, 0.98);
            --slot-bg: rgba(255, 255, 255, 0.01);
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--carbon-bg);
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.01) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.01) 1px, transparent 1px);
            background-size: 60px 60px;
            color: #e2e2e9;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        .sharp-img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            transform: translateZ(0);
            backface-visibility: hidden;
            will-change: transform;
        }

        #sidebar {
            width: 280px;
            background: var(--sidebar-bg);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            position: relative;
        }
        
        /* Mobile: Hide sidebar by default, show hamburger */
        @media (max-width: 768px) {
            #sidebar {
                position: fixed;
                left: -280px;
                top: 0;
                bottom: 0;
                transition: left 0.3s ease;
                z-index: 2000;
            }
            
            #sidebar.mobile-open {
                left: 0;
                box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
            }
            
            #mobileMenuBtn {
                display: flex !important;
            }
            
            #mobileOverlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.7);
                z-index: 1999;
            }
            
            #mobileOverlay.active {
                display: block;
            }
        }
        
        /* Desktop: Always show sidebar */
        @media (min-width: 769px) {
            #mobileMenuBtn {
                display: none !important;
            }
        }

        .sidebar-section-label {
            padding: 1.5rem 2rem 0.5rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.55rem;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 900;
        }

        .nav-item {
            display: flex;
            align-items: center; gap: 1rem; padding: 0.8rem 2rem; color: #555;
            font-family: 'Orbitron', sans-serif; font-size: 0.7rem; font-weight: 700;
            text-transform: uppercase; letter-spacing: 1.5px; transition: all 0.2s ease;
            border-left: 2px solid transparent; cursor: pointer;
        }

        .nav-item:hover { color: var(--neon-cyan); background: rgba(0, 255, 255, 0.02); }
        .nav-item.active {
            color: var(--neon-cyan); background: linear-gradient(90deg, rgba(0, 255, 255, 0.05) 0%, transparent 100%);
            border-left-color: var(--neon-cyan);
        }

        #viewport { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .top-bar {
            height: 80px; border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 3rem; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(15px);
        }
        .content-scroll { flex: 1; overflow-y: auto; padding: 2.5rem; }

        .glass-card { 
            background: var(--panel-bg); 
            border: 1px solid rgba(255, 255, 255, 0.05); 
            border-radius: 1rem;
            overflow: hidden;
        }

        .seed-box {
            background: #000000 !important;
            border: 2px solid #333 !important;
            color: #ffffff !important;
            text-align: center;
            padding: 18px 10px;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            font-size: 16px;
            font-weight: 900;
            outline: none;
            transition: 0.2s;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.9);
        }

        .btn-primary {
            background: rgba(0, 255, 255, 0.03); border: 1px solid var(--neon-cyan); color: var(--neon-cyan);
            padding: 0.75rem 1rem; font-family: 'Orbitron', sans-serif; text-transform: uppercase;
            font-size: 0.7rem; font-weight: 800; border-radius: 0.5rem; transition: all 0.3s; text-align: center;
        }
        .btn-primary:hover:not(:disabled) { background: var(--neon-cyan); color: black; box-shadow: 0 0 20px var(--neon-cyan); }
        .btn-primary:disabled { opacity: 0.2; cursor: not-allowed; }

        .fira { font-family: 'Fira Code', monospace; }
        
        /* Filter Dropdown */
        #filtersDropdown {
            backdrop-filter: blur(20px);
            animation: slideDown 0.2s ease-out;
        }
        
        /* Mobile: Full width dropdown */
        @media (max-width: 768px) {
            #filtersDropdown {
                position: fixed;
                left: 1rem;
                right: 1rem;
                width: auto;
                max-height: 60vh;
            }
            
            .chart-container {
                padding: 1rem;
            }
            
            .chart-stats {
                flex-wrap: wrap;
                gap: 1rem;
            }
            
            .chart-stat {
                flex: 1 1 45%;
                min-width: 120px;
            }
            
            .top-bar {
                padding: 0 1.5rem;
                height: 70px;
            }
            
            .content-scroll {
                padding: 1.5rem;
            }
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .trait-filter-checkbox {
            width: 14px;
            height: 14px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            appearance: none;
            position: relative;
        }
        
        .trait-filter-checkbox:checked {
            background: #00ffff;
            border-color: #00ffff;
        }
        
        .trait-filter-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            top: -2px;
            left: 2px;
            color: #000;
            font-size: 12px;
            font-weight: bold;
        }
        
        .filter-group {
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .filter-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .orbitron { font-family: 'Orbitron', sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }

        .unit-slot {
            aspect-ratio: 1; border: 1px dashed rgba(255,255,255,0.05); border-radius: 1rem;
            background: rgba(255,255,255,0.01); display: flex; align-items: center; justify-content: center;
        }

        .cyber-switch { position: relative; display: inline-block; width: 44px; height: 22px; }
        .cyber-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #111; transition: .4s; border-radius: 34px; border: 1px solid #333; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 4px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--neon-purple); }
        input:checked + .slider:before { transform: translateX(20px); }

        .forge-mini-preview {
            width: 120px; height: 120px; background: #000; border-radius: 1rem; border: 1px solid var(--neon-cyan);
            overflow: hidden; display: flex; align-items: center; justify-content: center;
        }
        .forge-mini-preview img { width: 100%; height: 100%; object-fit: cover; }
        .price-mode-btn {
            padding: 8px 12px; border: 1px solid rgba(255,255,255,0.05); border-radius: 6px;
            font-family: 'Orbitron', sans-serif; font-size: 8px; text-transform: uppercase;
            color: #444; background: rgba(0,0,0,0.4); cursor: pointer; transition: 0.2s;
        }
        .price-mode-btn.active { border-color: var(--neon-cyan); color: var(--neon-cyan); background: rgba(0, 255, 255, 0.05); }
        .debug-log { background: rgba(0,0,0,0.5); border: 1px solid #111; color: #0f0; font-family: 'Fira Code', monospace; font-size: 9px; height: 100px; overflow-y: auto; padding: 10px; border-radius: 8px; margin-top: 10px; }
        
        /* ============================================
           FIX #2: MINT STATUS INDICATOR 
           ============================================ */
        .mint-status-badge {
            position: fixed;
            top: 100px;
            right: 3rem;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 800;
            text-transform: uppercase;
            z-index: 2000;
            animation: slideIn 0.3s ease;
        }
        
        .mint-status-pending {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.5);
            color: orange;
        }
        
        .mint-status-confirmed {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.5);
            color: lime;
        }
        
        .mint-status-failed {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.5);
            color: red;
        }
        
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* ============================================
           FIX #4: INLINE LISTING MODAL
           ============================================ */
        .listing-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* ============================================
           FIX #5: ENHANCED CHART STYLING
           ============================================ */
        .chart-container {
            position: relative;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 20, 40, 0.4) 100%);
            border-radius: 1rem;
            padding: 1.5rem;
            border: 1px solid rgba(0, 255, 255, 0.1);
            box-shadow: inset 0 0 30px rgba(0, 255, 255, 0.05);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(0, 255, 255, 0.15);
        }
        
        .chart-selector {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            outline: none;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .chart-selector:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .chart-selector option {
            background: #000;
            color: var(--neon-cyan);
        }
        
        .chart-stats {
            display: flex;
            gap: 2rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .chart-stat {
            flex: 1;
            text-align: center;
        }
        
        .chart-stat-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            text-transform: uppercase;
            color: #666;
            letter-spacing: 0.15em;
            margin-bottom: 0.25rem;
        }
        
        .chart-stat-value {
            font-family: 'Fira Code', monospace;
            font-size: 1.2rem;
            font-weight: 900;
            color: var(--neon-cyan);
        }
        
        .chart-stat-change {
            font-family: 'Fira Code', monospace;
            font-size: 0.7rem;
            margin-top: 0.25rem;
        }
        
        .chart-stat-change.positive {
            color: #00ff88;
        }
        
        .chart-stat-change.negative {
            color: #ff4466;
        }
        
        .chart-timeframe-selector {
            display: flex;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.4);
            padding: 0.25rem;
            border-radius: 0.5rem;
        }
        
        .chart-timeframe-btn {
            padding: 0.4rem 0.8rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.4rem;
            color: #666;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chart-timeframe-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
            color: var(--neon-cyan);
        }
        
        .chart-timeframe-btn.active {
            background: var(--neon-cyan);
            border-color: var(--neon-cyan);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        .trait-badge {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            padding: 0.65rem 0.75rem;
        }
        
        .traits-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .traits-container.expanded {
            max-height: 500px;
        }
        
        .trait-toggle-btn {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(0, 255, 255, 0.03);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 0.5rem;
            transition: all 0.2s;
            margin-top: 0.75rem;
        }
        
        .trait-toggle-btn:hover {
            background: rgba(0, 255, 255, 0.08);
            border-color: rgba(0, 255, 255, 0.4);
        }
        
        .trait-toggle-icon {
            transition: transform 0.3s ease;
        }
        
        .trait-toggle-icon.rotated {
            transform: rotate(180deg);
        }
        
        /* FIX #8: Prevent image movement during scroll */
        .group {
            contain: layout style;
        }
        
        .group .sharp-img {
            backface-visibility: hidden;
            transform-style: preserve-3d;
            will-change: transform;
            transform: translateZ(0);
        }
        
        .glass-card {
            transform: translateZ(0);
            will-change: transform;
        }
    
        .batch-mint-option {
            display: inline-block;
            margin-left: 8px;
            padding: 4px 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .batch-mint-option:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        /* ============================================
           CRITICAL FIX: Hidden class for modals
           ============================================ */
        .hidden {
            display: none !important;
        }

        </style>
</head>
<body>

    <!-- SIDEBAR -->
    <aside id="sidebar">
        <div class="px-8 py-10">
            <h1 class="orbitron text-xl font-black italic tracking-tighter text-white">
                PUNK<span class="text-cyan-400">SWAP</span>
            </h1>
            <div class="text-[7px] text-gray-600 uppercase tracking-[0.5em] font-bold mt-1">Grid Node v6.3 OFFERS</div>
        </div>

        <div class="profile-header px-8 py-6">
            <div id="profileOffline" class="space-y-4">
                <div class="flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-red-500 animate-pulse"></span>
                    <span class="orbitron text-[8px] text-gray-500 uppercase font-black tracking-widest">Neural Offline</span>
                </div>
                <button onclick="window.initNeuralLink()" class="btn-primary w-full">Initialize Link</button>
            </div>
            
            <div id="profileOnline" class="hidden space-y-4">
                <div class="flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-green-500 shadow-[0_0_10px_#0f0]"></span>
                    <span class="orbitron text-[8px] text-cyan-400 uppercase font-black tracking-widest">Authorized</span>
                </div>
                <div class="bg-white/5 p-3 rounded-lg border border-white/5">
                    <div id="walletAddressDisplay" class="fira text-[9px] text-gray-400 truncate font-bold">---</div>
                </div>
                <button onclick="window.disconnectWallet()" class="w-full text-[8px] orbitron text-gray-600 hover:text-white uppercase font-bold tracking-widest transition-colors">Terminate Session</button>
                <!-- Storage debug buttons hidden - only for development
                <button onclick="window.debugStorage()" class="w-full text-[7px] orbitron text-cyan-600 hover:text-cyan-400 uppercase font-bold tracking-widest transition-colors">
                    üîç Check Storage Status
                </button>
                <button onclick="window.clearCorruptedSession()" class="w-full text-[7px] orbitron text-red-600 hover:text-red-400 uppercase font-bold tracking-widest transition-colors">
                    üßπ Clear Corrupted Data
                </button>
                -->
            </div>
        </div>

        <div class="flex-1 overflow-y-auto no-scrollbar">
            <div class="sidebar-section-label">Public</div>
            <nav class="flex flex-col">
                <div id="nav-market" onclick="window.switchTab('market')" class="nav-item active">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    Explorer
                </div>
            </nav>

            <div class="sidebar-section-label">Personal Hub</div>
            <nav class="flex flex-col">
                <div id="nav-collection" onclick="window.switchTab('collection')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>
                    Neural Vault
                </div>
                <div id="nav-transactions" onclick="window.switchTab('transactions')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>
                    Transaction History
                </div>
                <div id="nav-portfolio" onclick="window.switchTab('portfolio')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg>
                    Portfolio & P/L
                </div>
                <div id="nav-offers" onclick="window.switchTab('offers')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Offers
                </div>
                <div id="nav-auctions" onclick="window.notify('üöß Auctions coming soon!', 'info')" class="nav-item opacity-50 cursor-not-allowed" title="Coming Soon">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Auctions
                    <span class="text-[8px] text-yellow-500 ml-2">SOON</span>
                </div>
                <div id="nav-activity" onclick="window.switchTab('activity')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path></svg>
                    Activity Feed
                </div>
            </nav>

            <div class="sidebar-section-label">Protocols</div>
            <nav class="flex flex-col">
                <div id="nav-admin" onclick="window.switchTab('admin')" class="nav-item">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
                    Forge Hub
                </div>
                <div id="nav-escrow-admin" onclick="window.switchTab('escrow-admin')" class="nav-item hidden text-purple-400">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path></svg>
                    Escrow Oversight
                </div>
                <div id="nav-airdrop" onclick="window.switchTab('airdrop')" class="nav-item hidden text-cyan-400">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
                    Airdrop Control
                </div>
            </nav>
        </div>
    </aside>
    
    <!-- Mobile Menu Overlay -->
    <div id="mobileOverlay" onclick="window.toggleMobileMenu()"></div>

    <!-- MAIN VIEWPORT -->
    <main id="viewport">
        <header class="top-bar">
            <div class="flex items-center gap-6">
                <!-- Mobile Hamburger Menu -->
                <button id="mobileMenuBtn" onclick="window.toggleMobileMenu()" class="hidden p-2 rounded-lg border border-cyan-500/30 hover:bg-cyan-500/10 transition-all">
                    <svg class="w-5 h-5 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                    </svg>
                </button>
                
                <span id="viewTitle" class="orbitron text-md font-black uppercase tracking-[0.2em] text-white">Grid Explorer</span>
                <div class="h-4 w-[1px] bg-white/10 hidden md:block"></div>
                <span class="fira text-[9px] text-gray-600 uppercase tracking-widest hidden md:block">Global Pop: <span id="statTotal" class="text-cyan-400">0</span></span>
            </div>

            <div class="flex gap-6 md:gap-12">
                <div class="text-right">
                    <div class="text-[7px] orbitron text-cyan-500 uppercase font-black tracking-widest mb-1">RESERVE KTA</div>
                    <div id="balanceKTA" class="fira text-sm md:text-lg font-black text-white">0.0000</div>
                </div>
                <div class="text-right">
                    <div class="text-[7px] orbitron text-magenta-500 uppercase font-black tracking-widest mb-1">RESERVE PUNKS</div>
                    <div id="balancePunks" class="fira text-sm md:text-lg font-black text-white">0</div>
                </div>
                <div id="escrowBalanceDisplay" class="text-right hidden">
                    <div class="text-[7px] orbitron text-yellow-500 uppercase font-black tracking-widest mb-1">ESCROW KTA</div>
                    <div id="balanceEscrow" class="fira text-sm md:text-lg font-black text-white">0.0000</div>
                </div>
            </div>
        </header>

        <div class="content-scroll no-scrollbar">
            
            <section id="tab-market" class="tab-content animate-view space-y-16">
                <div class="glass-card p-10 space-y-6 border border-white/5">
                    <div class="chart-header">
                        <div>
                            <h3 class="orbitron text-xs text-gray-500 uppercase font-black tracking-[0.4em]">Market Depth Analysis</h3>
                            <p class="fira text-[8px] text-gray-700 mt-1 uppercase tracking-wider">Real-time floor price tracking</p>
                        </div>
                        <div class="flex items-center gap-4">
                            <select id="chartCollectionSelector" class="chart-selector" onchange="window.updateMarketChart()">
                                <option value="all">Overall Marketplace</option>
                            </select>
                            <!-- Currency Toggle -->
                            <div class="flex rounded-lg overflow-hidden border border-white/10">
                                <button id="chartCurrencyKTA" onclick="window.setChartCurrency('KTA')" class="px-3 py-1.5 text-[10px] orbitron font-black bg-cyan-500/30 text-cyan-400 border-r border-white/10 transition-all">KTA</button>
                                <button id="chartCurrencyPUNKS" onclick="window.setChartCurrency('PUNKS')" class="px-3 py-1.5 text-[10px] orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white">PUNKS</button>
                                <button id="chartCurrencyALL" onclick="window.setChartCurrency('ALL')" class="px-3 py-1.5 text-[10px] orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white">ALL</button>
                            </div>
                            <div class="chart-timeframe-selector">
                                <button class="chart-timeframe-btn active" data-timeframe="1h" onclick="window.setChartTimeframe('1h')">1H</button>
                                <button class="chart-timeframe-btn" data-timeframe="24h" onclick="window.setChartTimeframe('24h')">24H</button>
                                <button class="chart-timeframe-btn" data-timeframe="7d" onclick="window.setChartTimeframe('7d')">7D</button>
                                <button class="chart-timeframe-btn" data-timeframe="30d" onclick="window.setChartTimeframe('30d')">30D</button>
                                <button class="chart-timeframe-btn" data-timeframe="all" onclick="window.setChartTimeframe('all')">ALL</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- FIX #5: Enhanced Market Pulse Chart -->
                    <div class="chart-container">
                        <div class="h-64 relative">
                            <canvas id="floorPulseChart"></canvas>
                            <div id="chartLoadingState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs flex items-center gap-2">
                                    <div class="w-4 h-4 border-2 border-cyan-500 border-t-transparent rounded-full animate-spin"></div>
                                    Loading market data...
                                </div>
                            </div>
                            <div id="chartEmptyState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs">No market data yet</div>
                            </div>
                        </div>
                        
                        <div class="chart-stats">
                            <div class="chart-stat">
                                <div class="chart-stat-label">Floor Price</div>
                                <div class="chart-stat-value" id="chartFloorPrice">‚Äî</div>
                                <div class="chart-stat-change" id="chartFloorChange">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">24h Volume</div>
                                <div class="chart-stat-value" id="chart24hVolume">‚Äî</div>
                                <div class="chart-stat-change" id="chartVolumeChange">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Listed</div>
                                <div class="chart-stat-value" id="chartListedCount">‚Äî</div>
                                <div class="chart-stat-change" id="chartListedPercent">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Avg Price</div>
                                <div class="chart-stat-value" id="chartAvgPrice">‚Äî</div>
                                <div class="chart-stat-change" id="chartAvgChange">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex justify-between items-center">
                    <div>
                        <h2 class="orbitron text-3xl font-black uppercase italic tracking-tighter text-white">Trending Collections</h2>
                        <p class="fira text-xs text-gray-500 mt-1">Collections sorted by 24h trading volume</p>
                    </div>
                    <input type="text" id="marketSearch" oninput="window.renderMarketplace()" placeholder="Search Matrix ID..." class="w-80 bg-black/40 border border-white/5 rounded-lg px-4 py-2 fira text-xs text-cyan-400 outline-none focus:border-cyan-500">
                </div>
                
                <div id="collectionListGrid" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-6"></div>

                <div class="pt-16 border-t border-white/5 space-y-8">
                    <div class="flex justify-between items-center">
                        <div>
                            <h3 class="orbitron text-lg font-black uppercase text-cyan-500 tracking-widest italic">‚ö° Active Collections</h3>
                            <p class="fira text-xs text-gray-500 mt-1">Browse revealed collections and view stats</p>
                        </div>
                        <div class="flex gap-2" id="activeCollectionsButtons">
                            <!-- SHOW ALL button will be dynamically inserted here for escrow wallet -->
                            <button onclick="window.switchTab('all-collections'); window.renderAllCollections();" class="px-4 py-2 bg-gradient-to-r from-cyan-600 to-purple-600 text-white rounded-lg text-xs orbitron font-bold hover:from-cyan-500 hover:to-purple-500 transition-all shadow-lg hover:shadow-cyan-500/30">
                                üìÇ View All
                            </button>
                            <button onclick="window.loadCollections(); window.notify('Collections refreshed!', 'success');" class="px-4 py-2 bg-cyan-500/10 border border-cyan-500/30 text-cyan-400 rounded-lg text-xs orbitron font-bold hover:bg-cyan-500/20 transition-all">
                                üîÑ Refresh
                            </button>
                        </div>
                    </div>
                    <div id="regularCollectionGrid" class="grid grid-cols-1 md:grid-cols-4 gap-6"></div>
                </div>

                <div class="pt-16 border-t border-white/5 space-y-8">
                    <div class="flex justify-between items-center">
                        <div>
                            <h3 class="orbitron text-lg font-black uppercase text-magenta-500 tracking-widest italic">üé≤ Mystery Drops</h3>
                            <p class="fira text-xs text-gray-500 mt-1">Blind mint collections - mint to reveal your NFT</p>
                        </div>
                        <button onclick="window.loadCollections(); window.notify('Collections refreshed!', 'success');" class="px-4 py-2 bg-cyan-500/10 border border-cyan-500/30 text-cyan-400 rounded-lg text-xs orbitron font-bold hover:bg-cyan-500/20 transition-all">
                            üîÑ Refresh
                        </button>
                    </div>
                    <div id="dropGrid" class="grid grid-cols-1 md:grid-cols-4 gap-6"></div>
                </div>
            </section>

            <!-- COLLECTION PAGE -->
            <section id="tab-collection-view" class="tab-content animate-view hidden space-y-12">
                <button onclick="window.goBackFromCollection()" class="text-[10px] orbitron text-cyan-400 uppercase font-black hover:text-white transition-colors" id="colViewBackBtn">‚Üê explorer</button>
                <div id="collectionPageHeader" class="glass-card p-12 flex gap-12 items-center border-l-[10px] border-cyan-500">
                    <div class="w-48 h-48 rounded-2xl bg-black border border-white/10 overflow-hidden shadow-2xl" id="colPageImage"></div>
                    <div class="flex-1 space-y-4">
                        <h2 id="colPageTitle" class="orbitron text-5xl font-black uppercase italic tracking-tighter text-white">---</h2>
                        <p id="colPageDesc" class="fira text-sm text-gray-400 max-w-2xl leading-relaxed italic"></p>
                        <div class="flex gap-10 pt-4 border-t border-white/5">
                            <div><div class="text-[9px] orbitron text-gray-500 uppercase font-black tracking-widest">Creator ID</div><div id="colPageCreator" class="fira text-xs text-cyan-400 font-bold">---</div></div>
                            <div><div class="text-[9px] orbitron text-gray-500 uppercase font-black tracking-widest">Population</div><div id="colPageSupply" class="fira text-xs text-white font-bold">0</div></div>
                            <div><div class="text-[9px] orbitron text-gray-500 uppercase font-black tracking-widest">Floor Price</div><div id="colPageFloor" class="fira text-xs text-cyan-400 font-bold">‚Äî</div></div>
                        </div>
                    </div>
                </div>
                <div class="glass-card p-10">
                    <div class="chart-header">
                        <div>
                            <h3 class="orbitron text-[10px] text-gray-500 uppercase font-black mb-2 tracking-widest">Collection Market Depth</h3>
                            <p class="fira text-[8px] text-gray-700 uppercase tracking-wider">Real-time price & volume analytics</p>
                        </div>
                        <div class="chart-timeframe-selector">
                            <button class="chart-timeframe-btn" data-timeframe="1h" onclick="window.setCollectionChartTimeframe('1h')">1H</button>
                            <button class="chart-timeframe-btn active" data-timeframe="24h" onclick="window.setCollectionChartTimeframe('24h')">24H</button>
                            <button class="chart-timeframe-btn" data-timeframe="7d" onclick="window.setCollectionChartTimeframe('7d')">7D</button>
                            <button class="chart-timeframe-btn" data-timeframe="all" onclick="window.setCollectionChartTimeframe('all')">ALL</button>
                        </div>
                    </div>
                    
                    <div class="chart-container mt-4">
                        <!-- Collection Chart Currency Toggle -->
                        <div class="flex justify-end mb-2">
                            <div class="inline-flex rounded-lg overflow-hidden border border-white/10">
                                <button id="colChartCurrencyKTA" onclick="window.setColChartCurrency('KTA')" class="px-3 py-1 text-[10px] orbitron font-black bg-cyan-500/30 text-cyan-400 transition-all">KTA</button>
                                <button id="colChartCurrencyPUNKS" onclick="window.setColChartCurrency('PUNKS')" class="px-3 py-1 text-[10px] orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white border-l border-white/10">PUNKS</button>
                                <button id="colChartCurrencyALL" onclick="window.setColChartCurrency('ALL')" class="px-3 py-1 text-[10px] orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white border-l border-white/10">ALL</button>
                            </div>
                        </div>
                        <div class="h-64 relative">
                            <canvas id="colPageChart"></canvas>
                            <div id="colChartLoadingState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs flex items-center gap-2">
                                    <div class="w-4 h-4 border-2 border-cyan-500 border-t-transparent rounded-full animate-spin"></div>
                                    Loading collection data...
                                </div>
                            </div>
                            <div id="colChartEmptyState" class="absolute inset-0 flex items-center justify-center hidden">
                                <div class="text-gray-500 fira text-xs">No listing history yet</div>
                            </div>
                        </div>
                        
                        <div class="chart-stats">
                            <div class="chart-stat">
                                <div class="chart-stat-label">Floor</div>
                                <div class="chart-stat-value" id="colChartFloor">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Ceiling</div>
                                <div class="chart-stat-value" id="colChartCeiling">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Volume</div>
                                <div class="chart-stat-value" id="colChartVolume">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Listed</div>
                                <div class="chart-stat-value" id="colChartListed">‚Äî</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-label">Supply</div>
                                <div class="chart-stat-value" id="colChartSupply">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Filters & Sort Controls -->
                <div class="flex justify-between items-center gap-4">
                    <!-- Trait Filters Dropdown -->
                    <div class="relative">
                        <button id="filtersToggleBtn" onclick="window.toggleFiltersDropdown()" class="flex items-center gap-2 px-4 py-2 rounded-lg border border-cyan-500/30 text-sm orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
                            </svg>
                            <span>Filters</span>
                            <span id="filterCount" class="hidden ml-1 px-2 py-0.5 rounded-full bg-cyan-500 text-black text-xs font-black">0</span>
                        </button>
                        
                        <!-- Dropdown Menu -->
                        <div id="filtersDropdown" class="hidden absolute top-full left-0 mt-2 w-80 max-h-96 overflow-y-auto glass-card border border-cyan-500/30 rounded-lg shadow-2xl z-50">
                            <div class="p-4 border-b border-white/10">
                                <div class="flex justify-between items-center">
                                    <h3 class="orbitron text-sm text-cyan-400 uppercase font-black tracking-widest">Trait Filters</h3>
                                    <button onclick="window.clearFilters()" class="text-xs orbitron font-bold uppercase text-red-400 hover:text-red-300">Clear All</button>
                                </div>
                            </div>
                            <div id="traitFilters" class="p-4 space-y-3"></div>
                        </div>
                    </div>
                    
                    <!-- Sort Options -->
                    <div class="flex gap-3">
                        <button onclick="window.setSortMode('rarity')" id="sort-rarity" class="sort-btn text-sm orbitron font-bold uppercase px-4 py-2 rounded-lg border border-white/10 text-gray-400 hover:text-cyan-400 hover:border-cyan-500/30 transition-all">Rarity %</button>
                        <button onclick="window.setSortMode('traits')" id="sort-traits" class="sort-btn text-sm orbitron font-bold uppercase px-4 py-2 rounded-lg border border-white/10 text-gray-400 hover:text-cyan-400 hover:border-cyan-500/30 transition-all">Trait Count</button>
                        <button onclick="window.setSortMode('price')" id="sort-price" class="sort-btn active text-sm orbitron font-bold uppercase px-4 py-2 rounded-lg border border-cyan-500/30 text-cyan-400 bg-cyan-500/5">Price</button>
                    </div>
                </div>
                
                <div id="colPageGrid" class="grid grid-cols-2 md:grid-cols-5 gap-6"></div>
                
                <!-- Collection Comments Section -->
                <div id="collectionCommentsSection" class="mt-12 glass-card p-8 border-white/5">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="text-3xl">üí¨</span>
                        <h3 class="orbitron text-2xl font-black text-white uppercase">Collection Chat</h3>
                        <span id="commentCount" class="text-sm text-cyan-400 fira">(0 comments)</span>
                    </div>
                    
                    <!-- Comment Input (only if wallet connected) -->
                    <div id="commentInputSection" class="mb-8 hidden">
                        <div class="flex gap-3">
                            <input type="text" 
                                   id="collectionCommentInput" 
                                   placeholder="Share your thoughts about this collection..." 
                                   maxlength="500"
                                   class="flex-1 bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white text-sm fira outline-none focus:border-cyan-500"
                                   onkeypress="if(event.key==='Enter') window.postCollectionComment()">
                            <button onclick="window.postCollectionComment()" 
                                    class="btn-primary px-8 py-3">
                                üí¨ Post
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 fira mt-2">Press Enter or click Post to submit (max 500 characters)</p>
                    </div>
                    
                    <!-- Comments List -->
                    <div id="collectionCommentsList" class="space-y-4">
                        <div class="text-center py-12 text-gray-500 fira">
                            <span class="text-5xl mb-3 block">üí¨</span>
                            <p>No comments yet. Be the first to share your thoughts!</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Personal Modules -->
            <section id="tab-collection" class="tab-content animate-view hidden space-y-8">
                <div id="vaultGate" class="auth-gate glass-card p-16 text-center border-magenta-500/10"><h2 class="orbitron text-2xl font-black uppercase text-magenta-500 mb-6 italic">Vault Encrypted</h2><button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sync</button></div>
                <div id="vaultContainer" class="hidden space-y-8">
                    <div class="flex justify-between items-center">
                        <h2 class="orbitron text-4xl font-black uppercase italic text-magenta-500">Neural Vault</h2>
                        <div class="flex gap-4 items-center">
                            <button onclick="window.toggleMonitoring()" class="btn-primary px-6 flex items-center gap-2">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0zM2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                                <span id="monitoringBtnText">Show Monitoring</span>
                            </button>
                            <button onclick="window.renderCollection()" class="btn-primary px-10">Refresh Storage</button>
                            <button onclick="window.syncWalletNFTs()" class="btn-secondary px-10 ml-3">Sync Wallet</button>
                        </div>
                    </div>
                    
                    <!-- Portfolio Summary (Quick View) -->
                    <div class="glass-card p-6 border-cyan-500/20">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="orbitron text-lg font-black uppercase text-cyan-400">Portfolio Overview</h3>
                            <button onclick="window.calculatePortfolio(); window.switchTab('portfolio')" class="text-cyan-400 hover:text-cyan-300 transition-colors fira text-xs underline">
                                View Details ‚Üí
                            </button>
                        </div>
                        
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div class="bg-black/40 p-4 rounded-lg border border-cyan-500/20">
                                <div class="text-[10px] orbitron text-gray-500 uppercase mb-1 font-bold">Portfolio Value</div>
                                <div id="vaultPortfolioValue" class="text-xl fira font-black text-cyan-400">0 KTA</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-green-500/20">
                                <div class="text-[10px] orbitron text-gray-500 uppercase mb-1 font-bold">Total P/L</div>
                                <div id="vaultPortfolioPnL" class="text-xl fira font-black text-green-400">+0 KTA</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20">
                                <div class="text-[10px] orbitron text-gray-500 uppercase mb-1 font-bold">Invested</div>
                                <div id="vaultPortfolioInvested" class="text-xl fira font-black text-purple-400">0 KTA</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-yellow-500/20">
                                <div class="text-[10px] orbitron text-gray-500 uppercase mb-1 font-bold">NFTs Owned</div>
                                <div id="vaultPortfolioNFTs" class="text-xl fira font-black text-yellow-400">0</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Monitoring Dropdown -->
                    <div id="monitoringDropdown" class="hidden glass-card p-8 border-cyan-500/20 animate-view">
                        <div class="flex justify-between items-center mb-6">
                            <h3 class="orbitron text-lg font-black uppercase text-cyan-400">Monitored NFTs</h3>
                            <span class="fira text-xs text-gray-500" id="monitoredCount">0 monitored</span>
                        </div>
                        <div id="watchlistGrid" class="grid grid-cols-2 md:grid-cols-5 gap-6"></div>
                    </div>
                    

                    <!-- Peregrine Falcon Punks Rescan -->
                    <div class="glass-card p-4 border-cyan-500/20 mb-6 flex items-center justify-between">
                        <div>
                            <h4 class="orbitron text-sm font-black uppercase text-cyan-400">Peregrine Falcon Punks</h4>
                            <p class="fira text-[10px] text-gray-500 mt-1">Scan your wallet for owned Peregrine Falcon Punks NFTs</p>
                        </div>
                        <button onclick="window.manualPFPScan()" class="px-6 py-2 rounded-lg bg-gradient-to-r from-cyan-600 to-blue-600 text-white text-[10px] orbitron font-bold uppercase hover:from-cyan-500 hover:to-blue-500 transition-all shadow-lg hover:shadow-cyan-500/50">
                            üîÑ Scan
                        </button>
                    </div>
                    
                    <div id="collectionGrid" class="grid grid-cols-2 md:grid-cols-5 gap-6"></div>
                </div>
            </section>

            <!-- TRANSACTION HISTORY TAB -->
            <section id="tab-transactions" class="tab-content animate-view hidden space-y-8">
                <div id="transactionsGate" class="auth-gate glass-card p-16 text-center border-cyan-500/10">
                    <h2 class="orbitron text-2xl font-black uppercase text-cyan-400 mb-4 italic">Transaction Verification</h2>
                    <button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button>
                </div>
                
                <div id="transactionsContainer" class="hidden space-y-8">
                    <div class="glass-card p-12">
                        <div class="flex justify-between items-center mb-8">
                            <div>
                                <h2 class="orbitron text-4xl font-black uppercase italic text-cyan-500">Transaction History</h2>
                                <p class="fira text-sm text-gray-500 mt-2">Complete record of all marketplace activities</p>
                            </div>
                            <button onclick="window.loadTransactions()" class="btn-primary px-8">
                                <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Refresh
                            </button>
                        </div>
                        
                        <!-- Filter Options -->
                        <div class="flex gap-4 mb-6 flex-wrap">
                            <select id="txTypeFilter" onchange="window.filterTransactions()" class="bg-black/60 border border-cyan-500/30 px-4 py-2 rounded-lg text-sm text-cyan-400 font-bold orbitron">
                                <option value="all">All Types</option>
                                <option value="sale">Sales</option>
                                <option value="purchase">Purchases</option>
                                <option value="listing">Listings</option>
                                <option value="cancellation">Cancellations</option>
                                <option value="mint">Mints</option>
                            </select>
                            
                            <select id="txDateFilter" onchange="window.filterTransactions()" class="bg-black/60 border border-cyan-500/30 px-4 py-2 rounded-lg text-sm text-cyan-400 font-bold orbitron">
                                <option value="all">All Time</option>
                                <option value="today">Today</option>
                                <option value="week">This Week</option>
                                <option value="month">This Month</option>
                            </select>
                            
                            <input type="text" id="txSearchInput" oninput="window.filterTransactions()" placeholder="Search by NFT or collection..." class="flex-1 min-w-64 bg-black/60 border border-cyan-500/30 px-4 py-2 rounded-lg text-sm text-cyan-400 font-bold fira outline-none">
                        </div>
                        
                        <!-- Transaction Stats -->
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                            <div class="bg-black/40 p-4 rounded-lg border border-cyan-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">Total Transactions</div>
                                <div id="txTotalCount" class="text-2xl fira font-black text-cyan-400">0</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-green-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">Total Sales</div>
                                <div id="txTotalSales" class="text-2xl fira font-black text-green-400">0 KTA</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-purple-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">Total Purchases</div>
                                <div id="txTotalPurchases" class="text-2xl fira font-black text-purple-400">0 KTA</div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-yellow-500/20">
                                <div class="text-xs orbitron text-gray-500 uppercase mb-1 font-bold">NFTs Minted</div>
                                <div id="txTotalMints" class="text-2xl fira font-black text-yellow-400">0</div>
                            </div>
                        </div>
                        
                        <!-- Transactions Table -->
                        <div class="bg-black/40 rounded-xl border border-white/5 overflow-hidden">
                            <div class="overflow-x-auto">
                                <table class="w-full">
                                    <thead class="bg-black/60 border-b border-white/10">
                                        <tr>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Date</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Type</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">NFT</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Collection</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Price</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Counter-Party</th>
                                            <th class="text-left p-4 orbitron text-xs text-cyan-400 uppercase font-black">Tx Hash</th>
                                        </tr>
                                    </thead>
                                    <tbody id="transactionsTableBody">
                                        <tr>
                                            <td colspan="7" class="p-12 text-center">
                                                <div class="text-gray-500 fira text-sm">No transactions yet</div>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- PORTFOLIO TAB -->
            <section id="tab-portfolio" class="tab-content animate-view hidden space-y-8">
                <div id="portfolioGate" class="auth-gate glass-card p-16 text-center border-cyan-500/10">
                    <h2 class="orbitron text-2xl font-black uppercase text-cyan-400 mb-4 italic">Portfolio Dashboard</h2>
                    <p class="fira text-sm text-gray-500 mb-6">Connect wallet to view your portfolio and P/L</p>
                    <button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button>
                </div>
                <div id="portfolioContainer" class="hidden space-y-8">
                    <div class="glass-card p-12">
                        <div class="flex justify-between items-center mb-8">
                            <div>
                                <h2 class="orbitron text-4xl font-black uppercase italic text-cyan-500">Portfolio & P/L</h2>
                                <p class="fira text-sm text-gray-500 mt-2">Track your NFT investment performance</p>
                            </div>
                            <button onclick="window.calculatePortfolio()" class="btn-primary px-8">
                                <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Recalculate
                            </button>
                        </div>
                        
                        <!-- Currency Toggle -->
                        <div class="flex justify-end mb-4">
                            <div class="inline-flex rounded-lg overflow-hidden border border-white/10">
                                <button id="pnlCurrencyKTA" onclick="window.setPnLCurrency('KTA')" class="px-4 py-2 text-xs orbitron font-black bg-cyan-500/30 text-cyan-400 transition-all">KTA</button>
                                <button id="pnlCurrencyPUNKS" onclick="window.setPnLCurrency('PUNKS')" class="px-4 py-2 text-xs orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white border-l border-white/10">PUNKS</button>
                            </div>
                        </div>

                        <!-- Portfolio Summary Cards -->
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                            <div class="bg-gradient-to-br from-cyan-500/10 to-cyan-500/5 p-6 rounded-xl border border-cyan-500/20">
                                <div class="flex items-center justify-between mb-3">
                                    <div class="text-xs orbitron text-cyan-400 uppercase font-bold">Total Value</div>
                                    <svg class="w-5 h-5 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                </div>
                                <div id="portfolioTotalValue" class="text-2xl fira font-black text-cyan-400">0 KTA</div>
                                <div id="portfolioTotalValuePunks" class="text-sm fira font-bold text-cyan-600 mt-1 hidden">0 PUNKS</div>
                                <div class="text-xs fira text-gray-500 mt-2">Current market value</div>
                            </div>

                            <div class="bg-gradient-to-br from-green-500/10 to-green-500/5 p-6 rounded-xl border border-green-500/20">
                                <div class="flex items-center justify-between mb-3">
                                    <div class="text-xs orbitron text-green-400 uppercase font-bold">Total Profit/Loss</div>
                                    <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>
                                </div>
                                <div id="portfolioPnL" class="text-2xl fira font-black text-green-400">+0 KTA</div>
                                <div id="portfolioPnLPunks" class="text-sm fira font-bold text-green-600 mt-1 hidden">+0 PUNKS</div>
                                <div id="portfolioPnLPercent" class="text-xs fira text-gray-500 mt-2">+0.0% KTA</div>
                                <div id="portfolioPnLPercentPunks" class="text-xs fira text-gray-600 hidden">+0.0% PUNKS</div>
                            </div>

                            <div class="bg-gradient-to-br from-purple-500/10 to-purple-500/5 p-6 rounded-xl border border-purple-500/20">
                                <div class="flex items-center justify-between mb-3">
                                    <div class="text-xs orbitron text-purple-400 uppercase font-bold">Total Invested</div>
                                    <svg class="w-5 h-5 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"></path></svg>
                                </div>
                                <div id="portfolioTotalInvested" class="text-2xl fira font-black text-purple-400">0 KTA</div>
                                <div id="portfolioTotalInvestedPunks" class="text-sm fira font-bold text-purple-600 mt-1 hidden">0 PUNKS</div>
                                <div class="text-xs fira text-gray-500 mt-2">Mints + purchases</div>
                            </div>

                            <div class="bg-gradient-to-br from-yellow-500/10 to-yellow-500/5 p-6 rounded-xl border border-yellow-500/20">
                                <div class="flex items-center justify-between mb-3">
                                    <div class="text-xs orbitron text-yellow-400 uppercase font-bold">Total NFTs</div>
                                    <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                                </div>
                                <div id="portfolioTotalNFTs" class="text-2xl fira font-black text-yellow-400">0</div>
                                <div class="text-xs fira text-gray-500 mt-2">Owned NFTs</div>
                            </div>
                        </div>

                        <!-- P/L Breakdown by Collection -->
                        <div class="bg-black/40 rounded-xl border border-white/5 p-6 mb-8">
                            <h3 class="orbitron text-xl font-bold text-white uppercase mb-6">P/L by Collection</h3>
                            <div id="collectionPnLList" class="space-y-4">
                                <div class="text-center py-8 text-gray-500 fira text-sm">
                                    Loading collection data...
                                </div>
                            </div>
                        </div>

                        <!-- Recent Performance -->
                        <div class="bg-black/40 rounded-xl border border-white/5 p-6">
                            <h3 class="orbitron text-xl font-bold text-white uppercase mb-6">Recent Performance</h3>
                            <div class="space-y-3">
                                <div class="flex justify-between items-center py-3 border-b border-white/5">
                                    <span class="fira text-sm text-gray-400">Best Performing NFT</span>
                                    <span id="bestPerformer" class="fira text-sm text-green-400 font-bold">‚Äî</span>
                                </div>
                                <div class="flex justify-between items-center py-3 border-b border-white/5">
                                    <span class="fira text-sm text-gray-400">Worst Performing NFT</span>
                                    <span id="worstPerformer" class="fira text-sm text-red-400 font-bold">‚Äî</span>
                                </div>
                                <div class="flex justify-between items-center py-3 border-b border-white/5">
                                    <span class="fira text-sm text-gray-400">Avg. Hold Time</span>
                                    <span id="avgHoldTime" class="fira text-sm text-cyan-400 font-bold">‚Äî</span>
                                </div>
                                <div class="flex justify-between items-center py-3">
                                    <span class="fira text-sm text-gray-400">Total Realized Gains</span>
                                    <div class="text-right">
                                        <span id="realizedGains" class="fira text-sm text-green-400 font-bold block">0 KTA</span>
                                        <span id="realizedGainsPunks" class="fira text-xs text-green-600 font-bold hidden">0 PUNKS</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- OFFERS TAB -->
            <section id="tab-offers" class="tab-content animate-view hidden space-y-8">
                <!-- COMING SOON BANNER -->
                <div class="glass-card p-12 text-center border-2 border-purple-500/30 bg-gradient-to-br from-purple-900/20 to-magenta-900/20">
                    <div class="text-6xl mb-4">üîß</div>
                    <h2 class="orbitron text-3xl font-black uppercase text-purple-400 mb-4">Offers Coming Soon!</h2>
                    <p class="fira text-lg text-gray-400 mb-2">We're finalizing the offers feature for the next update</p>
                    <p class="fira text-sm text-gray-500">For now, you can buy and sell NFTs directly on the marketplace</p>
                    <div class="mt-8 inline-block px-6 py-2 bg-purple-500/20 border border-purple-500/40 rounded-lg">
                        <span class="orbitron text-xs font-bold text-purple-300">EXPECTED: v1.1 UPDATE</span>
                    </div>
                </div>
                
                <!-- Original Offers Content (Hidden) -->
                <div class="hidden">
                <div id="offersGate" class="auth-gate glass-card p-16 text-center border-purple-500/10">
                    <h2 class="orbitron text-2xl font-black uppercase text-purple-400 mb-4 italic">Offers Hub</h2>
                    <p class="fira text-sm text-gray-500 mb-6">Connect wallet to view and manage offers</p>
                    <button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button>
                </div>
                <div id="offersContainer" class="hidden space-y-8">
                    <div class="glass-card p-12">
                        <div class="flex justify-between items-center mb-8">
                            <div>
                                <h2 class="orbitron text-4xl font-black uppercase italic text-purple-500">Offers</h2>
                                <p class="fira text-sm text-gray-500 mt-2">Make offers on NFTs and manage incoming offers</p>
                            </div>
                            <button onclick="window.loadOffers()" class="btn-primary px-8">
                                <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Refresh
                            </button>
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                            <div class="space-y-4">
                                <h3 class="orbitron text-lg font-bold text-cyan-400 uppercase tracking-widest">Offers on My NFTs</h3>
                                <p class="fira text-xs text-gray-500">Offers others have made on NFTs you own</p>
                                <div id="offersOnMyNFTsList" class="space-y-4 min-h-[120px]">
                                    <p class="text-gray-500 fira text-sm py-8 text-center">No offers on your NFTs yet</p>
                                </div>
                            </div>
                            <div class="space-y-4">
                                <h3 class="orbitron text-lg font-bold text-magenta-400 uppercase tracking-widest">My Offers</h3>
                                <p class="fira text-xs text-gray-500">Offers you have made on others' NFTs</p>
                                <div id="myOffersList" class="space-y-4 min-h-[120px]">
                                    <p class="text-gray-500 fira text-sm py-8 text-center">No offers made yet</p>
                                </div>
                            </div>
                        </div>
                        <div class="mt-8 p-4 bg-cyan-500/10 border border-cyan-500/20 rounded-lg">
                            <p class="fira text-xs text-cyan-300">
                                <strong>How to make an offer:</strong> Go to Explorer ‚Üí click a collection ‚Üí find an unlisted NFT ‚Üí click "üí∞ Make Offer"
                            </p>
                        </div>
                    </div>
                </div>
                </div><!-- End hidden offers content -->
            </section>

            <!-- AUCTIONS PAGE -->
            <section id="tab-auctions" class="tab-content animate-view hidden space-y-8">
                <div class="space-y-4">
                    <h2 class="orbitron text-4xl font-black uppercase italic text-cyan-400">üé™ Live Auctions</h2>
                    <p class="fira text-sm text-gray-400">Time-limited bidding on exclusive NFTs</p>
                </div>
                
                <div id="auctionsGrid" class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Auctions render here -->
                    <div class="col-span-full text-center py-12 text-gray-500 fira text-sm">
                        No active auctions
                    </div>
                </div>
            </section>

            <!-- ALL COLLECTIONS PAGE -->
            <section id="tab-all-collections" class="tab-content animate-view hidden space-y-8">
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <div>
                            <button onclick="window.switchTab('market')" class="text-[10px] orbitron text-cyan-400 uppercase font-black hover:text-white transition-colors mb-3 block">‚Üê Back to Explorer</button>
                            <h2 class="orbitron text-4xl font-black uppercase italic text-cyan-400">All Collections</h2>
                            <p class="fira text-sm text-gray-400 mt-1">Browse every collection on PunkSwap</p>
                        </div>
                        <div class="flex gap-3">
                            <input type="text" id="allCollectionsSearch" placeholder="Search collections..." 
                                   oninput="window.filterAllCollections(this.value)"
                                   class="bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-2 text-sm text-white fira outline-none focus:border-cyan-500 w-64">
                            <button onclick="window.loadCollections(); window.renderAllCollections(); window.notify('Refreshed!', 'success');" 
                                    class="px-4 py-2 bg-cyan-500/10 border border-cyan-500/30 text-cyan-400 rounded-lg text-xs orbitron font-bold hover:bg-cyan-500/20 transition-all">
                                üîÑ Refresh
                            </button>
                        </div>
                    </div>
                </div>
                <div class="flex gap-3 text-xs orbitron font-bold">
                    <button onclick="window.sortAllCollections('volume')" id="sortVolume" class="px-3 py-1.5 bg-cyan-500/20 text-cyan-400 rounded-lg transition-all">üìä Volume</button>
                    <button onclick="window.sortAllCollections('floor')" id="sortFloor" class="px-3 py-1.5 bg-black/20 text-gray-500 rounded-lg transition-all hover:text-white">üíé Floor</button>
                    <button onclick="window.sortAllCollections('listed')" id="sortListed" class="px-3 py-1.5 bg-black/20 text-gray-500 rounded-lg transition-all hover:text-white">üìã Listed</button>
                    <button onclick="window.sortAllCollections('newest')" id="sortNewest" class="px-3 py-1.5 bg-black/20 text-gray-500 rounded-lg transition-all hover:text-white">üÜï Newest</button>
                </div>
                <div id="allCollectionsGrid" class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-6"></div>
            </section>

            <!-- ACTIVITY FEED PAGE -->
            <section id="tab-activity" class="tab-content animate-view hidden space-y-8">
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <h2 class="orbitron text-4xl font-black uppercase italic text-cyan-400">Activity Feed</h2>
                        <div class="text-xs orbitron text-gray-500 uppercase">Live ‚Ä¢ Last 24 hours</div>
                    </div>
                    <p class="fira text-sm text-gray-400">Real-time marketplace activity</p>
                </div>
                
                <div class="glass-card p-8 space-y-4">
                    <div id="activityFeedContainer" class="space-y-2">
                        <!-- Activity items render here -->
                        <div class="text-center py-12 text-gray-500 fira text-sm">
                            Loading activity...
                        </div>
                    </div>
                </div>
            </section>

            <!-- Admin/Forge Hub -->
            <section id="tab-admin" class="tab-content animate-view hidden space-y-8">
                <div id="adminGate" class="auth-gate glass-card p-16 text-center border-cyan-500/10"><h2 class="orbitron text-2xl font-black uppercase text-cyan-400 mb-4 italic">Administrative Check</h2><button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button></div>
                
                <!-- UI WIPE & RELOAD PANEL -->
                <div id="uiWipePanel" class="hidden glass-card p-8 space-y-6 border-red-500/20">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="orbitron text-xl text-red-400 uppercase font-black italic">‚ö†Ô∏è UI Reset Panel</h3>
                            <p class="fira text-xs text-gray-500 mt-2">Force sync UI with database (use after database wipe)</p>
                        </div>
                        <div class="text-right">
                            <div class="orbitron text-xs text-gray-500 uppercase">Cached Items</div>
                            <div class="orbitron text-2xl text-cyan-400 font-black" id="cachedItemsCount">0</div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-3 gap-4">
                        <div class="bg-black/40 p-4 rounded-lg border border-white/5 text-center">
                            <div class="orbitron text-xs text-gray-500 uppercase mb-2">NFTs</div>
                            <div class="text-2xl text-white font-bold" id="cachedNFTsCount">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-white/5 text-center">
                            <div class="orbitron text-xs text-gray-500 uppercase mb-2">Collections</div>
                            <div class="text-2xl text-white font-bold" id="cachedCollectionsCount">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-white/5 text-center">
                            <div class="orbitron text-xs text-gray-500 uppercase mb-2">Transactions</div>
                            <div class="text-2xl text-white font-bold" id="cachedTransactionsCount">0</div>
                        </div>
                    </div>
                    
                    <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                        <div class="flex items-start gap-3">
                            <span class="text-yellow-500 text-xl">‚ö†Ô∏è</span>
                            <div class="fira text-xs text-yellow-200">
                                <p class="font-bold mb-1">Warning: This will clear all cached UI data</p>
                                <p>Use this when you've wiped the database and need to force the UI to reload fresh data. All Firestore listeners will be reset.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex gap-4">
                        <button onclick="window.wipeUIAndReload(false)" class="flex-1 p-4 rounded-lg border-2 border-cyan-500/30 text-cyan-400 orbitron text-sm font-bold uppercase hover:bg-cyan-500/10 transition-all">
                            üîÑ Soft Reload
                        </button>
                        <button onclick="window.wipeUIAndReload(true)" class="flex-1 p-4 rounded-lg border-2 border-red-500 text-red-400 orbitron text-sm font-bold uppercase hover:bg-red-500/10 transition-all">
                            üí• Hard Wipe & Reload
                        </button>
                    </div>
                    
                    <!-- FIREBASE DATABASE WIPE BUTTON -->
                    <div class="bg-red-900/20 border-2 border-red-600 rounded-lg p-6">
                        <div class="flex items-center gap-3 mb-4">
                            <span class="text-3xl">üî•</span>
                            <div>
                                <div class="orbitron text-lg text-red-400 font-black uppercase">Nuclear Option</div>
                                <div class="fira text-xs text-red-300">Wipe Firebase Database + UI Cache</div>
                            </div>
                        </div>
                        <div class="bg-red-950/50 border border-red-700/50 rounded p-3 mb-4">
                            <p class="fira text-xs text-red-200">
                                <strong>‚ö†Ô∏è DANGER:</strong> This will permanently delete ALL NFTs, transactions, offers, bids, auctions, and comments from Firebase. Collections/whitelists will be preserved but counters reset to 0.
                            </p>
                        </div>
                        <button onclick="window.autoWipeFirebaseDatabase()" class="w-full p-4 rounded-lg bg-red-600 hover:bg-red-700 border-2 border-red-400 text-white orbitron text-sm font-black uppercase transition-all shadow-lg shadow-red-900/50">
                            üî• WIPE FIREBASE DATABASE
                        </button>
                    </div>
                    
                    <div class="flex gap-4">
                        <button onclick="window.forceSyncCollections()" class="flex-1 p-3 rounded-lg border border-purple-500/30 text-purple-400 orbitron text-xs font-bold uppercase hover:bg-purple-500/10 transition-all">
                            üîÑ Force Sync Collections
                        </button>
                        <button onclick="window.clearGhostData()" class="flex-1 p-3 rounded-lg border border-orange-500/30 text-orange-400 orbitron text-xs font-bold uppercase hover:bg-orange-500/10 transition-all">
                            üëª Clear Ghost Data
                        </button>
                    </div>
                    
                    <div class="text-center">
                        <button onclick="window.hardRefreshPage()" class="text-xs orbitron text-gray-500 uppercase hover:text-white transition-colors">
                            Or click here for full page refresh (F5)
                        </button>
                    </div>
                </div>
                
                <!-- DATABASE WIPE PANEL -->
                <div id="databaseWipePanel" class="hidden glass-card p-8 space-y-6 border-red-500/30">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="orbitron text-2xl text-red-500 uppercase font-black italic">üóëÔ∏è Database Wipe</h3>
                            <p class="fira text-xs text-gray-500 mt-2">Clear all marketplace data and start fresh</p>
                        </div>
                        <div class="text-right">
                            <div class="orbitron text-xs text-gray-500 uppercase">Escrow Only</div>
                            <div class="orbitron text-sm text-red-400 font-black">DANGER ZONE</div>
                        </div>
                    </div>
                    
                    <div class="bg-red-500/10 border border-red-500/30 rounded-lg p-6">
                        <div class="flex items-start gap-3">
                            <span class="text-red-500 text-3xl">‚ö†Ô∏è</span>
                            <div class="fira text-sm text-red-200 space-y-2">
                                <p class="font-bold text-lg">This will PERMANENTLY delete:</p>
                                <ul class="space-y-1 ml-4">
                                    <li>‚Ä¢ All NFTs from marketplace</li>
                                    <li>‚Ä¢ All collections</li>
                                    <li>‚Ä¢ All transactions</li>
                                    <li>‚Ä¢ All offers</li>
                                    <li>‚Ä¢ All whitelist settings</li>
                                    <li>‚Ä¢ All trait counts</li>
                                    <li>‚Ä¢ All wallet tracking data</li>
                                </ul>
                                <p class="font-bold text-yellow-300 mt-3">‚ö° This DOES NOT affect blockchain tokens!</p>
                                <p class="text-xs text-gray-400">NFTs will remain in user wallets - only marketplace data is cleared.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="space-y-4">
                        <div class="bg-black/60 p-6 rounded-lg border border-white/10 space-y-3">
                            <h4 class="orbitron text-sm text-cyan-400 uppercase font-bold">What happens:</h4>
                            <div class="fira text-xs text-gray-300 space-y-2">
                                <p>1Ô∏è‚É£ Deletes all documents from Firebase collections</p>
                                <p>2Ô∏è‚É£ Clears UI cache and state</p>
                                <p>3Ô∏è‚É£ Reloads the page with fresh empty marketplace</p>
                                <p>4Ô∏è‚É£ Ready to create new collections from scratch</p>
                            </div>
                        </div>
                        
                        <div class="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
                            <div class="flex items-start gap-3">
                                <span class="text-green-500 text-xl">‚úÖ</span>
                                <div class="fira text-xs text-green-200">
                                    <p class="font-bold mb-1">Safe Operation</p>
                                    <p>This only deletes Firebase data. Your Firebase structure and rules remain intact. No blockchain tokens are affected.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="space-y-3">
                        <button onclick="window.confirmDatabaseWipe()" class="w-full p-6 rounded-lg border-2 border-red-500 text-red-400 orbitron text-lg font-bold uppercase hover:bg-red-500/20 transition-all">
                            üóëÔ∏è WIPE ALL MARKETPLACE DATA
                        </button>
                        <p class="text-center fira text-xs text-gray-600">You will be asked to confirm before deletion</p>
                    </div>
                </div>
                
                <div id="forgeContainer" class="hidden space-y-10">
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-10">
                        <div class="lg:col-span-2 glass-card p-12 space-y-10">
                            <div class="flex justify-between items-start">
                                <h3 class="orbitron text-2xl text-cyan-400 uppercase font-black italic">Collection Forge Hub</h3>
                                <div class="forge-mini-preview" id="previewImageContainer"></div>
                            </div>
                            <div class="space-y-6">
                                <input type="text" id="collectionTitleInput" placeholder="COLLECTION TITLE (Required - e.g., 'Series Protocol Alpha')" class="w-full bg-black/60 border border-cyan-500/30 p-5 rounded-xl fira text-sm text-cyan-400 outline-none font-bold">
                                
                                <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                                    <span class="text-[8px] orbitron text-cyan-400 uppercase font-black block mb-3">Collection Type</span>
                                    <div class="flex gap-3">
                                        <label class="flex-1 cursor-pointer">
                                            <input type="radio" name="collectionType" value="external_ipfs" checked class="hidden peer">
                                            <div class="p-3 rounded-lg border border-white/10 peer-checked:border-cyan-500 peer-checked:bg-cyan-500/10 transition-all">
                                                <div class="orbitron text-xs font-bold text-white">External IPFS</div>
                                                <div class="fira text-[9px] text-gray-500 mt-1">Bueno/Pinata metadata</div>
                                            </div>
                                        </label>
                                    </div>
                                </div>
                                
                                <input type="text" id="batchFolderCid" placeholder="IPFS PROTOCOL CID (bafy...)" class="w-full bg-black/60 border border-white/5 p-5 rounded-xl fira text-xs text-cyan-400 outline-none">
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                                        <span class="text-[8px] orbitron text-cyan-400 uppercase font-black block mb-2">Total Supply</span>
                                        <input type="number" id="totalSupplyInput" value="10" min="1" max="1000" class="w-full bg-transparent fira text-lg font-bold outline-none text-white">
                                    </div>
                                    <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                                        <span class="text-[8px] orbitron text-orange-400 uppercase font-black block mb-2">Max Per Wallet</span>
                                        <input type="number" id="maxMintsPerWalletInput" value="1" min="1" max="10" class="w-full bg-transparent fira text-lg font-bold outline-none text-white">
                                    </div>
                                </div>
                                <textarea id="collectionDescInput" placeholder="Narrative summary for this unit series..." class="w-full h-24 bg-black/40 border border-white/5 p-4 rounded-xl fira text-xs text-gray-500 outline-none resize-none"></textarea>
                                <input type="text" id="collectionThumbnailInput" placeholder="Collection Thumbnail CID (The Grid Icon)..." class="w-full bg-black/60 border border-white/5 p-4 rounded-xl fira text-xs text-white outline-none">

                                <div class="flex justify-between items-center">
                                    <div class="flex gap-2" id="priceModeMatrix">
                                        <button onclick="window.setPriceMode('kta')" id="mode-kta" class="price-mode-btn active">KTA Only</button>
                                        <button onclick="window.setPriceMode('punks')" id="mode-punks" class="price-mode-btn">PUNKS Only</button>
                                        <button onclick="window.setPriceMode('hybrid')" id="mode-hybrid" class="price-mode-btn">Hybrid</button>
                                    </div>
                                    <div class="flex items-center gap-4">
                                        <span class="orbitron text-[10px] text-gray-500 uppercase font-black">Blind Mint</span>
                                        <label class="cyber-switch"><input type="checkbox" id="enableDropMode" checked><span class="slider"></span></label>
                                    </div>
                                </div>
                                
                                <div class="grid grid-cols-2 gap-6">
                                    <div id="ktaInputBox" class="bg-black/60 p-5 rounded-xl border border-white/5">
                                        <span class="text-[8px] orbitron text-cyan-400 uppercase font-black">KTA Base Price</span>
                                        <input type="number" id="batchPriceKTA" value="1.0" step="0.1" class="w-full bg-transparent fira text-xl font-bold outline-none text-white mt-1">
                                    </div>
                                    <div id="punksInputBox" class="bg-black/60 p-5 rounded-xl border border-white/5 opacity-20">
                                        <span class="text-[8px] orbitron text-magenta-400 uppercase font-black">PUNKS Base Price</span>
                                        <input type="number" id="batchPricePunks" value="1000" class="w-full bg-transparent fira text-xl font-bold outline-none text-white mt-1">
                                    </div>
                                </div>
                                
                                <!-- CREATOR ROYALTY PERCENTAGE -->
                                <div class="bg-gradient-to-br from-green-900/20 to-emerald-900/20 p-6 rounded-xl border border-green-500/30 space-y-3">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <span class="text-sm orbitron text-green-400 uppercase font-bold block">Creator Royalty %</span>
                                            <span class="text-[9px] fira text-gray-500 block mt-1">You earn this % on every secondary sale</span>
                                        </div>
                                        <div class="text-right">
                                            <span class="text-3xl orbitron text-green-400 font-black" id="royaltyDisplay">5.0</span>
                                            <span class="text-lg orbitron text-green-400">%</span>
                                        </div>
                                    </div>
                                    <input type="range" id="creatorRoyaltyPercent" min="0" max="20" step="0.5" value="5" 
                                           class="w-full h-2 bg-black/60 rounded-lg appearance-none cursor-pointer accent-green-500"
                                           oninput="document.getElementById('royaltyDisplay').textContent = this.value; document.getElementById('royaltyExample').textContent = this.value">
                                    <div class="flex justify-between text-[8px] fira text-gray-500">
                                        <span>0% (No Royalty)</span>
                                        <span class="text-yellow-400">5% (Default)</span>
                                        <span>10% (Premium)</span>
                                        <span>20% (Max)</span>
                                    </div>
                                    <div class="bg-black/40 p-3 rounded-lg border border-green-500/20">
                                        <div class="fira text-[9px] text-gray-400 space-y-1">
                                            <div class="flex justify-between">
                                                <span>If NFT sells for 100 KTA:</span>
                                                <span class="text-white font-bold"></span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span>‚Ä¢ Seller gets:</span>
                                                <span class="text-cyan-400 font-bold">92 KTA (92%)</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span>‚Ä¢ You (creator) get:</span>
                                                <span class="text-green-400 font-bold"><span id="royaltyExample">5</span> KTA</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span>‚Ä¢ Marketplace gets:</span>
                                                <span class="text-purple-400 font-bold">3 KTA (3%)</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button onclick="window.scanCollectionFolder()" class="btn-primary py-5 text-sm w-full">Validate Protocol Matrix</button>
                                <div id="forgeReadyArea" class="hidden animate-view"><button id="startForgeBtn" onclick="window.createBlindMintCollection()" class="btn-primary py-10 text-xl border-orange-500 text-orange-500 border-2 w-full">Deploy Blind Mint Collection</button></div>
                            </div>
                        </div>
                        <div class="space-y-8">
                            <!-- Reserve NFTs Panel (Creator Only) -->
                            <div class="glass-card p-10 space-y-6 border-purple-500/20">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="flex items-center gap-2">
                                            <h4 class="orbitron text-[10px] text-purple-400 font-bold uppercase tracking-widest">üéÅ Reserve NFTs</h4>
                                            <span class="px-2 py-0.5 bg-red-500/20 border border-red-500/30 rounded text-[8px] text-red-400 orbitron font-bold">üîí LOCKED</span>
                                        </div>
                                        <p class="fira text-[9px] text-gray-500 mt-1">Mint to your wallet for giveaways, auctions & reserves</p>
                                    </div>
                                    <button onclick="window.loadCollections()" class="text-purple-400 hover:text-purple-300 text-xs orbitron">üîÑ Refresh</button>
                                </div>
                                
                                <div id="preMintCollectionsContainer" class="space-y-3">
                                    <!-- Will be populated by renderPreMintCollections() -->
                                </div>
                            </div>
                            
                            <!-- My Whitelists Panel -->
                            <div class="glass-card p-10 space-y-6 border-cyan-500/20">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <h4 class="orbitron text-[10px] text-cyan-400 font-bold uppercase tracking-widest">My Active Whitelists</h4>
                                        <p class="fira text-[9px] text-gray-500 mt-1">Collections you've configured with whitelist settings</p>
                                    </div>
                                    <button onclick="window.refreshMyWhitelists()" class="text-cyan-400 hover:text-cyan-300 text-xs orbitron">üîÑ Refresh</button>
                                </div>
                                
                                <div id="myWhitelistsContainer" class="space-y-3">
                                    <div class="text-center py-8 text-gray-600 fira text-sm">
                                        Loading...
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Collection Verification Panel (Admin Only) -->
                            <div id="verificationPanel" class="hidden glass-card p-10 space-y-6 border-blue-500/20">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <h4 class="orbitron text-[10px] text-blue-400 font-bold uppercase tracking-widest">‚úÖ Collection Verification</h4>
                                        <p class="fira text-[9px] text-gray-500 mt-1">Add or remove verified badges (Escrow Only)</p>
                                    </div>
                                    <div class="bg-blue-500/10 px-3 py-1 rounded text-[9px] orbitron text-blue-400 font-bold">ADMIN</div>
                                </div>
                                
                                <div>
                                    <label class="block text-[9px] orbitron text-blue-400 uppercase font-black mb-2">Select Collection</label>
                                    <select id="verifyCollectionSelector" class="w-full bg-black/60 border border-blue-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none">
                                        <option value="">-- Select a Collection --</option>
                                    </select>
                                </div>
                                
                                <div id="verificationControls" class="hidden space-y-3">
                                    <div class="bg-blue-900/20 border border-blue-500/30 p-4 rounded-lg">
                                        <div class="text-sm text-blue-400 font-bold mb-2">‚ÑπÔ∏è About Verification</div>
                                        <div class="text-xs text-gray-400 space-y-1">
                                            <div>‚Ä¢ Blue checkmark shows collection is authentic</div>
                                            <div>‚Ä¢ Increases buyer confidence and trust</div>
                                            <div>‚Ä¢ Only escrow wallet can verify</div>
                                            <div>‚Ä¢ Visible on all collection cards</div>
                                        </div>
                                    </div>
                                    
                                    <div class="flex gap-3">
                                        <button id="verifyBtn" onclick="window.verifyCollectionFromPanel()" class="flex-1 bg-blue-500/20 border-2 border-blue-500/50 text-blue-400 p-4 rounded-xl orbitron font-bold hover:bg-blue-500/30 transition-all">
                                            ‚úÖ Verify Collection
                                        </button>
                                        <button id="unverifyBtn" onclick="window.unverifyCollectionFromPanel()" class="flex-1 bg-red-500/20 border-2 border-red-500/50 text-red-400 p-4 rounded-xl orbitron font-bold hover:bg-red-500/30 transition-all">
                                            üóëÔ∏è Remove Verification
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Whitelist Settings Panel -->
                            <div class="glass-card p-10 space-y-6 border-purple-500/20">
                                <div class="flex justify-between items-center">
                                    <h4 class="orbitron text-[10px] text-purple-500 font-bold uppercase tracking-widest">Whitelist Settings</h4>
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="whitelistEnabled" class="w-4 h-4 accent-purple-500" onchange="window.toggleWhitelistSettingsUI()">
                                        <span class="fira text-xs text-gray-400">Enable Whitelist</span>
                                    </label>
                                </div>
                                
                                <!-- Collection Selector -->
                                <div>
                                    <label class="block text-[9px] orbitron text-cyan-400 uppercase font-black mb-2">Select Collection</label>
                                    <select id="whitelistCollectionSelector" onchange="window.loadWhitelistSettings(this.value)" class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none">
                                        <option value="">-- Select a Collection --</option>
                                    </select>
                                    <p class="text-[9px] fira text-gray-500 mt-2">Select a collection to configure its whitelist</p>
                                </div>
                                
                                <div id="whitelistControls" class="hidden space-y-6">
                                    <!-- Enable/Disable Toggle -->
                                    <div class="bg-gradient-to-r from-purple-900/20 to-pink-900/20 p-6 rounded-xl border border-purple-500/30">
                                        <div class="flex items-center justify-between">
                                            <div>
                                                <h5 class="orbitron text-sm text-purple-400 uppercase font-black">Whitelist Enabled</h5>
                                                <p class="fira text-[10px] text-gray-500 mt-1">Only wallets in phases below can mint</p>
                                            </div>
                                            <label class="cyber-switch">
                                                <input type="checkbox" id="whitelistEnabled" onchange="window.toggleWhitelistSettingsUI()">
                                                <span class="slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    
                                    <!-- WHITELIST PHASES -->
                                    <div class="bg-gradient-to-br from-purple-900/20 to-pink-900/20 p-6 rounded-xl border border-purple-500/30 space-y-4">
                                        <div class="flex items-center justify-between">
                                            <div>
                                                <h5 class="orbitron text-[10px] text-purple-400 uppercase font-black">Whitelist Phases</h5>
                                                <p class="fira text-[9px] text-gray-500 mt-1">Create phases with custom pricing for different wallet groups</p>
                                            </div>
                                            <button onclick="window.addWhitelistPhase()" class="text-xs px-4 py-2 rounded bg-purple-500/20 text-purple-400 hover:bg-purple-500/30 transition-all orbitron font-bold">+ Add Phase</button>
                                        </div>
                                        
                                        <div id="whitelistPhasesContainer" class="space-y-3 mt-4">
                                            <!-- Phases will be added here -->
                                        </div>
                                        
                                        <div class="bg-cyan-500/10 border border-cyan-500/20 rounded-lg p-4 mt-4">
                                            <p class="fira text-[9px] text-cyan-300 leading-relaxed">
                                                üí° <strong>How it works:</strong> Each phase can have a different mint price. Add your wallet addresses to each phase (comma-separated). Wallets can be in multiple phases.
                                            </p>
                                        </div>
                                    </div>
                                    
                                    <!-- Warnings -->
                                    <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4">
                                        <div class="flex items-start gap-3">
                                            <span class="text-yellow-500 text-xl">‚ö†Ô∏è</span>
                                            <div class="fira text-[10px] text-yellow-200 space-y-1">
                                                <p>‚Ä¢ Click "Save Whitelist Settings" below after making changes</p>
                                                <p>‚Ä¢ Whitelist only controls WHO can mint, not WHAT they get (blind mint is still random)</p>
                                                <p>‚Ä¢ Public mint resumes when whitelist is disabled</p>
                                                <p>‚Ä¢ You cannot bypass mint logic or assign specific NFTs</p>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Save Button -->
                                    <button onclick="window.saveWhitelistSettings()" class="btn-primary w-full py-4">üíæ Save Whitelist Settings</button>
                                </div>
                            </div>
                            
                            <div id="escrowDiagnostics" class="glass-card p-10 space-y-6 hidden">
                                <h4 class="orbitron text-[10px] text-orange-500 font-bold uppercase tracking-widest">Escrow Diagnostics</h4>
                                <button onclick="window.runNeuralRepair()" class="w-full p-4 rounded-xl border border-purple-500/20 text-[9px] orbitron font-bold uppercase text-purple-400 hover:bg-purple-500/5 transition-all text-center">Neural Sync Recovery</button>
                                <div id="previewDetails" class="hidden p-4 bg-black/40 rounded-xl fira text-[10px]"><div class="flex justify-between"><span>POPULATION:</span><span id="previewCount">0</span></div></div>
                            </div>
                            <div id="escrowMaintenanceProtocol" class="glass-card p-10 border-red-500/20 bg-red-500/5 animate-view hidden">
                                <h4 class="orbitron text-[9px] text-red-500 font-black uppercase mb-4 tracking-widest">Admin Wipe Protocol</h4>
                                <div id="wipeStage1"><button onclick="window.prepWipe()" class="w-full p-4 border border-red-500/20 text-[9px] text-red-500 orbitron uppercase font-black hover:bg-red-500/10 transition-all">Database Purge</button></div>
                                <div id="wipeStage2" class="hidden flex gap-2"><button onclick="window.clearAllNFTs()" class="btn-primary flex-1 !border-red-500 !text-red-500 font-black">Confirm Wipe</button><button onclick="window.resetWipe()" class="flex-1 text-[9px] orbitron font-bold text-gray-500 uppercase">Abort</button></div>
                            </div>
                        </div>
                    </div>
                    <div id="batchProgress" class="hidden glass-card p-8 space-y-6 border-cyan-500/20"><div class="flex justify-between fira text-xs font-bold uppercase"><span id="batchStatusMsg" class="text-cyan-400 animate-pulse">Forging...</span><span id="batchPercent">0%</span></div><div class="w-full bg-black/60 h-1 rounded-full overflow-hidden border border-white/5"><div id="batchProgressInner" class="bg-gradient-to-r from-cyan-500 to-purple-500 h-full transition-all duration-300"></div></div><div id="neuralDebugLog" class="debug-log"></div></div>
                </div>
                
            </section>
            
            <!-- ESCROW OVERSIGHT TAB -->
            <section id="tab-escrow-admin" class="tab-content animate-view hidden space-y-8">
                <div id="escrowAdminGate" class="auth-gate glass-card p-16 text-center border-purple-500/10">
                    <h2 class="orbitron text-2xl font-black uppercase text-purple-400 mb-4 italic">Escrow Oversight</h2>
                    <p class="fira text-sm text-gray-500 mb-6">Escrow wallet required</p>
                    <button onclick="window.initNeuralLink()" class="btn-primary px-12">Initialize Sign-In</button>
                </div>
                
                <div id="escrowAdminContent" class="hidden space-y-6">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="orbitron text-xl text-purple-400 uppercase font-black italic">üìä Escrow & Fee Tracker</h3>
                            <p class="fira text-xs text-gray-500 mt-2">All transactions, fees, royalties, and escrow activity</p>
                        </div>
                        <div class="flex gap-3">
                            <button onclick="window.loadEscrowStats()" class="px-4 py-2 bg-cyan-500/10 border border-cyan-500/30 rounded-lg text-cyan-400 text-xs orbitron font-bold hover:bg-cyan-500/20 transition-all">üîÑ Refresh</button>
                            <button onclick="window.exportEscrowCSV()" class="px-4 py-2 bg-purple-500/10 border border-purple-500/30 rounded-lg text-purple-400 text-xs orbitron font-bold hover:bg-purple-500/20 transition-all">üì• Export CSV</button>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
                        <div class="bg-black/40 p-4 rounded-lg border border-white/5 text-center">
                            <div class="orbitron text-[9px] text-gray-500 uppercase mb-1">Total Sales</div>
                            <div class="text-xl text-white font-bold" id="escrowTotalSales">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-cyan-500/10 text-center">
                            <div class="orbitron text-[9px] text-cyan-400 uppercase mb-1">KTA Volume</div>
                            <div class="text-lg text-cyan-400 font-bold" id="escrowTotalVolumeKTA">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-fuchsia-500/10 text-center">
                            <div class="orbitron text-[9px] text-fuchsia-400 uppercase mb-1">PUNKS Volume</div>
                            <div class="text-lg text-fuchsia-400 font-bold" id="escrowTotalVolumePUNKS">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-green-500/10 text-center">
                            <div class="orbitron text-[9px] text-green-400 uppercase mb-1">KTA Fees Earned</div>
                            <div class="text-lg text-green-400 font-bold" id="escrowTotalFeesKTA">0</div>
                        </div>
                        <div class="bg-black/40 p-4 rounded-lg border border-green-500/10 text-center">
                            <div class="orbitron text-[9px] text-green-400 uppercase mb-1">PUNKS Fees Earned</div>
                            <div class="text-lg text-green-400 font-bold" id="escrowTotalFeesPUNKS">0</div>
                        </div>
                    </div>
                    
                    <!-- Escrow Wallet Balances -->
                    <div class="grid grid-cols-2 gap-4">
                        <div class="bg-gradient-to-r from-cyan-500/5 to-transparent p-4 rounded-lg border border-cyan-500/20 flex items-center justify-between">
                            <div>
                                <div class="orbitron text-[9px] text-cyan-400/70 uppercase">Escrow KTA Balance</div>
                                <div class="text-xl text-cyan-400 font-bold mt-1" id="escrowBalanceKTA">0</div>
                            </div>
                            <div class="text-3xl opacity-30">üíé</div>
                        </div>
                        <div class="bg-gradient-to-r from-fuchsia-500/5 to-transparent p-4 rounded-lg border border-fuchsia-500/20 flex items-center justify-between">
                            <div>
                                <div class="orbitron text-[9px] text-fuchsia-400/70 uppercase">Escrow PUNKS Balance</div>
                                <div class="text-xl text-fuchsia-400 font-bold mt-1" id="escrowBalancePUNKS">0</div>
                            </div>
                            <div class="text-3xl opacity-30">ü¶Ö</div>
                        </div>
                    </div>
                    
                    <!-- KTA Section -->
                    <div class="bg-black/30 rounded-xl border border-cyan-500/15 overflow-hidden">
                        <div class="bg-cyan-500/10 px-4 py-3 border-b border-cyan-500/15 flex items-center gap-2">
                            <span class="text-lg">üíé</span>
                            <span class="orbitron text-sm text-cyan-400 uppercase font-black">KTA Breakdown</span>
                        </div>
                        <div class="grid grid-cols-2 gap-4 p-4">
                            <div class="bg-black/40 p-4 rounded-lg border border-cyan-500/10">
                                <div class="orbitron text-xs text-cyan-400 uppercase font-bold mb-3">Primary Sales (Mints)</div>
                                <div class="space-y-2 fira text-xs">
                                    <div class="flex justify-between"><span class="text-gray-500">Count:</span><span class="text-white font-bold" id="escrowPrimaryCountKTA">0</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Volume:</span><span class="text-cyan-400 font-bold" id="escrowPrimaryVolumeKTA">0 KTA</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Fees (10%):</span><span class="text-green-400 font-bold" id="escrowPrimaryFeesKTA">0 KTA</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">To Creators (90%):</span><span class="text-purple-400 font-bold" id="escrowPrimaryCreatorKTA">0 KTA</span></div>
                                </div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-cyan-500/10">
                                <div class="orbitron text-xs text-cyan-400 uppercase font-bold mb-3">Secondary Sales (Resales)</div>
                                <div class="space-y-2 fira text-xs">
                                    <div class="flex justify-between"><span class="text-gray-500">Count:</span><span class="text-white font-bold" id="escrowSecondaryCountKTA">0</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Volume:</span><span class="text-cyan-400 font-bold" id="escrowSecondaryVolumeKTA">0 KTA</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Fees (3%):</span><span class="text-green-400 font-bold" id="escrowSecondaryFeesKTA">0 KTA</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Royalties (5%):</span><span class="text-purple-400 font-bold" id="escrowSecondaryRoyaltiesKTA">0 KTA</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">To Sellers (92%):</span><span class="text-cyan-300 font-bold" id="escrowSecondarySellerKTA">0 KTA</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- PUNKS Section -->
                    <div class="bg-black/30 rounded-xl border border-fuchsia-500/15 overflow-hidden">
                        <div class="bg-fuchsia-500/10 px-4 py-3 border-b border-fuchsia-500/15 flex items-center gap-2">
                            <span class="text-lg">ü¶Ö</span>
                            <span class="orbitron text-sm text-fuchsia-400 uppercase font-black">PUNKS Breakdown</span>
                        </div>
                        <div class="grid grid-cols-2 gap-4 p-4">
                            <div class="bg-black/40 p-4 rounded-lg border border-fuchsia-500/10">
                                <div class="orbitron text-xs text-fuchsia-400 uppercase font-bold mb-3">Primary Sales (Mints)</div>
                                <div class="space-y-2 fira text-xs">
                                    <div class="flex justify-between"><span class="text-gray-500">Count:</span><span class="text-white font-bold" id="escrowPrimaryCountPUNKS">0</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Volume:</span><span class="text-fuchsia-400 font-bold" id="escrowPrimaryVolumePUNKS">0 PUNKS</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Fees (10%):</span><span class="text-green-400 font-bold" id="escrowPrimaryFeesPUNKS">0 PUNKS</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">To Creators (90%):</span><span class="text-purple-400 font-bold" id="escrowPrimaryCreatorPUNKS">0 PUNKS</span></div>
                                </div>
                            </div>
                            <div class="bg-black/40 p-4 rounded-lg border border-fuchsia-500/10">
                                <div class="orbitron text-xs text-fuchsia-400 uppercase font-bold mb-3">Secondary Sales (Resales)</div>
                                <div class="space-y-2 fira text-xs">
                                    <div class="flex justify-between"><span class="text-gray-500">Count:</span><span class="text-white font-bold" id="escrowSecondaryCountPUNKS">0</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Volume:</span><span class="text-fuchsia-400 font-bold" id="escrowSecondaryVolumePUNKS">0 PUNKS</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Fees (3%):</span><span class="text-green-400 font-bold" id="escrowSecondaryFeesPUNKS">0 PUNKS</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">Royalties (5%):</span><span class="text-purple-400 font-bold" id="escrowSecondaryRoyaltiesPUNKS">0 PUNKS</span></div>
                                    <div class="flex justify-between"><span class="text-gray-500">To Sellers (92%):</span><span class="text-fuchsia-300 font-bold" id="escrowSecondarySellerPUNKS">0 PUNKS</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="orbitron text-sm text-white uppercase font-bold">Transaction Log</h4>
                            <div class="flex gap-2 items-center">
                                <span class="fira text-[9px] text-gray-500" id="escrowTxCount"></span>
                                <select id="escrowTxFilter" onchange="window.filterEscrowTx()" class="bg-black/60 border border-white/10 rounded px-3 py-1 text-xs text-white fira">
                                    <option value="all">All Types</option>
                                    <option value="primary">Primary (Mints)</option>
                                    <option value="secondary">Secondary (Resales)</option>
                                    <option value="listing">Listings</option>
                                    <option value="cancellation">Cancellations</option>
                                </select>
                            </div>
                        </div>
                        <div class="overflow-x-auto max-h-[500px] overflow-y-auto border border-white/5 rounded-lg">
                            <table class="w-full text-xs fira" style="min-width: 1100px;">
                                <thead class="bg-black/60 sticky top-0 z-10">
                                    <tr class="text-gray-500 uppercase text-[9px]">
                                        <th class="p-2 text-left">Date</th>
                                        <th class="p-2 text-left">Type</th>
                                        <th class="p-2 text-left">Status</th>
                                        <th class="p-2 text-left">NFT</th>
                                        <th class="p-2 text-left">Collection</th>
                                        <th class="p-2 text-right">Price</th>
                                        <th class="p-2 text-right">Mkt Fee</th>
                                        <th class="p-2 text-right">Royalty</th>
                                        <th class="p-2 text-right">Seller Got</th>
                                        <th class="p-2 text-left">Buyer</th>
                                        <th class="p-2 text-left">Seller</th>
                                        <th class="p-2 text-left">TX Hash</th>
                                    </tr>
                                </thead>
                                <tbody id="escrowTxBody" class="divide-y divide-white/5"><tr><td colspan="12" class="p-8 text-center text-gray-600">Click Refresh to load data</td></tr></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <!-- Sign-In Modal -->
    <div id="seedModal" class="fixed inset-0 bg-black/95 backdrop-blur-3xl hidden z-[2000] flex items-center justify-center p-12">
        <div class="glass-card p-16 max-w-5xl w-full border-cyan-500/20 shadow-2xl">
            <h2 class="orbitron text-4xl font-black uppercase text-center text-cyan-400 tracking-tighter mb-4 italic">Neural Identity Hub</h2>
            <p class="text-center fira text-[10px] text-gray-600 mb-10 uppercase tracking-widest font-black italic">Matrix Seed Input Required</p>
            <div id="seedGrid" class="grid grid-cols-3 md:grid-cols-6 gap-4 mb-10"></div>
            <div class="flex gap-4 justify-center">
                <button onclick="window.importWallet()" class="btn-primary py-4 px-20 text-lg">Synchronize Link</button>
                <button onclick="window.closeModal('seedModal')" class="text-[9px] orbitron text-gray-700 hover:text-white font-black uppercase tracking-widest px-10 transition-colors">Abort</button>
            </div>
        </div>
    </div>

    <!-- FIX #4: Inline Listing Modal -->
    <div id="listingModal" class="listing-modal-overlay hidden">
        <div class="glass-card p-12 max-w-3xl w-full border-cyan-500/20 shadow-2xl">
            <div class="flex justify-between items-start mb-8">
                <h2 class="orbitron text-2xl font-black uppercase text-cyan-400 tracking-tighter">List NFT for Sale</h2>
                <button onclick="window.closeListingModal()" class="text-gray-500 hover:text-white transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            <div class="grid grid-cols-2 gap-8 mb-8">
                <div>
                    <div id="listingNFTPreview" class="w-full aspect-square bg-black/40 rounded-xl border border-white/10 mb-4 overflow-hidden"></div>
                    <h3 id="listingNFTName" class="orbitron text-lg font-bold text-white mb-2">---</h3>
                    <div id="listingNFTTraits" class="space-y-2"></div>
                </div>
                
                <div class="space-y-6">
                    <div>
                        <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Select Currency</label>
                        <div class="flex gap-3">
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="listingCurrency" value="KTA" checked class="hidden peer" onchange="window.updateFeeBreakdown()">
                                <div class="p-4 rounded-lg border-2 border-cyan-500/30 bg-cyan-500/5 peer-checked:border-cyan-500 peer-checked:bg-cyan-500/20 transition-all text-center hover:border-cyan-500/50">
                                    <div class="orbitron text-sm font-bold text-cyan-400">KTA</div>
                                    <div class="fira text-[9px] text-gray-500 mt-1">Keeta Token</div>
                                </div>
                            </label>
                            <label class="flex-1 cursor-pointer">
                                <input type="radio" name="listingCurrency" value="PUNKS" class="hidden peer" onchange="window.updateFeeBreakdown()">
                                <div class="p-4 rounded-lg border-2 border-magenta-500/30 bg-magenta-500/5 peer-checked:border-magenta-500 peer-checked:bg-magenta-500/20 transition-all text-center hover:border-magenta-500/50">
                                    <div class="orbitron text-sm font-bold text-magenta-400">PUNKS</div>
                                    <div class="fira text-[9px] text-gray-500 mt-1">Punk Token</div>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <div>
                        <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Listing Price</label>
                        <input type="number" id="listingPriceInput" step="0.1" min="0" placeholder="Enter price..." class="w-full bg-black/60 border border-white/5 p-4 rounded-xl fira text-xl text-cyan-400 outline-none font-bold focus:border-cyan-500" oninput="window.updateFeeBreakdown()">
                    </div>
                    
                    <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                        <div class="text-[9px] orbitron text-gray-500 uppercase font-black mb-3">Fee Breakdown</div>
                        <div class="space-y-2 fira text-xs">
                            <div class="flex justify-between">
                                <span class="text-gray-400">You receive</span>
                                <span id="sellerPayout" class="text-white font-bold">0.00</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">Creator royalty (<span id="royaltyPercent">5.0</span>%)</span>
                                <span id="creatorRoyalty" class="text-cyan-400 font-bold">0.00</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-400">Marketplace fee (3%)</span>
                                <span id="marketplaceFee" class="text-purple-400 font-bold">0.00</span>
                            </div>
                        </div>
                    </div>
                    
                    <button onclick="window.confirmListing()" class="btn-primary w-full py-4 text-sm">Confirm Listing</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- AIRDROP ADMIN PANEL -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <section id="tab-airdrop" class="tab-content animate-view hidden space-y-8">
        <!-- Passcode Protection -->
        <div id="airdropPasscodeGate" class="flex items-center justify-center min-h-[60vh]">
            <div class="glass-card p-8 max-w-md w-full">
                <div class="text-center mb-6">
                    <div class="text-6xl mb-4">üîí</div>
                    <h2 class="orbitron text-2xl font-bold text-white mb-2">Airdrop Access</h2>
                    <p class="fira text-sm text-gray-400">Enter passcode to access airdrop controls</p>
                </div>
                
                <div class="space-y-4">
                    <input type="password" id="airdropPasscodeInput" placeholder="Enter passcode" 
                        class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white fira text-center text-lg outline-none focus:border-cyan-500 font-mono"
                        onkeypress="if(event.key === 'Enter') window.verifyAirdropPasscode()">
                    
                    <button onclick="window.verifyAirdropPasscode()" class="btn-primary w-full py-3">
                        üîì Unlock Airdrop
                    </button>
                    
                    <p id="airdropPasscodeError" class="text-red-400 text-sm text-center hidden"></p>
                </div>
            </div>
        </div>

        <!-- Airdrop Content (Hidden until unlocked) -->
        <div id="airdropContent" class="hidden">
        <div class="flex items-center justify-between mb-8">
            <div>
                <h2 class="orbitron text-2xl font-bold text-white mb-2">üéÅ Airdrop Control</h2>
                <p class="fira text-sm text-gray-400">Send pre-owned NFTs to their rightful owners</p>
                <p class="fira text-xs text-yellow-500 mt-1">‚ö†Ô∏è Only for non-blind-mint collections</p>
            </div>
        </div>

        <!-- Collection Selector -->
        <div class="glass-card p-6">
            <h3 class="orbitron text-lg font-bold text-cyan-400 mb-4">Select Collection</h3>
            <select id="airdropCollectionSelect" onchange="window.loadAirdropCollection()" class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-cyan-500">
                <option value="">-- Select a collection --</option>
            </select>
            <div id="airdropCollectionInfo" class="hidden mt-4 p-4 bg-cyan-500/10 border border-cyan-500/30 rounded-lg">
                <div class="flex justify-between items-center">
                    <div>
                        <p class="orbitron text-sm text-cyan-400 font-bold" id="airdropCollectionName"></p>
                        <p class="fira text-xs text-gray-400 mt-1">
                            <span id="airdropMintedCount">0</span>/<span id="airdropTotalSupply">0</span> Minted | 
                            <span id="airdropRemainingSupply">0</span> Remaining
                        </p>
                    </div>
                    <div class="text-right">
                        <p class="text-xs text-gray-500">Your Collection</p>
                        <p class="text-xs text-green-400 font-mono" id="airdropCreatorAddress"></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Airdrop Options -->
        <div id="airdropOptionsSection" class="hidden space-y-6">
            <!-- Single Airdrop -->
            <div class="glass-card p-6">
                <h3 class="orbitron text-lg font-bold text-purple-400 mb-4">Single Airdrop</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-xs orbitron text-gray-400 uppercase font-bold mb-2">Recipient Wallet Address</label>
                        <input type="text" id="airdropRecipient" placeholder="keeta_aab5o4wtbzgfvrsxntftzsecq2l7daek2mzsbni6fc43et5v7r4ihgpn4pv3nra" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-purple-500 font-mono">
                    </div>
                    
                    <div>
                        <label class="block text-xs orbitron text-gray-400 uppercase font-bold mb-2">NFT Number (Which NFT to send)</label>
                        <input type="number" id="airdropNFTNumber" min="1" placeholder="1" class="w-full bg-black/60 border border-purple-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-purple-500">
                        <p class="text-xs text-gray-500 mt-1" id="singleNFTHelp">
                            Enter the NFT number: 1-256<br>
                            NFT #1 = 001.json, NFT #2 = 002.json, etc.
                        </p>
                    </div>

                    <button onclick="window.executeSingleAirdrop()" class="btn-primary w-full py-4">
                        üéÅ Send Specific NFT to Owner
                    </button>
                </div>
            </div>

            <!-- Batch Airdrop -->
            <div class="glass-card p-6">
                <h3 class="orbitron text-lg font-bold text-cyan-400 mb-4">Batch Airdrop (CSV)</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-xs orbitron text-gray-400 uppercase font-bold mb-2">CSV Format: wallet_address, nft_number</label>
                        <textarea id="batchAirdropAddresses" rows="6" placeholder="keeta_aab5o4wt..., 1&#10;keeta_aabjzmx5..., 2&#10;keeta_another..., 3" class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-4 py-3 text-white fira text-sm outline-none focus:border-cyan-500 font-mono"></textarea>
                        <p class="text-xs text-gray-400 mt-1">Each line: wallet address, NFT number <span id="batchNFTRange">(1-256)</span></p>
                        <p class="text-xs text-gray-500 mt-1">NFT #1 = 001.json, NFT #2 = 002.json, etc.</p>
                    </div>

                    <div class="flex gap-4">
                        <button onclick="window.importAirdropCSV()" class="flex-1 border border-cyan-500/30 rounded-lg px-4 py-3 text-cyan-400 text-sm hover:bg-cyan-500/10 transition">
                            üìÑ Import CSV
                        </button>
                        <button onclick="window.validateAirdropAddresses()" class="flex-1 border border-purple-500/30 rounded-lg px-4 py-3 text-purple-400 text-sm hover:bg-purple-500/10 transition">
                            ‚úì Validate
                        </button>
                    </div>

                    <div id="batchAirdropStatus" class="hidden p-4 rounded-lg border"></div>

                    <button onclick="window.executeBatchAirdrop()" class="btn-primary w-full py-4">
                        üéÅ Send to All Owners (<span id="batchAirdropCount">0</span> NFTs)
                    </button>
                </div>
            </div>

            <!-- Airdrop History -->
            <div class="glass-card p-6">
                <h3 class="orbitron text-lg font-bold text-green-400 mb-4">Airdrop History</h3>
                <div id="airdropHistoryList" class="space-y-2">
                    <p class="text-sm text-gray-500 text-center py-8">No airdrops yet</p>
                </div>
            </div>
        </div>
        </div> <!-- End airdropContent -->
    </section>

    <script type="module">
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIREBASE INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, setPersistence, browserLocalPersistence, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, deleteDoc, onSnapshot, getDocs, query, where, orderBy, limit, increment, addDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";


        const firebaseConfig = {
            apiKey: "AIzaSyBe_G4Es-1UrPx_0unnByq2VsiSEKRj0GU",
            authDomain: "punkswap-production.firebaseapp.com",
            projectId: "punkswap-production",
            storageBucket: "punkswap-production.firebasestorage.app",
            messagingSenderId: "897835219222",
            appId: "1:897835219222:web:a65f92db25cd8861d0b837"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const functions = getFunctions(app, 'us-central1'); // CRITICAL: Specify region

        // CRITICAL: Set auth persistence to LOCAL (survives page refresh)
        setPersistence(auth, browserLocalPersistence)
            .then(() => {
                console.log("‚úÖ Auth persistence set to LOCAL (survives refresh)");
            })
            .catch((error) => {
                console.error("‚ùå Auth persistence error:", error);
            });

        console.log("üî• Firebase initialized - ALL 5 FIXES APPLIED + SECURE ESCROW BACKEND");

        window.db = db;
        window.functions = functions;
        
        // Initialize Cloud Functions callable references (SECURE ESCROW BACKEND)
        window.getEscrowBalance = httpsCallable(functions, 'getEscrowBalance');
        window.processNFTPurchase = httpsCallable(functions, 'processNFTPurchase');
        window.returnFromEscrow = httpsCallable(functions, 'returnFromEscrow');
        window.getEscrowAddressCF = httpsCallable(functions, 'getEscrowAddress');
        window.escrowMintRelease = httpsCallable(functions, 'escrowMintRelease');
        
        console.log("üîí Cloud Functions initialized (SECURE ESCROW):", {
            getEscrowBalance: !!window.getEscrowBalance,
            processNFTPurchase: !!window.processNFTPurchase,
            returnFromEscrow: !!window.returnFromEscrow,
            getEscrowAddress: !!window.getEscrowAddressCF,
            escrowMintRelease: !!window.escrowMintRelease
        });

        async function testFirebaseConnection() {
            // First, wait for auth state to settle (handles browser persistence restoring session)
            const waitForAuth = () => new Promise((resolve) => {
                // If already signed in, resolve immediately
                if (auth.currentUser) {
                    resolve(auth.currentUser);
                    return;
                }
                // Wait for onAuthStateChanged (fires when persistence restores session)
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    unsubscribe();
                    resolve(user);
                });
                // Timeout after 3 seconds ‚Äî don't wait forever
                setTimeout(() => resolve(null), 3000);
            });

            try {
                let user = await waitForAuth();
                
                if (user) {
                    console.log("‚úÖ Firebase Auth: SESSION RESTORED");
                    return true;
                }
                
                // No existing session ‚Äî sign in anonymously
                const userCredential = await signInAnonymously(auth);
                console.log("‚úÖ Firebase Auth: CONNECTED (new session)");
                return true;
            } catch (error) {
                console.error("‚ùå Firebase initial auth failed, retrying...", error.message);
                // Retry once after a short delay
                try {
                    await new Promise(r => setTimeout(r, 2000));
                    if (auth.currentUser) {
                        console.log("‚úÖ Firebase Auth: CONNECTED on retry (session restored)");
                        return true;
                    }
                    await signInAnonymously(auth);
                    console.log("‚úÖ Firebase Auth: CONNECTED on retry");
                    return true;
                } catch (retryError) {
                    console.error("‚ùå Firebase connection failed after retry:", retryError.message);
                    window.notify("Firebase Connection Error ‚Äî try refreshing", "error");
                    return false;
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GLOBAL STATE & CONSTANTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // CRITICAL: Your escrow wallet address - REPLACE WITH YOUR ACTUAL ESCROW WALLET
        const ESCROW_WALLET = 'keeta_aahwlzckqrwutkvb5dvqkv7pzdlbuwwwnildzomjhajslz3tmhmzp3jmhlkq';
        
        const state = { 
            appId: 'punkswap-pro-auth-v16',
            keetaClient: null, 
            keetaAccount: null, 
            user: null, 
            address: null, 
            nfts: [], 
            collections: [],
            traitCounts: {},
            balanceKTA: 0, 
            balancePunks: 0, 
            scannedFiles: [], 
            watchlist: [],
            escrowAccount: null, 
            escrowClient: null, 
            escrowAddress: null,
            priceMode: 'kta', 
            pulseChart: null, 
            colPageChart: null, 
            viewingCollection: null,
            isForging: false,
            firebaseReady: false,
            mintStatus: null,
            listingNFT: null,
            marketPulseData: [],
            chartTimeframe: '24h',
            chartCurrency: 'ALL',
            pnlCurrency: 'KTA',
            colChartCurrency: 'KTA',
            collectionChartTimeframe: '24h',
            selectedChartCollection: 'all',
            marketHistory: [],
            chartUpdateInterval: null,
            transactions: [], // User's transaction history
            allTransactions: [], // Unfiltered transactions
            collectionFilters: {},
            sortMode: 'price',
            // WHITELIST STATE
            whitelistSettings: {},      // collectionId -> settings
            whitelistWallets: {},        // collectionId -> [wallets]
            editingWhitelist: null,      // current collection being edited
            // Offer system
            offers: [],
            myOffers: [],
            offersOnMyNFTs: [],
            // Auction system
            auctions: [],
            myBids: [],
            // üìä PERFORMANCE MONITORING
            performanceMetrics: {
                totalMints: 0,
                successfulMints: 0,
                failedMints: 0,
                batchMints: [],  // Array of batch statistics
                mintTimes: [],   // Array of individual mint times
                lastUpdated: null
            },
            // Comments system
            comments: {},  // nftId -> [comments]
            currentCommentTarget: null,
            commentWidgetOpen: false,
            // üîí DOUBLE-CLICK PROTECTION
            _txLocks: {}  // operation locks to prevent duplicate transactions
        };
        
        window.state = state;

        // üîí DOUBLE-CLICK PROTECTION - prevents duplicate transactions
        window.acquireTxLock = (key) => {
            if (state._txLocks[key]) {
                console.warn(`üîí Transaction "${key}" already in progress, ignoring duplicate click`);
                return false;
            }
            state._txLocks[key] = Date.now();
            console.log(`üîí Lock acquired: ${key}`);
            return true;
        };
        window.releaseTxLock = (key) => {
            delete state._txLocks[key];
            console.log(`üîì Lock released: ${key}`);
        };
        // Safety: auto-release stale locks after 5 minutes
        setInterval(() => {
            const now = Date.now();
            Object.entries(state._txLocks).forEach(([key, ts]) => {
                if (now - ts > 300000) {
                    console.warn(`üîì Auto-releasing stale lock: ${key} (${Math.round((now - ts) / 1000)}s old)`);
                    delete state._txLocks[key];
                }
            });
        }, 30000);

        // Lazy-load Chart.js (saves ~200KB on initial page load, reduces ERR_INSUFFICIENT_RESOURCES)
        window.loadChartJs = () => {
            if (window.Chart) return Promise.resolve();
            if (window._chartJsLoadPromise) return window._chartJsLoadPromise;
            window._chartJsLoadPromise = new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/chart.js';
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('Chart.js load failed'));
                document.head.appendChild(s);
            });
            return window._chartJsLoadPromise;
        };

        // üìä PROFESSIONAL CHART HELPERS
        window.formatChartLabel = (timestamp, timeframe) => {
            const d = timestamp instanceof Date ? timestamp : new Date(timestamp);
            switch (timeframe) {
                case '1h':
                    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                case '24h':
                    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                case '7d':
                    return d.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + d.toLocaleTimeString([], { hour: '2-digit' });
                case '30d':
                    return d.toLocaleDateString([], { month: 'short', day: 'numeric' });
                case 'all':
                    return d.toLocaleDateString([], { month: 'short', day: 'numeric' });
                default:
                    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
        };
        window.getChartCurrencyLabel = (currency) => {
            if (currency === 'PUNKS') return 'PUNKS';
            if (currency === 'ALL') return 'KTA+PUNKS';
            return currency || 'KTA';
        };

        // üñºÔ∏è UNIVERSAL COLLECTION IMAGE RESOLVER
        // Single source of truth for resolving collection display images
        window.resolveCollectionImage = (col) => {
            // 1. External collections: use first NFT image
            if (col.isExternal) {
                const firstNFT = state.nfts.find(n => n.collectionId === col.collectionId || getNormalizedId(n.collectionToken) === getNormalizedId(col.collectionToken));
                if (firstNFT?.image || firstNFT?.imageUrl) return firstNFT.image || firstNFT.imageUrl;
            }
            // 2. Forge Hub thumbnail CID (user provided during collection creation)
            if (col.collectionThumbnailCid) {
                const cid = col.collectionThumbnailCid;
                if (cid.startsWith('http://') || cid.startsWith('https://')) return cid;
                return getIPFSUrl(cid);
            }
            // 3. Preview image URL
            if (col.previewImageUrl) return col.previewImageUrl;
            // 4. Legacy thumbnail field
            if (col.collectionThumbnail) return getIPFSUrl(col.collectionThumbnail);
            // 5. thumbnailCid alias
            if (col.thumbnailCid) {
                const cid = col.thumbnailCid;
                if (cid.startsWith('http://') || cid.startsWith('https://')) return cid;
                return getIPFSUrl(cid);
            }
            // 6. Derive from IPFS folder + first scanned file
            if (col.ipfsCid && col.scannedFiles && col.scannedFiles[0]) {
                // Derive from scannedFiles - check if the scanned file already has a path prefix
                const scannedFile = col.scannedFiles[0].replace('.json', '.png');
                const imageCid = scannedFile.includes('/') 
                    ? `${col.ipfsCid}/${scannedFile}` 
                    : `${col.ipfsCid}/images/${scannedFile}`;
                return getIPFSUrl(imageCid);
            }
            // 7. Use a minted NFT's image
            const mintedNFT = state.nfts.find(n => n.collectionId === col.collectionId);
            if (mintedNFT) {
                const nftImgPath = window.getNFTImagePath(mintedNFT);
                if (nftImgPath) {
                    if (nftImgPath.startsWith('http://') || nftImgPath.startsWith('https://')) return nftImgPath;
                    return getIPFSUrl(nftImgPath);
                }
            }
            // 8. Fallback SVG with collection name
            const title = encodeURIComponent(col.collectionTitle || col.collectionName || 'Collection');
            return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23111' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-family='monospace' font-size='16'%3E${title}%3C/text%3E%3C/svg%3E`;
        };

        const KTA_DECIMALS = 1e18; // Mainnet uses 18 decimals (testnet was 1e9)
        // SECURITY: Escrow seed phrase is SERVER-SIDE ONLY (Firebase Cloud Functions)
        // All escrow signing operations are handled by secure Cloud Functions:
        // - processNFTPurchase: Releases NFT from escrow to buyer (server signs)
        // - returnFromEscrow: Returns NFT from escrow to seller (server signs)
        // - getEscrowBalance: Checks escrow wallet balance (server-side)
        // Client only needs the escrow ADDRESS (public, read-only) for deposits
        
        const MARKETPLACE_FEE_WALLET = "keeta_aabxkpwbrtvh75lw6y2xbjzbscdzih3gqgq45dracocjakq6l4a544rh6sakpga";
        const ESCROW_ADDRESS = MARKETPLACE_FEE_WALLET; // Public escrow address (same wallet receives fees + holds escrow NFTs)
        const PUNKS_TOKEN_ADDRESS = "keeta_anbddd6wtxbe6sjgvpfb7yjehkfeoulufieim62zrddkmuaw5wnq464hd32wa"; // RESERVE PUNKS token
        const PRIMARY_SALE_CREATOR_PERCENT = 0.90;
        const PRIMARY_SALE_MARKETPLACE_PERCENT = 0.10;
        const SECONDARY_SALE_SELLER_PERCENT = 0.92;
        const SECONDARY_SALE_CREATOR_ROYALTY_PERCENT = 0.05;
        const SECONDARY_SALE_MARKETPLACE_PERCENT = 0.03;
        
        // ‚ö° PARALLEL MINTING CONFIGURATION (Optimized for Keeta blockchain)
        const PARALLEL_MINT_CONFIG = {
            CHUNK_SIZE: 1,                // Mints per batch (1 = sequential for blockchain stability)
            SHOW_SPEED_STATS: true,       // Show minting speed in notifications  
            MAX_RETRIES: 0,               // Retry failed mints (0 = no retry for speed)
            ENABLE_OPTIMISTIC_UI: true,   // Show NFTs immediately before blockchain confirm ‚ö°
            INTER_MINT_DELAY_MS: 1000,    // Delay between sequential mints (ms) - Min 1000ms recommended
            AGGRESSIVE_MODE: false        // ‚ö° EXPERIMENTAL: Reduce inter-mint delay to 500ms (MAY CAUSE CONFLICTS!)
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // IPFS GATEWAY ROTATOR - Fixes 429 "Too Many Requests" Errors
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const IPFS_GATEWAYS = [
            'https://ipfs.io/ipfs/',
            'https://gateway.pinata.cloud/ipfs/',
            'https://4everland.io/ipfs/',
            'https://w3s.link/ipfs/',
            'https://dweb.link/ipfs/'
        ];

        let currentGatewayIndex = 0;
        const gatewayFailures = new Map(); // Track failures per CID

        // Get IPFS URL with current gateway
        window.getIPFSUrl = function(cid) {
            if (!cid) return '';
            
            // If it's already a full URL, return as-is
            if (cid.startsWith('http://') || cid.startsWith('https://')) {
                return cid;
            }
            
            // Remove any existing gateway prefix
            const cleanCid = cid.replace(/https?:\/\/[^\/]+\/ipfs\//, '');
            
            // Use current gateway
            return IPFS_GATEWAYS[currentGatewayIndex] + cleanCid;
        };

        // Rotate to next gateway on error
        window.rotateIPFSGateway = function() {
            currentGatewayIndex = (currentGatewayIndex + 1) % IPFS_GATEWAYS.length;
            console.log(`üîÑ Rotating to IPFS gateway ${currentGatewayIndex + 1}/${IPFS_GATEWAYS.length}: ${IPFS_GATEWAYS[currentGatewayIndex]}`);
        };
        
        // Helper: Get collection mint price and currency (supports KTA + PUNKS)
        window.getCollectionPrice = function(col, wallet) {
            const phase = wallet ? window.getActivePhaseForWallet(col.collectionId, wallet) : null;
            if (phase) return { price: phase.priceKTA || 0, currency: 'KTA' };
            const ktaP = parseFloat(col.priceKTA || 0);
            const punksP = parseFloat(col.pricePunks || 0);
            if (ktaP > 0) return { price: ktaP, currency: 'KTA' };
            if (punksP > 0) return { price: punksP, currency: 'PUNKS' };
            return { price: 0, currency: 'KTA' };
        };
        
        // Helper: Get the token object for a currency
        window.getTokenForCurrency = function(currency) {
            if (currency === 'PUNKS') {
                return KeetaNet.lib.Account.fromPublicKeyString(PUNKS_TOKEN_ADDRESS);
            }
            return state.keetaClient.baseToken; // KTA
        };

        // Handle image load errors with automatic retry on different gateway
        window.handleIPFSImageError = function(imgElement, cid, retryCount = 0) {
            if (!cid || retryCount >= IPFS_GATEWAYS.length) {
                console.warn('‚ö†Ô∏è All IPFS gateways failed for:', cid);
                imgElement.onerror = null;
                imgElement.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="400" height="400"%3E%3Crect fill="%23111" width="400" height="400"/%3E%3Ctext x="50%25" y="50%25" text-anchor="middle" fill="%23666" font-size="16"%3EIPFS Load Failed%3C/text%3E%3C/svg%3E';
                return;
            }
            
            // Try next gateway
            const gatewayIdx = (retryCount + 1) % IPFS_GATEWAYS.length;
            const cleanCid = cid.replace(/https?:\/\/[^\/]+\/ipfs\//, '');
            const newUrl = IPFS_GATEWAYS[gatewayIdx] + cleanCid;
            console.log(`üîÑ Retry ${retryCount + 1}/${IPFS_GATEWAYS.length} for ${cleanCid.substring(0,20)}...: ${IPFS_GATEWAYS[gatewayIdx]}`);
            imgElement.src = newUrl;
            imgElement.onerror = () => handleIPFSImageError(imgElement, cid, retryCount + 1);
        };
        
        // Proactive IPFS image loader - tries fetch as blob to bypass CORS, with img fallback
        window.loadIPFSImage = function(imgElement, ipfsPath) {
            if (!ipfsPath || ipfsPath.startsWith('data:')) return;
            const cleanPath = ipfsPath.replace(/https?:\/\/[^\/]+\/ipfs\//, '');
            
            let attempt = 0;
            const tryNextGateway = () => {
                if (attempt >= IPFS_GATEWAYS.length) {
                    console.warn('‚ö†Ô∏è All IPFS fetch attempts failed for:', cleanPath.substring(0,30));
                    return; // Keep whatever src was last set
                }
                const url = IPFS_GATEWAYS[attempt] + cleanPath;
                attempt++;
                fetch(url)
                    .then(r => { if (!r.ok) throw new Error(r.status); return r.blob(); })
                    .then(blob => { 
                        if (blob.type.startsWith('image/') || blob.size > 1000) {
                            imgElement.onerror = null;
                            imgElement.src = URL.createObjectURL(blob);
                        } else {
                            throw new Error('Not an image');
                        }
                    })
                    .catch(() => tryNextGateway());
            };
            tryNextGateway();
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TAB SWITCHING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Toggle mobile menu
        window.toggleMobileMenu = () => {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobileOverlay');
            
            if (sidebar && overlay) {
                sidebar.classList.toggle('mobile-open');
                overlay.classList.toggle('active');
            }
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // HELPER FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        function getNormalizedId(t) {
            if (!t) return "";
            try {
                if (typeof t === 'string') return t.toLowerCase().trim();
                if (t.publicKeyString) return (typeof t.publicKeyString === 'string' ? t.publicKeyString : t.publicKeyString.get()).toLowerCase().trim();
                if (t.account?.publicKeyString) return (typeof t.account.publicKeyString === 'string' ? t.account.publicKeyString : t.account.publicKeyString.get()).toLowerCase().trim();
            } catch (e) {}
            return t.toString().toLowerCase().trim();
        }

        // Resolve NFT imageCid to full IPFS path (handles relative paths like images/004.png)
        // Returns the CID path for use with any gateway: https://gateway.pinata.cloud/ipfs/${path}
        window.getNFTImagePath = (n) => {
            // For external NFTs (like PFP), return the full image URL directly
            if (n?.isExternal && (n?.image || n?.imageUrl)) {
                return n.image || n.imageUrl;
            }
            
            // Check for full image URL first (works for any NFT type)
            if (n?.image && (n.image.startsWith('http://') || n.image.startsWith('https://'))) return n.image;
            if (n?.imageUrl && (n.imageUrl.startsWith('http://') || n.imageUrl.startsWith('https://'))) return n.imageUrl;
            
            const cid = n?.imageCid || '';
            if (!cid) return '';
            
            // If CID is already a full URL, return as-is
            if (cid.startsWith('http://') || cid.startsWith('https://')) return cid;
            
            // If CID starts with known IPFS hash prefix, it's a valid CID path
            if (cid.startsWith('bafybei') || cid.startsWith('Qm')) return cid;
            
            // For relative paths (like '191.png' or 'images/004.png'), need collection CID
            const col = state.collections?.find(c => (c.collectionId || c.id) === (n?.collectionId || n?.id) || getNormalizedId(c.collectionToken) === getNormalizedId(n?.collectionToken));
            const ipfsCid = col?.ipfsCid;
            if (ipfsCid) {
                return cid.startsWith('images/') ? `${ipfsCid}/${cid}` : cid.includes('/') ? `${ipfsCid}/${cid}` : `${ipfsCid}/images/${cid}`;
            }
            
            // If no collection found and CID is just a filename (like '191.png'), 
            // it's likely a PFP or external NFT - don't return bare filename
            if (cid.match(/^\d+\.(png|jpg|jpeg|gif|webp|svg)$/i)) {
                // Bare filename with no collection context - return empty to avoid bad IPFS URLs
                console.warn(`‚ö†Ô∏è getNFTImagePath: bare filename '${cid}' with no collection context for ${n?.name || 'unknown'}`);
                return '';
            }
            
            return cid;
        };

        window.fixBrokenNFTs = async () => {
            console.log('üîß Starting NFT ownership repair...');
            
            try {
                const nftsRef = collection(db, 'nfts');
                const snapshot = await getDocs(nftsRef);
                
                let fixed = 0;
                const updates = [];
                
                for (const docSnap of snapshot.docs) {
                    const nft = docSnap.data();
                    
                    // Skip external auto-detected NFTs
                    if (nft.isExternal && nft.source === 'auto-detect') {
                        console.log(`‚è≠Ô∏è Skipping external: ${nft.name || nft.id}`);
                        continue;
                    }
                    
                    // Fix if owner is null OR transferredOutside is true
                    if (!nft.owner || nft.transferredOutside) {
                        console.log(`üîß Fixing: ${nft.name || nft.id}`);
                        const nftRef = doc(db, 'nfts', docSnap.id);
                        updates.push(
                            updateDoc(nftRef, {
                                owner: state.address,
                                transferredOutside: false,
                                updatedAt: new Date().toISOString()
                            })
                        );
                        fixed++;
                    }
                }
                
                if (updates.length > 0) {
                    await Promise.all(updates);
                    console.log(`‚úÖ Fixed ${fixed} NFTs!`);
                    window.notify(`Fixed ${fixed} NFTs!`, 'success');
                    await window.loadNFTsFromFirebase();
                    await window.renderCollection();
                } else {
                    console.log('‚úÖ All NFTs are already correct');
                }
            } catch (error) {
                console.error('‚ùå Error fixing NFTs:', error);
                window.notify('Error fixing NFTs: ' + error.message, 'error');
            }
        };

        window.inspectManifestItem = async (itemId = '191') => {
            try {
                console.log(`üîç Fetching manifest to inspect item #${itemId}...`);
                const manifestUrl = 'https://ipfs.io/ipfs/bafkreifh4qgpi7qg2htojj3rndpy23pj3mhkloibo3squ2z6ntwj2svhwe';
                const response = await fetch(manifestUrl);
                const manifest = await response.json();
                
                const item = manifest.items?.find(i => i.id === itemId);
                if (!item) {
                    console.error(`‚ùå Item #${itemId} not found in manifest`);
                    return null;
                }
                
                console.log(`‚úÖ Found item #${itemId} in manifest`);
                console.log('üì¶ Item structure:', JSON.stringify(item, null, 2));
                console.log('üîë Item keys:', Object.keys(item));
                console.log('üìã Has metadata field?', 'metadata' in item);
                console.log('üìã Has attributes field?', 'attributes' in item);
                console.log('üìã Has metadata_url field?', 'metadata_url' in item);
                
                return item;
            } catch (error) {
                console.error('‚ùå Failed to inspect manifest:', error);
                return null;
            }
        };

        window.redetectExternalNFT = async (nftId) => {
            try {
                console.log(`üîÑ Re-detecting NFT: ${nftId}`);
                
                // Remove from Firebase
                const nftRef = doc(db, 'nfts', nftId);
                await deleteDoc(nftRef);
                console.log('‚úÖ Deleted from Firebase');
                
                // Remove from state
                state.nfts = state.nfts.filter(n => n.id !== nftId);
                console.log('‚úÖ Removed from state');
                
                // Re-run auto-detect
                await window.autoDetectExternalNFTs();
                
                // Check the result
                const pfpNFT = state.nfts.find(n => n.id === nftId);
                console.log('‚úÖ NFT re-detected:', {
                    name: pfpNFT?.name,
                    image: pfpNFT?.image,
                    attributes: pfpNFT?.attributes?.length,
                    sampleAttributes: pfpNFT?.attributes?.slice(0, 3)
                });
                
                return pfpNFT;
            } catch (error) {
                console.error('‚ùå Re-detect failed:', error);
                return null;
            }
        };

        window.debugLog = (msg, isError = false) => {
            const log = document.getElementById('neuralDebugLog');
            if (log) {
                const timestamp = new Date().toLocaleTimeString();
                const color = isError ? '#ff0066' : '#00ff88';
                log.innerHTML += `<div style="color: ${color}">[${timestamp}] ${msg}</div>`;
                log.scrollTop = log.scrollHeight;
            }
            console.log(msg);
        };

        // NOTIFICATION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        window.notify = (msg, type = "success") => {
            const n = document.createElement('div');
            n.className = `fixed bottom-10 right-10 p-8 glass-card border-l-[10px] ${type==='success'?'border-cyan-500 text-cyan-400':'border-red-500 text-red-500'} z-[5000] orbitron text-[10px] font-black uppercase animate-view shadow-2xl`;
            n.innerText = msg;
            document.body.appendChild(n);
            setTimeout(() => n.remove(), 4000);
        };

        window.updateStats = () => { 
            const el = document.getElementById('statTotal');
            if (el) el.innerText = state.nfts.length; 
        };

        window.notify = (msg, type = "success") => {
            const n = document.createElement('div');
            n.className = `fixed bottom-10 right-10 p-8 glass-card border-l-[10px] ${type==='success'?'border-cyan-500 text-cyan-400':'border-red-500 text-red-500'} z-[5000] orbitron text-[10px] font-black uppercase animate-view shadow-2xl`;
            n.innerText = msg;
            document.body.appendChild(n);
            setTimeout(() => n.remove(), 4000);
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #2: MINT STATUS INDICATOR
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.showMintStatus = (status, message) => {
            state.mintStatus = status;
            
            const existing = document.querySelector('.mint-status-badge');
            if (existing) existing.remove();
            
            const badge = document.createElement('div');
            badge.className = `mint-status-badge mint-status-${status}`;
            badge.innerHTML = `
                <div class="flex items-center gap-3">
                    ${status === 'pending' ? '<div class="w-3 h-3 border-2 border-orange-500 border-t-transparent rounded-full animate-spin"></div>' : ''}
                    ${status === 'confirmed' ? '<div class="w-3 h-3 bg-green-500 rounded-full shadow-[0_0_10px_lime]"></div>' : ''}
                    ${status === 'failed' ? '<div class="w-3 h-3 bg-red-500 rounded-full"></div>' : ''}
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(badge);
            
            if (status === 'confirmed' || status === 'failed') {
                setTimeout(() => {
                    badge.style.opacity = '0';
                    badge.style.transform = 'translateX(400px)';
                    setTimeout(() => badge.remove(), 300);
                }, 3000);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #1 & #3: ENHANCED METADATA FETCHING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.fetchNFTMetadata = async (nft) => {
            try {
                if (nft.metadataCache && nft.metadataCache.attributes) {
                    return nft.metadataCache;
                }
                
                const collection = state.collections.find(c => c.collectionId === nft.collectionId);
                if (!collection) {
                    console.warn("Collection not found for NFT:", nft.id);
                    return null;
                }
                
                // Build metadata URL
                let metadataUrl;
                
                if (collection.isExternal && collection.baseMetadataUrl) {
                    // External collection (like PFP) - use externalId for the number
                    const nftNumber = nft.externalId || nft.id.split('_').pop();
                    metadataUrl = `${collection.baseMetadataUrl}${nftNumber}.json`;
                    console.log(`üì• Fetching external NFT metadata #${nftNumber}: ${metadataUrl}`);
                } else {
                    // Regular internal collection
                    const mintIndex = nft.id.split('_').pop();
                    const fileName = collection.scannedFiles?.[mintIndex] || `${mintIndex}.json`;
                    metadataUrl = `${getIPFSUrl(collection.ipfsCid)}/${fileName}`;
                    console.log("üì• Fetching metadata:", metadataUrl);
                }
                
                const response = await fetch(metadataUrl);
                if (!response.ok) {
                    // For external NFTs, try fallback: use manifest data or kee.tools
                    if (collection.isExternal && nft.tokenId) {
                        console.warn(`‚ö†Ô∏è IPFS metadata failed, using embedded data for external NFT`);
                        // Use what we already have from manifest
                        return {
                            name: nft.name,
                            description: nft.description,
                            image: nft.image || `${collection.baseImageUrl || 'https://pfponkeeta.xyz/images/'}${nft.externalId}.png`,
                            attributes: nft.attributes || []
                        };
                    }
                    throw new Error(`Metadata fetch failed: ${response.status}`);
                }
                
                const metadata = await response.json();
                nft.metadataCache = metadata;
                
                if (metadata.attributes && Array.isArray(metadata.attributes)) {
                    await updateDoc(doc(db, 'nfts', nft.id), {
                        attributes: metadata.attributes,
                        metadataFetched: true,
                        lastMetadataUpdate: new Date().toISOString()
                    });
                }
                
                return metadata;
            } catch (error) {
                console.error("Error fetching NFT metadata:", error);
                return null;
            }
        };

        // FIX #1: Render traits with rarity - ENHANCED WITH TOGGLE
        window.renderNFTTraits = (nft, mode = 'toggle', initiallyExpanded = false) => {
            if (!nft.attributes || nft.attributes.length === 0) {
                return '<div class="text-xs text-gray-500 fira italic mt-2">No traits available</div>';
            }
            
            const collection = state.collections.find(c => 
                c.collectionId === nft.collectionId || 
                (nft.collectionToken && getNormalizedId(c.collectionToken) === getNormalizedId(nft.collectionToken))
            );
            const totalMinted = collection?.mintedCount || 1;
            const uniqueId = `traits-${nft.id}-${Math.random().toString(36).substr(2, 9)}`;
            
            const traitsHTML = nft.attributes.map((trait, index) => {
                const traitRarity = window.calculateTraitRarity(trait, nft.collectionId, totalMinted);
                const tier = window.getRarityTier(traitRarity);
                
                // Clean trait_type: remove leading numbers (handles "1 BACKGROUND", "3 BODY", etc.)
                const cleanTraitType = (trait.trait_type || 'Unknown').replace(/^\d+\s+/, '');
                
                return `
                    <div class="trait-badge" style="border-color: ${tier.borderColor || 'rgba(255,255,255,0.1)'}">
                        <div class="flex justify-between text-xs items-center">
                            <span class="text-gray-400 uppercase font-semibold text-[10px]">${cleanTraitType}</span>
                            <span class="${tier.color} font-bold">${trait.value || 'Unknown'}</span>
                        </div>
                        <div class="text-[10px] ${tier.color} mt-0.5 font-bold">
                            ${traitRarity.toFixed(1)}% rarity
                        </div>
                    </div>
                `;
            }).join('');
            
            // MODE: 'toggle' = collapsible, 'all' = show all expanded, 'limited' = show first 3
            if (mode === 'all') {
                return `<div class="mt-3 space-y-1.5">${traitsHTML}</div>`;
            }
            
            if (mode === 'limited') {
                return `
                    <div class="mt-3 space-y-1.5">
                        ${nft.attributes.slice(0, 3).map((trait, index) => {
                            const traitRarity = window.calculateTraitRarity(trait, nft.collectionId, totalMinted);
                            const tier = window.getRarityTier(traitRarity);
                            
                            // Clean trait_type: remove leading numbers
                            const cleanTraitType = (trait.trait_type || 'Unknown').replace(/^\d+\s+/, '');
                            
                            return `
                                <div class="trait-badge ${tier.glow}" style="border-color: ${tier.borderColor || 'rgba(255,255,255,0.1)'}">
                                    <div class="flex justify-between text-xs items-center">
                                        <span class="text-gray-400 uppercase font-semibold text-[10px]">${cleanTraitType}</span>
                                        <span class="${tier.color} font-bold">${trait.value || 'Unknown'}</span>
                                    </div>
                                    <div class="text-[10px] ${tier.color} mt-0.5 font-bold">
                                        ${traitRarity.toFixed(1)}% rarity
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        ${nft.attributes.length > 3 ? `
                            <div class="text-[10px] text-cyan-400 fira text-center font-semibold">
                                +${nft.attributes.length - 3} more traits
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // MODE: 'toggle' - collapsible with button
            return `
                <div class="mt-3">
                    <div class="trait-toggle-btn" onclick="window.toggleTraits('${uniqueId}')">
                        <span class="orbitron text-xs font-bold text-cyan-400 uppercase">
                            Traits (${nft.attributes.length})
                        </span>
                        <svg id="${uniqueId}-icon" class="w-4 h-4 text-cyan-400 trait-toggle-icon ${initiallyExpanded ? 'rotated' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    <div id="${uniqueId}" class="traits-container ${initiallyExpanded ? 'expanded' : ''} space-y-1.5 mt-2">
                        ${traitsHTML}
                    </div>
                </div>
            `;
        };
        
        // Toggle traits visibility
        window.toggleTraits = (containerId) => {
            const container = document.getElementById(containerId);
            const icon = document.getElementById(`${containerId}-icon`);
            
            if (container && icon) {
                container.classList.toggle('expanded');
                icon.classList.toggle('rotated');
            }
        };

        window.calculateTraitRarity = (trait, collectionId, totalMinted) => {
            // Try multiple collection ID formats
            const possibleIds = [
                collectionId,
                collectionId?.replace?.('collection_', ''),
                `collection_${collectionId}`
            ].filter(Boolean);
            
            let counts = {};
            for (const id of possibleIds) {
                if (state.traitCounts[id]) {
                    counts = state.traitCounts[id];
                    break;
                }
            }
            
            if (Object.keys(counts).length === 0) {
                console.warn(`‚ö†Ô∏è No trait counts found for collection: ${collectionId}`);
                return 0;
            }
            
            const key = `${trait.trait_type}:${trait.value}`;
            const count = counts[key] || 0;
            const rarity = totalMinted > 0 ? (count / totalMinted) * 100 : 0;
            
            console.log(`üé® Trait rarity: ${key} = ${rarity.toFixed(1)}% (${count}/${totalMinted})`);
            
            return rarity;
        };

        window.getRarityTier = (rarityPercent) => {
            if (rarityPercent > 20) return { tier: 'common', color: 'text-gray-400', glow: '', borderColor: 'rgba(156,163,175,0.3)' };
            if (rarityPercent > 10) return { tier: 'uncommon', color: 'text-green-400', glow: 'shadow-[0_0_10px_rgba(34,197,94,0.3)]', borderColor: 'rgba(34,197,94,0.5)' };
            if (rarityPercent > 3) return { tier: 'rare', color: 'text-blue-400', glow: 'shadow-[0_0_15px_rgba(59,130,246,0.5)]', borderColor: 'rgba(59,130,246,0.6)' };
            if (rarityPercent > 1) return { tier: 'elite', color: 'text-purple-400', glow: 'shadow-[0_0_20px_rgba(168,85,247,0.6)]', borderColor: 'rgba(168,85,247,0.7)' };
            return { tier: 'mythic', color: 'text-yellow-400', glow: 'shadow-[0_0_25px_rgba(234,179,8,0.8)]', borderColor: 'rgba(234,179,8,0.8)' };
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AUTO-DETECT EXTERNAL NFT COLLECTION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const EXTERNAL_COLLECTION = {
            manifestUrl: 'https://ipfs.io/ipfs/bafkreifh4qgpi7qg2htojj3rndpy23pj3mhkloibo3squ2z6ntwj2svhwe',
            collectionToken: 'keeta_an2ry2lnhztn5x7h5n3af5cw5ho37rqcq5z3kr4jlnmqyxprteu7ooxuhlmje',
            collectionName: 'Peregrine Falcon Punks',
            baseMetadataUrl: 'https://gateway.pinata.cloud/ipfs/bafybeifyjbtyhw3zikyo3x25lnszfebxg2cqotzwsjvb3fxnr4x7gkfkei/', // Metadata CID  
            baseImageUrl: 'https://pfponkeeta.xyz/images/', // Direct image server (fallback)
            totalItems: 241
        };

        window.autoDetectExternalNFTs = async () => {
            if (!state.address || !state.keetaClient) {
                console.log("‚è≠Ô∏è Skipping auto-detect: No wallet connected");
                return;
            }

            try {
                console.log("üîç AUTO-DETECT: Starting scan for Peregrine Falcon Punks...");
                
                // Step 1: Fetch the manifest
                console.log("üì° Fetching collection manifest from IPFS...");
                const manifestResponse = await fetch(EXTERNAL_COLLECTION.manifestUrl);
                if (!manifestResponse.ok) {
                    throw new Error(`Failed to fetch manifest: ${manifestResponse.status}`);
                }
                const manifest = await manifestResponse.json();
                console.log(`‚úÖ Manifest loaded: ${manifest.items?.length || 0} NFTs in collection`);

                if (!manifest.items || !Array.isArray(manifest.items)) {
                    console.warn("‚ö†Ô∏è Invalid manifest structure");
                    return;
                }

                // Step 2: Get user's balance to check which NFTs they own
                console.log("üíº Checking wallet balances...");
                let balances = await state.keetaClient.allBalances(state.address);
                
                if (!balances || !Array.isArray(balances)) {
                    console.warn("‚ö†Ô∏è Could not fetch balances");
                    return;
                }

                // Create a set of token addresses the user owns
                const ownedTokens = new Set(
                    balances
                        .filter(b => {
                            // NFTs have balance of 1 (could be string, number, or BigInt)
                            const balance = b.balance;
                            return balance && (
                                balance === '1' || 
                                balance === 1 || 
                                balance.toString() === '1'
                            );
                        })
                        .map(b => getNormalizedId(b.token))
                );

                console.log(`üíé User owns ${ownedTokens.size} tokens (checking against collection...)`);
                console.log(`üîç DEBUG - Sample owned tokens:`, Array.from(ownedTokens).slice(0, 3));

                // Step 3: Check which NFTs from the collection the user owns
                let detectedCount = 0;
                let processedCount = 0;
                
                for (const item of manifest.items) {
                    const nftAddress = getNormalizedId(item.address);
                    
                    // Check if user owns this NFT
                    if (ownedTokens.has(nftAddress)) {
                        console.log(`‚ú® Found owned NFT #${item.id}: ${nftAddress.substring(0, 20)}...`);
                        
                        try {
                            // Check if this NFT is already in Firebase
                            const existingNFT = state.nfts.find(n => 
                                n.tokenId === item.address || 
                                n.id === `external_${item.id}` ||
                                n.externalId === item.id
                            );


                            if (existingNFT) {
                                // NFT exists in database - check if owner changed
                                const currentOwner = existingNFT.owner?.toLowerCase();
                                const walletOwner = state.address?.toLowerCase();
                                
                                if (currentOwner !== walletOwner) {
                                    console.log(`üîÑ NFT #${item.id} owner changed! Updating from ${currentOwner} to ${walletOwner}`);
                                    
                                    // Update owner in Firebase
                                    // Update owner in Firebase
                                    try {
                                        console.log(`üìù Updating Firebase doc: ${existingNFT.id}`);
                                        console.log(`üìù New owner: ${state.address}`);
                                        
                                        await updateDoc(doc(window.db, 'nfts', existingNFT.id), {
                                            owner: state.address,
                                            inVault: true,
                                            transferredOutside: false,
                                            updatedAt: new Date().toISOString()
                                        });
                                        
                                        console.log(`‚úÖ Updated owner for NFT #${item.id} in Firebase`);
                                        
                                        // Update in state
                                        existingNFT.owner = state.address;
                                        existingNFT.inVault = true;
                                        existingNFT.transferredOutside = false;
                                        
                                        detectedCount++;
                                        
                                        // Trigger UI refresh
                                        await window.loadNFTsFromFirebase();
                                        window.renderCollection();
                                        
                                    } catch (updateError) {
                                        console.error(`‚ùå Failed to update owner for NFT #${item.id}:`, updateError);
                                        console.error(`‚ùå Error message:`, updateError?.message);
                                        console.error(`‚ùå Error code:`, updateError?.code);
                                        console.error(`‚ùå Full error:`, JSON.stringify(updateError, null, 2));
                                    }
                                } else {
                                    console.log(`‚ÑπÔ∏è NFT #${item.id} already in database with correct owner, skipping`);
                                }
                                continue;
                            }
                            
                            // Fetch metadata from IPFS (from manifest or metadata URL)
                            let metadata = item.metadata || null; // Use manifest metadata if available
                            
                            if (!metadata) {
                                try {
                                    const metadataUrl = item.metadata_url || item.uri || `${EXTERNAL_COLLECTION.baseMetadataUrl}${item.id}.json`;
                                    console.log(`üì• Fetching metadata for NFT #${item.id}: ${metadataUrl}`);
                                    
                                    const metadataResponse = await fetch(metadataUrl, { signal: AbortSignal.timeout(5000) }); // 5s timeout
                                    if (metadataResponse.ok) {
                                        metadata = await metadataResponse.json();
                                        console.log(`‚úÖ Metadata loaded for NFT #${item.id}:`, metadata.name);
                                    } else {
                                        console.warn(`‚ö†Ô∏è Metadata fetch failed (${metadataResponse.status}) for NFT #${item.id}`);
                                    }
                                } catch (e) {
                                    console.warn(`‚ö†Ô∏è Could not fetch metadata for NFT #${item.id}:`, e.message);
                                }
                            }
                            
                            // Try fetching from blockchain if no metadata yet
                            if (!metadata || !metadata.attributes || metadata.attributes.length === 0) {
                                try {
                                    console.log(`üì° Attempting to fetch metadata from blockchain for token: ${item.address}`);
                                    const accountInfo = await state.keetaClient.accountInfo(item.address);
                                    if (accountInfo && accountInfo.meta) {
                                        console.log(`‚úÖ Found blockchain metadata for #${item.id}`);
                                        metadata = accountInfo.meta;
                                    }
                                } catch (e) {
                                    console.warn(`‚ö†Ô∏è Could not fetch blockchain metadata for NFT #${item.id}:`, e.message);
                                }
                            }

                            // Construct image URL - prefer direct server over IPFS
                            const imageUrl = metadata?.image || 
                                           item.image || 
                                           (EXTERNAL_COLLECTION.baseImageUrl ? `${EXTERNAL_COLLECTION.baseImageUrl}${item.id}.png` : null);

                            // Create NFT record
                            const nftData = {
                                id: `external_${EXTERNAL_COLLECTION.collectionName.toLowerCase().replace(/\s+/g, '_')}_${item.id}`,
                                externalId: item.id,
                                tokenId: item.address,
                                name: metadata?.name || item.name || `${EXTERNAL_COLLECTION.collectionName} #${item.id}`,
                                description: metadata?.description || item.description || `NFT from ${EXTERNAL_COLLECTION.collectionName} collection`,
                                image: imageUrl,
                                imageUrl: imageUrl,
                                imageCid: imageUrl ? imageUrl.replace('ipfs://', '').split('/').pop() : null,
                                attributes: metadata?.attributes || item.attributes || [],
                                collectionToken: EXTERNAL_COLLECTION.collectionToken,
                                collectionName: EXTERNAL_COLLECTION.collectionName,
                                collectionId: EXTERNAL_COLLECTION.collectionToken,
                                owner: state.address,
                                creator: item.creator || state.address,
                                status: 'external',
                                isExternal: true,
                                autoDetected: true,
                                detectedAt: new Date().toISOString(),
                                isListed: false,
                                listed: false,
                                inVault: true,
                                source: 'auto-detect',
                                metadataCache: metadata // Cache the metadata
                            };
                            
                            console.log(`üíæ Saving NFT #${item.id} with image: ${nftData.image?.substring(0, 50)}...`);

                            // Save to Firebase
                            await setDoc(
                                doc(db, 'nfts', nftData.id),
                                nftData
                            );

                            console.log(`‚úÖ Saved NFT #${item.id} to database`);
                            detectedCount++;

                        } catch (error) {
                            console.error(`‚ùå Error processing NFT #${item.id}:`, error);
                        }
                    }
                    
                    processedCount++;
                    
                    // Progress update every 50 NFTs
                    if (processedCount % 50 === 0) {
                        console.log(`üìä Progress: ${processedCount}/${manifest.items.length} checked`);
                    }
                    
                    // Small delay to avoid rate limiting
                    if (processedCount % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                if (detectedCount > 0) {
                    console.log(`üéâ AUTO-DETECT COMPLETE: Found and imported ${detectedCount} NFTs from ${EXTERNAL_COLLECTION.collectionName}`);
                    
                    // Create or update collection record
                    await window.createOrUpdateCollectionRecord(EXTERNAL_COLLECTION.collectionToken, EXTERNAL_COLLECTION.collectionName);
                    
                    // Reload all data
                    await window.loadNFTsFromFirebase();
                    await window.loadCollections();
                    
                    // Calculate and save trait counts for rarity system
                    await window.calculateAndSaveTraitCounts(EXTERNAL_COLLECTION.collectionToken);
                    await window.loadTraitCounts();
                    
                    window.notify(`Auto-detected ${detectedCount} NFTs from ${EXTERNAL_COLLECTION.collectionName}!`, "success");
                } else {
                    console.log(`‚ÑπÔ∏è AUTO-DETECT: No new NFTs found from ${EXTERNAL_COLLECTION.collectionName}`);
                }
                
                // ALWAYS calculate trait counts for this collection (even if just updating owners)
                const pfpNFTs = state.nfts.filter(n => 
                    n.collectionToken === EXTERNAL_COLLECTION.collectionToken ||
                    n.externalCollection === EXTERNAL_COLLECTION.collectionName
                );
                
                if (pfpNFTs.length > 0) {
                    console.log(`üìä Ensuring trait counts for ${pfpNFTs.length} PFP NFTs...`);
                    await window.calculateAndSaveTraitCounts(EXTERNAL_COLLECTION.collectionToken);
                    await window.loadTraitCounts();
                }

            } catch (error) {
                console.error("‚ùå Auto-detect error:", error);
                // Fail silently - don't interrupt the user experience
            }
        };

        // Manual PFP scan - triggered by button click
        window.manualPFPScan = async () => {
            if (!state.address || !state.keetaClient) {
                window.notify("Please connect your wallet first", "error");
                return;
            }
            
            window.notify("üîç Scanning wallet for Peregrine Falcon Punks...", "info");
            console.log("üîç MANUAL SCAN: User triggered PFP scan");
            
            try {
                await window.autoDetectExternalNFTs();
                console.log("‚úÖ MANUAL SCAN: Complete");
            } catch (error) {
                console.error("‚ùå MANUAL SCAN: Failed", error);
                window.notify("Scan failed. Please try again.", "error");
            }
        };

        // Calculate and save trait counts for a collection
        window.calculateAndSaveTraitCounts = async (collectionToken) => {
            try {
                console.log(`üìä Calculating trait counts for collection: ${collectionToken}`);
                
                // Get all NFTs from this collection
                const collectionNFTs = state.nfts.filter(nft => 
                    getNormalizedId(nft.collectionToken) === getNormalizedId(collectionToken)
                );
                
                if (collectionNFTs.length === 0) {
                    console.log("‚ÑπÔ∏è No NFTs found for trait count calculation");
                    return;
                }
                
                // Count each trait
                const traitCounts = {};
                collectionNFTs.forEach(nft => {
                    if (nft.attributes && Array.isArray(nft.attributes)) {
                        nft.attributes.forEach(trait => {
                            const key = `${trait.trait_type}:${trait.value}`;
                            traitCounts[key] = (traitCounts[key] || 0) + 1;
                        });
                    }
                });
                
                // Save to Firebase
                await setDoc(
                    doc(db, 'traitCounts', collectionToken),
                    traitCounts
                );
                
                console.log(`‚úÖ Saved ${Object.keys(traitCounts).length} trait counts for collection`);
                
            } catch (error) {
                console.error("‚ùå Error calculating trait counts:", error);
            }
        };

        // Create or update collection record
        window.createOrUpdateCollectionRecord = async (collectionToken, collectionName) => {
            try {
                console.log(`üìù Creating/updating collection record: ${collectionName}`);
                
                // Count how many NFTs are in this collection
                const collectionNFTs = state.nfts.filter(nft => 
                    getNormalizedId(nft.collectionToken) === getNormalizedId(collectionToken)
                );
                
                const mintedCount = collectionNFTs.length;
                
                // Get a sample NFT for the collection image
                const sampleNFT = collectionNFTs[0];
                
                const collectionData = {
                    collectionId: collectionToken,
                    collectionToken: collectionToken,
                    collectionName: collectionName,
                    collectionTitle: collectionName,
                    mintedCount: mintedCount,
                    totalSupply: 241, // From manifest
                    remainingSupply: 241 - mintedCount,
                    creator: sampleNFT?.creator || state.address,
                    createdAt: sampleNFT?.detectedAt || new Date().toISOString(),
                    imageCid: sampleNFT?.imageCid || null,
                    baseMetadataUrl: EXTERNAL_COLLECTION.baseMetadataUrl, // Add this!
                    manifestUrl: EXTERNAL_COLLECTION.manifestUrl,
                    isExternal: true,
                    autoDetected: true
                };
                
                console.log(`üíæ Saving collection with baseMetadataUrl: ${collectionData.baseMetadataUrl}`);
                
                await setDoc(
                    doc(db, 'collections', collectionToken),
                    collectionData
                );
                
                console.log(`‚úÖ Collection record saved: ${mintedCount} NFTs minted`);
                
            } catch (error) {
                console.error("‚ùå Error creating collection record:", error);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WALLET & BALANCE FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        window.refreshBalance = async () => {
            if (!state.address || !state.keetaClient) return;
            try {
                if (!state.keetaClient.baseToken) { 
                    try { await state.keetaClient.init(); } catch(e) { console.warn("Client init:", e); } 
                }
                
                const bals = await state.keetaClient.allBalances(state.address);
                if (!bals || !Array.isArray(bals)) {
                    console.warn("‚ö†Ô∏è No balances returned or invalid format");
                    return;
                }
                
                console.log("üîç DEBUG - All balances returned:", JSON.stringify(bals, (k, v) => typeof v === 'bigint' ? v.toString() : v, 2));
                console.log("üîç DEBUG - Base token ID:", state.keetaClient.baseToken);
                console.log("üîç DEBUG - Number of balance entries:", bals.length);
                
                // Try multiple ways to find KTA token
                const clientBaseTokenId = getNormalizedId(state.keetaClient.baseToken);
                let ktaToken = null;
                
                // Method 1: Find by base token flag (most reliable)
                ktaToken = bals.find(b => b.isBaseToken === true);
                if (ktaToken) console.log("‚úÖ Found KTA via isBaseToken flag");
                
                // Method 2: Match base token ID
                if (!ktaToken) {
                    ktaToken = bals.find(b => getNormalizedId(b.token) === clientBaseTokenId);
                    if (ktaToken) console.log("‚úÖ Found KTA via base token ID match");
                }
                
                // Method 3: Check symbol (case-insensitive)
                if (!ktaToken) {
                    ktaToken = bals.find(b => b.info && (b.info.symbol||'').toUpperCase() === 'KTA');
                    if (ktaToken) console.log("‚úÖ Found KTA via symbol 'KTA'");
                }
                
                // Method 4: Check name contains KTA
                if (!ktaToken) {
                    ktaToken = bals.find(b => b.info && (b.info.name||'').toUpperCase().includes('KEETA'));
                    if (ktaToken) console.log("‚úÖ Found KTA via name containing 'KEETA'");
                }
                
                // Method 5: Check if token address/ID contains relevant strings
                if (!ktaToken) {
                    ktaToken = bals.find(b => {
                        const tokenStr = (b.token||'').toLowerCase();
                        return tokenStr.includes('kta') || tokenStr.includes('keeta') || tokenStr.includes('base');
                    });
                    if (ktaToken) console.log("‚úÖ Found KTA via token ID string match");
                }
                
                // Method 6: Assume largest balance is KTA (last resort)
                if (!ktaToken && bals.length > 0) {
                    console.warn("‚ö†Ô∏è KTA not found by any method, trying largest balance");
                    ktaToken = bals.reduce((max, b) => {
                        const maxBal = BigInt((max.balance ?? max.amount ?? 0).toString().replace('n', ''));
                        const bBal = BigInt((b.balance ?? b.amount ?? 0).toString().replace('n', ''));
                        return bBal > maxBal ? b : max;
                    }, bals[0]);
                    console.log("‚ö†Ô∏è Using largest balance as KTA (fallback)");
                }

                if (ktaToken) {
                    const rawVal = (ktaToken.balance ?? ktaToken.amount ?? 0).toString().replace('n','');
                    // CRITICAL: Divide as BigInt first, then convert to Number to preserve precision
                    state.balanceKTA = Number(BigInt(rawVal)) / Number(KTA_DECIMALS);
                    const el = document.getElementById('balanceKTA');
                    if (el) el.innerText = state.balanceKTA.toFixed(4);
                    console.log("üí∞ KTA balance set:", state.balanceKTA);
                    console.log("üí∞ Raw KTA value:", rawVal);
                    console.log("üí∞ KTA token details:", JSON.stringify(ktaToken, (k, v) => typeof v === 'bigint' ? v.toString() : v, 2));
                } else {
                    console.error("‚ùå CRITICAL: No KTA token found in any balance entry!");
                    console.error("‚ùå Available tokens:", bals.map(b => ({
                        token: b.token,
                        isBaseToken: b.isBaseToken,
                        symbol: b.info?.symbol,
                        name: b.info?.name,
                        balance: (b.balance ?? b.amount ?? 0).toString()
                    })));
                    state.balanceKTA = 0;
                }



                // PUNKS token balance (FIXED: extract publicKeyString from token object)
                const punksToken = bals.find(b => {
                    // Token object might have publicKeyString property (like KeetaNet Account objects)
                    let tokenStr = '';
                    if (typeof b.token === 'string') {
                        tokenStr = b.token;
                    } else if (b.token?.publicKeyString) {
                        // KeetaNet Account object
                        tokenStr = typeof b.token.publicKeyString === 'string' 
                            ? b.token.publicKeyString 
                            : b.token.publicKeyString.get?.() || String(b.token.publicKeyString);
                    } else if (b.token?.toString && b.token.toString() !== '[object Object]') {
                        tokenStr = b.token.toString();
                    } else {
                        // Last resort: check the JSON stringified version
                        try {
                            tokenStr = JSON.parse(JSON.stringify(b.token));
                        } catch {
                            tokenStr = String(b.token);
                        }
                    }
                    
                    const matches = tokenStr === PUNKS_TOKEN_ADDRESS;
                    if (matches) {
                        console.log("‚úÖ PUNKS token FOUND!");
                        console.log("   Token string:", tokenStr);
                        console.log("   Balance:", b.balance);
                    }
                    return matches;
                });
                
                if (!punksToken) {
                    console.warn("‚ö†Ô∏è PUNKS token NOT found");
                    console.warn("   Looking for:", PUNKS_TOKEN_ADDRESS);
                    console.warn("   Available tokens:");
                    bals.forEach((b, i) => {
                        let tokenStr = '';
                        if (b.token?.publicKeyString) {
                            tokenStr = typeof b.token.publicKeyString === 'string' 
                                ? b.token.publicKeyString 
                                : (b.token.publicKeyString.get?.() || String(b.token.publicKeyString));
                        } else {
                            tokenStr = JSON.parse(JSON.stringify(b.token));
                        }
                        console.warn(`   ${i}: ${tokenStr}`);
                    });
                }
                
                const punksRaw = (punksToken?.balance ?? punksToken?.amount ?? 0).toString().replace('n','');
                state.balancePunks = punksRaw === '0' ? 0 : Number(BigInt(punksRaw)) / KTA_DECIMALS;
                
                const pEl = document.getElementById('balancePunks');
                if (pEl) pEl.innerText = state.balancePunks.toLocaleString(undefined, {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 4
                });
                
                console.log("üí∞ Final Balance - KTA:", state.balanceKTA, "PUNKS:", state.balancePunks);
                
                // Sync escrow tracker balance if visible
                const escrowBalEl = document.getElementById('escrowCurrentBalance');
                if (escrowBalEl && !escrowBalEl.closest('.hidden')) {
                    const parts = [];
                    if (state.balanceKTA > 0) parts.push(parseFloat(state.balanceKTA).toFixed(4) + ' KTA');
                    if (state.balancePunks > 0) parts.push(parseFloat(state.balancePunks).toFixed(4) + ' PUNKS');
                    escrowBalEl.textContent = parts.length > 0 ? parts.join(' + ') : '0';
                }
            } catch (e) { 
                console.error("‚ùå Balance refresh error:", e);
                console.error("‚ùå Error stack:", e.stack); 
            }
        };

        window.refreshAuthGate = () => {
            const hasAuth = !!state.address;
            const isEscrowWallet = state.address === MARKETPLACE_FEE_WALLET;
            
            document.getElementById('adminGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('forgeContainer')?.classList.toggle('hidden', !hasAuth);
            
            // UI Reset Panel - ONLY show for escrow wallet
            document.getElementById('uiWipePanel')?.classList.toggle('hidden', !isEscrowWallet);
            
            // Database Wipe Panel - ONLY show for escrow wallet
            document.getElementById('databaseWipePanel')?.classList.toggle('hidden', !isEscrowWallet);
            
            // Escrow Stats - show in escrow-admin tab
            document.getElementById('escrowAdminGate')?.classList.toggle('hidden', isEscrowWallet);
            document.getElementById('escrowAdminContent')?.classList.toggle('hidden', !isEscrowWallet);
            if (isEscrowWallet && typeof window.loadEscrowStats === 'function') window.loadEscrowStats();
            
            document.getElementById('vaultGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('vaultContainer')?.classList.toggle('hidden', !hasAuth);
            document.getElementById('watchlistGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('watchlistContainer')?.classList.toggle('hidden', !hasAuth);
            document.getElementById('transactionsGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('transactionsContainer')?.classList.toggle('hidden', !hasAuth);
            document.getElementById('portfolioGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('portfolioContainer')?.classList.toggle('hidden', !hasAuth);
            document.getElementById('offersGate')?.classList.toggle('hidden', hasAuth);
            document.getElementById('offersContainer')?.classList.toggle('hidden', !hasAuth);
            
            // Update cached items display when showing admin panel (escrow wallet only)
            if (isEscrowWallet) {
                setTimeout(() => {
                    window.updateCachedItemsDisplay();
                    window.populateWhitelistCollectionSelector();
                }, 100);
            }
        };

        window.initNeuralLink = () => {
            try {
                const modal = document.getElementById('seedModal');
                if (modal) modal.classList.remove('hidden');
                
                const grid = document.getElementById('seedGrid');
                if (grid) {
                    grid.innerHTML = '';
                    for (let i = 0; i < 24; i++) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'seed-box';
                    input.placeholder = `${i + 1}`;
                    input.autocomplete = 'off';
                    
                    input.addEventListener('paste', (e) => {
                        e.preventDefault();
                        const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                        const words = pastedText.trim().split(/\s+/);
                        
                        if (words.length >= 12) {
                            const allInputs = grid.querySelectorAll('.seed-box');
                            words.forEach((word, index) => {
                                if (allInputs[index]) {
                                    allInputs[index].value = word.toLowerCase().trim();
                                }
                            });
                            window.notify(`Pasted ${words.length} words`, "success");
                        } else {
                            input.value = pastedText;
                        }
                    });
                    
                    grid.appendChild(input);
                }
            }
            } catch (error) {
                console.error("Error in initNeuralLink:", error);
                // Fallback: just show a simple prompt
                alert("Please refresh the page and try again. If the issue persists, check the console for details.");
            }
        };

        window.closeModal = (modalId) => {
            const modal = document.getElementById(modalId);
            if (modal) modal.classList.add('hidden');
        };

        window.disconnectWallet = () => {
            state.address = null;
            state.keetaAccount = null;
            state.keetaClient = null;
            
            // FIX #6: Clear BOTH storage locations
            try {
                sessionStorage.removeItem('punkswap_wallet_seed');
                localStorage.removeItem('punkswap_wallet_seed_backup');
                console.log("‚úÖ Session cleared from both storage locations");
            } catch (e) {
                console.warn("‚ö†Ô∏è Could not clear storage:", e);
            }
            
            document.getElementById('profileOffline').classList.remove('hidden');
            document.getElementById('profileOnline').classList.add('hidden');
            window.refreshAuthGate();
            window.notify("‚úÖ Session Terminated", "success");
        };

        // Debug function to check storage status
        window.debugStorage = () => {
            console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            console.log("üîç STORAGE DEBUG REPORT");
            console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            
            try {
                // Check sessionStorage
                const sessionSeed = sessionStorage.getItem('punkswap_wallet_seed');
                console.log("üì¶ sessionStorage:");
                console.log("   - Has seed:", !!sessionSeed);
                console.log("   - Seed length:", sessionSeed ? sessionSeed.length : 0, "chars");
                console.log("   - Word count:", sessionSeed ? sessionSeed.split(/\s+/).length : 0);
                
                // Check localStorage  
                const localSeed = localStorage.getItem('punkswap_wallet_seed_backup');
                console.log("üíæ localStorage backup:");
                console.log("   - Has seed:", !!localSeed);
                console.log("   - Seed length:", localSeed ? localSeed.length : 0, "chars");
                console.log("   - Word count:", localSeed ? localSeed.split(/\s+/).length : 0);
                
                // Check current state
                console.log("üîë Current state:");
                console.log("   - Wallet connected:", !!state.address);
                console.log("   - Address:", state.address || "NOT CONNECTED");
                
                // Test storage write
                try {
                    sessionStorage.setItem('debug_test', 'test123');
                    const testRead = sessionStorage.getItem('debug_test');
                    sessionStorage.removeItem('debug_test');
                    console.log("‚úÖ Storage read/write: WORKING");
                } catch (e) {
                    console.error("‚ùå Storage read/write: BROKEN -", e.message);
                }
                
                console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                
                window.notify("Check console for storage report", "info");
            } catch (e) {
                console.error("‚ùå Debug failed:", e);
            }
        };

        // Clear corrupted session data
        window.clearCorruptedSession = () => {
            if (confirm("Clear all saved session data?\n\nThis will sign you out and remove any corrupted wallet data.")) {
                try {
                    // Clear localStorage
                    sessionStorage.removeItem('punkswap_wallet_seed');
                    
                    // Clear state
                    state.address = null;
                    state.keetaAccount = null;
                    state.keetaClient = null;
                    
                    // Clear UI
                    document.querySelectorAll('.seed-box').forEach(box => {
                        if (box) box.value = '';
                    });
                    
                    // Reset profile
                    document.getElementById('profileOffline').classList.remove('hidden');
                    document.getElementById('profileOnline').classList.add('hidden');
                    
                    window.refreshAuthGate();
                    
                    window.notify("‚úÖ Session data cleared - please sign in again", "success");
                    
                    console.log("üßπ All session data cleared");
                } catch (error) {
                    console.error("Error clearing session:", error);
                    window.notify("Manual clear needed - check console", "error");
                }
            }
        };

        window.importWallet = async () => {
            const raw = Array.from(document.querySelectorAll('.seed-box')).map(i => (i?.value || '').toLowerCase().trim());
            
            // Less strict filtering - just remove obvious non-words
            const words = raw.filter(w => {
                if (!w || w.length < 2) return false;
                if (w.startsWith('keeta_')) return false;
                if (/^https?:\/\//.test(w)) return false;
                return true;
            });
            
            console.log('üîç DEBUG - Seed validation:');
            console.log('- Raw input length:', raw.join(' ').length);
            console.log('- Split words count:', raw.length);
            console.log('- Filtered words count:', words.length);
            console.log('- First 3 words:', words.slice(0, 3));
            console.log('- Last 3 words:', words.slice(-3));
            
            if (words.length !== 12 && words.length !== 24) {
                console.error('‚ùå Invalid word count:', words.length);
                
                // Clear corrupted localStorage
                try {
                    sessionStorage.removeItem('punkswap_wallet_seed');
                    console.log('üßπ Cleared corrupted seed from localStorage');
                } catch (e) {
                    console.warn('Could not clear localStorage:', e);
                }
                
                return window.notify(`Invalid seed phrase (Need 12 or 24 words, got ${words.length})`, "error");
            }
            
            try {
                window.notify("Connecting wallet...", "success");
                
                const passphrase = words.join(' ');
                console.log('‚úÖ Seed validation passed');
                
                const hex = await KeetaNet.lib.Account.seedFromPassphrase(passphrase, { asString: true });
                state.keetaAccount = KeetaNet.lib.Account.fromSeed(hex, 0);
                state.address = state.keetaAccount.publicKeyString.get();
                // Try mainnet - SDK loaded from static.network.keeta.com suggests this is mainnet SDK
                // Common patterns: '', 'production', 'main', or just 'test' might work differently on mainnet SDK
                try {
                    state.keetaClient = KeetaNet.UserClient.fromNetwork('', state.keetaAccount);
                    console.log("‚úÖ Connected to network with '' parameter");
                } catch (e) {
                    console.warn("Failed with '', trying 'production':", e.message);
                    try {
                        state.keetaClient = KeetaNet.UserClient.fromNetwork('production', state.keetaAccount);
                        console.log("‚úÖ Connected to network with 'production' parameter");
                    } catch (e2) {
                        console.warn("Failed with 'production', trying 'main':", e2.message);
                        try {
                            state.keetaClient = KeetaNet.UserClient.fromNetwork('main', state.keetaAccount);
                            console.log("‚úÖ Connected to network with 'main' parameter");
                        } catch (e3) {
                            console.warn("Failed with 'main', falling back to 'test':", e3.message);
                            state.keetaClient = KeetaNet.UserClient.fromNetwork('test', state.keetaAccount);
                            console.log("‚úÖ Connected to network with 'test' parameter (fallback)");
                        }
                    }
                }
                
                // Save to BOTH sessionStorage AND localStorage for redundancy
                try {
                    sessionStorage.setItem('punkswap_wallet_seed', passphrase);
                    localStorage.setItem('punkswap_wallet_seed_backup', passphrase);
                    console.log("‚úÖ Wallet saved to session AND backup");
                    console.log("üîë Saved seed length:", passphrase.length, "characters");
                } catch (storageError) {
                    console.warn("‚ö†Ô∏è Could not save to storage:", storageError);
                }
                
                document.getElementById('profileOffline').classList.add('hidden');
                document.getElementById('profileOnline').classList.remove('hidden');
                document.getElementById('walletAddressDisplay').innerText = state.address;
                
                window.closeModal('seedModal');
                
                console.log("üîê Wallet connected:", state.address);
                
                const linkLoop = async () => {
                    try {
                        if (state.keetaClient && typeof state.keetaClient.init === 'function') {
                            await state.keetaClient.init();
                        }
                        await window.refreshBalance();
                        window.refreshAuthGate();
                        window.checkEscrowAccess();
                        await window.loadNFTsFromFirebase();
                        await window.loadCollections();
                        await window.loadTraitCounts();
                        
                        // ‚ö° AUTO-DETECT: Scan for Peregrine Falcon Punks collection
                        await window.autoDetectExternalNFTs();
                        
                        // üìä Load transaction history
                        await window.loadTransactions();
                        await window.loadOffers();
                        
                        // üíº Calculate portfolio (after all data loaded)
                        setTimeout(() => {
                            window.calculatePortfolio();
                        }, 1000);
                    } catch (e) { 
                        console.warn("Link initialization delay, retrying...");
                        setTimeout(linkLoop, 3000); 
                    }
                };
                linkLoop();
                
            } catch (e) { 
                console.error("Authorization error:", e);
                window.notify("Authorization Failure", "error"); 
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIREBASE NFT FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UNIVERSAL WALLET SYNC - Detect transfers outside marketplace
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.syncWalletNFTs = async () => {
            if (!state.address || !state.keetaClient) {
                console.log("‚ö†Ô∏è Wallet not connected, skipping sync");
                return;
            }
            
            try {
                console.log("üîÑ WALLET SYNC: Scanning blockchain for all NFTs...");
                
                // Get all tokens in wallet from blockchain
                const balances = await state.keetaClient.allBalances(state.address);
                
                if (!balances || !Array.isArray(balances)) {
                    console.warn("‚ö†Ô∏è Could not fetch wallet balances");
                    return;
                }
                
                // Filter to NFTs (balance = 1, not KTA)
                const walletNFTs = balances.filter(b => 
                    b.balance === '1' && 
                    b.token && 
                    b.token.$type !== 'KTA'
                );
                
                console.log(`üíé Found ${walletNFTs.length} NFTs in wallet`);
                
                let syncedCount = 0;
                let removedCount = 0;
                
                // CHECK 1: Update ownership for NFTs user now owns
                for (const walletNFT of walletNFTs) {
                    const tokenId = walletNFT.token.publicKeyString?.get() || walletNFT.token;
                    
                    // Check if this NFT exists in Firebase
                    const existingNFT = state.nfts.find(n => 
                        getNormalizedId(n.tokenId) === getNormalizedId(tokenId)
                    );
                    
                    if (existingNFT) {
                        // NFT exists in Firebase - check if owner is correct
                        if (getNormalizedId(existingNFT.owner) !== getNormalizedId(state.address)) {
                            console.log(`üîÑ Updating ownership: ${existingNFT.name || tokenId.substring(0, 20)}`);
                            
                            // Update Firebase
                            await updateDoc(
                                doc(db, 'nfts', existingNFT.id),
                                {
                                    owner: state.address,
                                    inEscrow: false,
                                    isListed: false,
                                    listedPrice: null,
                                    listedCurrency: null,
                                    updatedAt: new Date().toISOString()
                                }
                            );
                            
                            syncedCount++;
                        }
                    }
                }
                
                // CHECK 2: Remove NFTs user no longer owns
                const walletTokenIds = new Set(
                    walletNFTs.map(nft => {
                        const tokenId = nft.token.publicKeyString?.get() || nft.token;
                        return getNormalizedId(tokenId);
                    })
                );
                
                for (const fbNFT of state.nfts) {
                    // SKIP external auto-detected NFTs - they're from other wallets
                    if (fbNFT.isExternal && fbNFT.source === 'auto-detect') {
                        continue;
                    }
                    
                    // If Firebase says we own it, but wallet doesn't have it
                    if (getNormalizedId(fbNFT.owner) === getNormalizedId(state.address)) {
                        const normalizedToken = getNormalizedId(fbNFT.tokenId);
                        
                        if (!walletTokenIds.has(normalizedToken)) {
                            console.log(`üîÑ NFT transferred out: ${fbNFT.name || fbNFT.tokenId.substring(0, 20)}`);
                            
                            // Update Firebase - mark as transferred (owner = null or previous owner)
                            await updateDoc(
                                doc(db, 'nfts', fbNFT.id),
                                {
                                    owner: null,  // Unknown owner
                                    inEscrow: false,
                                    isListed: false,
                                    listedPrice: null,
                                    listedCurrency: null,
                                    updatedAt: new Date().toISOString(),
                                    transferredOutside: true
                                }
                            );
                            
                            removedCount++;
                        }
                    }
                }
                
                if (syncedCount > 0 || removedCount > 0) {
                    console.log(`‚úÖ WALLET SYNC: ${syncedCount} NFTs synced, ${removedCount} removed`);
                    
                    // Refresh UI
                    await window.loadNFTsFromFirebase();
                    await window.renderCollection();
                    
                    window.notify(`Wallet synced: ${syncedCount} updated, ${removedCount} removed`, "success");
                } else {
                    console.log("‚úÖ WALLET SYNC: All NFTs already in sync");
                }
                
            } catch (error) {
                console.error("‚ùå Wallet sync failed:", error);
            }
        };
        
        // Auto-sync on wallet connection and periodically
        window.startAutoSync = () => {
            // Sync immediately
            window.syncWalletNFTs();
            
            // Sync every 30 seconds
            if (window.autoSyncInterval) {
                clearInterval(window.autoSyncInterval);
            }
            window.autoSyncInterval = setInterval(() => {
                if (state.address) {
                    window.syncWalletNFTs();
                }
            }, 30000); // 30 seconds
        };
        
        // Stop auto-sync (call on disconnect)
        window.stopAutoSync = () => {
            if (window.autoSyncInterval) {
                clearInterval(window.autoSyncInterval);
                window.autoSyncInterval = null;
            }
        };

        


        // RARITY SCORING SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.calculateRarityScore = (nft, allNFTsInCollection) => {
            if (!nft.attributes || !Array.isArray(nft.attributes)) {
                return { score: 0, rank: null, percentile: 0 };
            }
            
            const collectionSize = allNFTsInCollection.length;
            if (collectionSize === 0) return { score: 0, rank: null, percentile: 0 };
            
            let totalScore = 0;
            const traitScores = [];
            
            // Calculate score for each trait
            for (const trait of nft.attributes) {
                const traitType = trait.trait_type;
                const traitValue = trait.value;
                
                // Count how many NFTs have this exact trait
                const countWithTrait = allNFTsInCollection.filter(n => {
                    if (!n.attributes) return false;
                    return n.attributes.some(a => 
                        a.trait_type === traitType && a.value === traitValue
                    );
                }).length;
                
                // Rarity formula: 1 / (frequency / total)
                const frequency = countWithTrait / collectionSize;
                const traitScore = frequency > 0 ? (1 / frequency) : 0;
                
                traitScores.push({
                    trait_type: traitType,
                    value: traitValue,
                    count: countWithTrait,
                    frequency: (frequency * 100).toFixed(1) + '%',
                    score: traitScore
                });
                
                totalScore += traitScore;
            }
            
            // Calculate rank
            const allScores = allNFTsInCollection.map(n => {
                if (!n.attributes) return 0;
                let score = 0;
                for (const trait of n.attributes) {
                    const countWithTrait = allNFTsInCollection.filter(x => 
                        x.attributes && x.attributes.some(a => 
                            a.trait_type === trait.trait_type && a.value === trait.value
                        )
                    ).length;
                    const freq = countWithTrait / collectionSize;
                    score += freq > 0 ? (1 / freq) : 0;
                }
                return score;
            }).sort((a, b) => b - a); // Descending order
            
            const rank = allScores.indexOf(totalScore) + 1;
            const percentile = ((collectionSize - rank) / collectionSize * 100).toFixed(1);
            
            return {
                score: totalScore,
                rank: rank,
                total: collectionSize,
                percentile: parseFloat(percentile),
                traitScores: traitScores,
                formattedScore: totalScore.toFixed(2)
            };
        };
        
        window.addRarityToNFTs = () => {
            console.log("üé≤ Calculating rarity scores...");
            
            // Group NFTs by collection
            const byCollection = {};
            for (const nft of state.nfts) {
                const colId = nft.collectionId || nft.collectionToken;
                if (!colId) continue;
                if (!byCollection[colId]) byCollection[colId] = [];
                byCollection[colId].push(nft);
            }
            
            // Calculate rarity for each NFT
            let calculated = 0;
            for (const [colId, nfts] of Object.entries(byCollection)) {
                for (const nft of nfts) {
                    const rarity = window.calculateRarityScore(nft, nfts);
                    nft.rarity = rarity;
                    calculated++;
                }
            }
            
            console.log(`‚úÖ Calculated rarity for ${calculated} NFTs across ${Object.keys(byCollection).length} collections`);
            return calculated;
        };
        
        window.getRarityBadgeHTML = (rarity) => {
            if (!rarity || !rarity.rank) return '';
            
            let badgeColor = 'gray';
            let badgeText = 'Common';
            
            // Percentile-based rarity tiers
            if (rarity.percentile >= 95) {
                badgeColor = 'from-yellow-400 to-orange-500';
                badgeText = 'Legendary';
            } else if (rarity.percentile >= 85) {
                badgeColor = 'from-purple-500 to-pink-500';
                badgeText = 'Epic';
            } else if (rarity.percentile >= 70) {
                badgeColor = 'from-blue-500 to-cyan-500';
                badgeText = 'Rare';
            } else if (rarity.percentile >= 50) {
                badgeColor = 'from-green-500 to-emerald-500';
                badgeText = 'Uncommon';
            } else {
                badgeColor = 'from-gray-600 to-gray-700';
                badgeText = 'Common';
            }
            
            return `
                <div class="absolute top-2 left-2 z-10">
                    <div class="bg-gradient-to-r ${badgeColor} px-2 py-1 rounded text-[8px] orbitron font-black text-white shadow-lg">
                        #${rarity.rank} / ${rarity.total}
                    </div>
                    <div class="bg-black/80 mt-1 px-2 py-0.5 rounded text-[7px] fira text-white">
                        ${badgeText}
                    </div>
                </div>
            `;
        };
        
        window.sortNFTsByRarity = (nfts, order = 'desc') => {
            return [...nfts].sort((a, b) => {
                const scoreA = a.rarity?.score || 0;
                const scoreB = b.rarity?.score || 0;
                return order === 'desc' ? scoreB - scoreA : scoreA - scoreB;
            });
        };

        window.loadNFTsFromFirebase = async () => {
            try {
                console.log("üì• Loading NFTs from Firebase...");
                
                const nftsRef = collection(db, 'nfts');
                const snapshot = await getDocs(nftsRef);
                
                state.nfts = [];
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    state.nfts.push({
                        id: doc.id,
                        ...data
                    });
                });
                
                console.log(`‚úÖ Loaded ${state.nfts.length} NFTs from Firebase`);
                if (state.nfts.length > 0) {
                    console.log("üì¶ Sample NFT:", state.nfts[0]);
                    console.log("üì¶ First NFT keys:", Object.keys(state.nfts[0]));
                    
                    // üé≤ Calculate rarity scores for all NFTs
                    const rarityCount = window.addRarityToNFTs();
                    console.log(`üé≤ Calculated rarity for ${rarityCount} NFTs`);
                } else {
                    console.warn("‚ö†Ô∏è Query returned 0 NFTs - checking Firebase path...");
                    console.log("üîç Expected path:", `nfts`);
                    console.log("üîç Check Firebase Console: Is data at this exact path?");
                }
                window.updateStats();
                window.renderMarketplace();
                window.renderDrops();
                // FIX #7: Also refresh user's collection view
                window.renderCollection();
                
                // FIX #1: Fetch metadata for NFTs missing traits
                await window.enrichNFTMetadata();
                
                return state.nfts;
            } catch (error) {
                console.error("‚ùå Error loading NFTs:", error);
                window.notify("Error loading marketplace data", "error");
                return [];
            }
        };

        // ACTIVITY FEED - Real-time marketplace activity
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.initActivityFeed = () => {
            console.log("üì∞ Initializing activity feed...");
            
            // Listen to transactions collection for real-time updates
            const txQuery = query(
                collection(db, 'transactions'),
                orderBy('timestamp', 'desc'),
                limit(50)
            );
            
            onSnapshot(
                txQuery, 
                (snapshot) => {
                    console.log("üì∞ Activity feed updated");
                    window.renderActivityFeed();
                },
                (error) => {
                    console.error("‚ùå Activity feed listener error:", error.message);
                    // Don't retry immediately to prevent infinite loops
                    setTimeout(() => {
                        console.log("üîÑ Retrying activity feed connection...");
                        window.initActivityFeed();
                    }, 5000);
                }
            );
        };
        
        window.renderActivityFeed = () => {
            const container = document.getElementById('activityFeedContainer');
            if (!container) return;
            
            // Get recent transactions (last 7 days) - increased from 24 hours
            const now = Date.now();
            const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
            
            const recentActivity = state.transactions
                .filter(tx => {
                    const txTime = new Date(tx.timestamp).getTime();
                    return txTime > sevenDaysAgo;
                })
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                .slice(0, 50);  // Increased from 20 to 50
            
            if (recentActivity.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-8 text-gray-500 fira text-sm">
                        No recent activity (last 7 days)
                    </div>
                `;
                return;
            }
            
            container.innerHTML = recentActivity.map(tx => {
                const timeAgo = window.getTimeAgo(tx.timestamp);
                const nft = state.nfts.find(n => n.id === tx.nftId || n.tokenId === tx.nftId);
                const nftName = tx.nftName || nft?.name || 'Unknown NFT';
                const collection = state.collections.find(c => c.collectionId === tx.collectionId || c.collectionId === nft?.collectionId);
                const collectionName = tx.collection || collection?.collectionTitle || 'Unknown Collection';
                
                let icon = 'üí∞';
                let action = '';
                let color = 'text-cyan-400';
                
                // Map transaction types to activity feed messages
                switch(tx.type) {
                    case 'mint':
                    case 'MINT':
                        icon = 'üé®';
                        action = 'minted';
                        color = 'text-green-400';
                        break;
                    case 'sale':
                    case 'SALE':
                        icon = 'üíé';
                        action = 'sold';
                        color = 'text-cyan-400';
                        break;
                    case 'purchase':
                    case 'PURCHASE':
                        icon = 'üõí';
                        action = 'bought';
                        color = 'text-purple-400';
                        break;
                    case 'listing':
                    case 'LIST':
                    case 'list':
                        icon = 'üìã';
                        action = 'listed';
                        color = 'text-yellow-400';
                        break;
                    case 'auction':
                    case 'AUCTION':
                        icon = '‚ö°';
                        action = 'auctioned';
                        color = 'text-orange-400';
                        break;
                    case 'cancellation':
                    case 'CANCEL':
                    case 'cancel':
                        icon = '‚ùå';
                        action = 'cancelled listing for';
                        color = 'text-red-400';
                        break;
                    case 'offer':
                    case 'OFFER':
                        icon = 'üí∞';
                        action = 'offered on';
                        color = 'text-yellow-400';
                        break;
                    default:
                        icon = 'üìù';
                        action = tx.type || 'interacted with';
                        color = 'text-gray-400';
                }
                
                const actor = tx.wallet || tx.buyer || tx.seller || state.address;
                const actorShort = actor ? actor.substring(0, 6) + '...' + actor.substring(actor.length - 4) : 'Someone';
                
                return `
                    <div class="flex items-center gap-3 p-3 rounded-lg hover:bg-white/5 transition-all group cursor-pointer border border-white/5 hover:border-cyan-500/30">
                        <div class="text-2xl">${icon}</div>
                        <div class="flex-1 min-w-0">
                            <div class="fira text-xs ${color}">
                                <span class="font-bold">${actorShort}</span>
                                <span class="text-gray-400"> ${action} </span>
                                <span class="font-bold text-white truncate">${nftName}</span>
                            </div>
                            <div class="fira text-[10px] text-gray-600 mt-0.5">
                                ${collectionName} ‚Ä¢ ${timeAgo}
                            </div>
                        </div>
                        ${tx.price > 0 ? `
                            <div class="orbitron text-xs font-bold ${color}">
                                ${tx.price} ${tx.currency || 'KTA'}
                            </div>
                        ` : (tx.price === 0 && tx.type !== 'cancellation' ? `
                            <div class="orbitron text-xs font-bold text-green-400">
                                FREE
                            </div>
                        ` : '')}
                    </div>
                `;
            }).join('');
        };
        
        window.getTimeAgo = (timestamp) => {
            const now = Date.now();
            const then = new Date(timestamp).getTime();
            const diff = now - then;
            
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            if (minutes > 0) return `${minutes}m ago`;
            return 'just now';
        };

        // FIX #1: Enrich NFTs with missing metadata
        window.enrichNFTMetadata = async () => {
            const nftsNeedingMetadata = state.nfts.filter(n => 
                !n.attributes || n.attributes.length === 0
            );
            
            if (nftsNeedingMetadata.length === 0) return;
            
            console.log(`üîç Fetching metadata for ${nftsNeedingMetadata.length} NFTs...`);
            
            for (const nft of nftsNeedingMetadata) {
                try {
                    await window.fetchNFTMetadata(nft);
                    await new Promise(r => setTimeout(r, 200));
                } catch (error) {
                    console.error(`Failed to fetch metadata for ${nft.id}:`, error);
                }
            }
        };

        window.setupNFTListener = () => {
            try {
                console.log("üëÇ Setting up Firebase listeners...");
                
                // Debounce helper to prevent excessive re-renders
                let renderTimeout = null;
                const debouncedRender = () => {
                    if (renderTimeout) clearTimeout(renderTimeout);
                    renderTimeout = setTimeout(() => {
                        window.renderMarketplace();
                        window.renderDrops();
                    }, 300); // Wait 300ms before rendering
                };
                
                const nftsRef = collection(db, 'nfts');
                
                onSnapshot(nftsRef, 
                    (snapshot) => {
                        console.log("üîÑ NFT data updated, refreshing...");
                        state.nfts = [];
                        snapshot.forEach((doc) => {
                            state.nfts.push({
                                id: doc.id,
                                ...doc.data()
                            });
                        });
                        
                        window.updateStats();
                        debouncedRender();
                        
                        // CRITICAL: Update charts in real-time
                        console.log("üìä Updating charts from real-time data...");
                        window.updateMarketChart();
                        
                        if (state.viewingCollection) {
                            window.updateCollectionDepth(state.viewingCollection);
                            // Also refresh the collection detail grid
                            if (typeof window.renderFilteredCollection === 'function') {
                                window.renderFilteredCollection();
                            }
                        }
                    },
                    (error) => {
                        console.error("‚ùå NFT listener error:", error.message || error);
                        console.warn("‚ö†Ô∏è Firestore NFT listener encountered an error. Will retry automatically.");
                        // Firestore automatically retries, no need to manually reconnect
                        // Adding manual retry can cause duplicate listeners
                    }
                );
                
                // NEW: Real-time transaction listener for charts
                const txRef = collection(db, 'transactions');
                onSnapshot(txRef, 
                    (snapshot) => {
                        console.log("üí≥ Transaction data updated, refreshing charts...");
                        
                        // Update all charts when transactions change
                        window.updateMarketChart();
                        
                        if (state.viewingCollection) {
                            window.updateCollectionDepth(state.viewingCollection);
                        }
                        
                        // Always refresh transaction list when data changes (so it's fresh when user switches to tab)
                        if (state.address) {
                            window.loadTransactions();
                        }
                    },
                    (error) => {
                        console.error("‚ùå Transaction listener error:", error.message || error);
                        console.warn("‚ö†Ô∏è Firestore transaction listener encountered an error. Will retry automatically.");
                        // Firestore automatically retries, no manual intervention needed
                    }
                );
                
                // NEW: Real-time collections listener to update blind mint cards
                const collectionsRef = collection(db, 'collections');
                let lastCollectionUpdate = 0;
                onSnapshot(collectionsRef, 
                    (snapshot) => {
                        // Throttle collection updates to max once per second
                        const now = Date.now();
                        if (now - lastCollectionUpdate < 1000) {
                            console.log("‚è∏Ô∏è Collection update throttled");
                            return;
                        }
                        lastCollectionUpdate = now;
                        
                        console.log("üîÑ Collection data updated, refreshing drops...");
                        
                        // Update state.collections
                        state.collections = [];
                        snapshot.forEach((doc) => {
                            state.collections.push({
                                id: doc.id,
                                ...doc.data()
                            });
                        });
                        
                        // Use debounced render
                        debouncedRender();
                    },
                    (error) => {
                        console.error("‚ùå Collection listener error:", error.message || error);
                        console.warn("‚ö†Ô∏è Firestore collection listener encountered an error. Will retry automatically.");
                        // Firestore SDK handles reconnection automatically
                    }
                );
                
                console.log("üëÇ Real-time NFT, Transaction & Collection listeners active");
            } catch (error) {
                console.error("Error setting up listeners:", error);
            }
        };

        window.updateTraitCounts = async (collectionId, traits) => {
            if (!traits || traits.length === 0) return;
            
            try {
                const traitCountsRef = doc(db, 'traitCounts', collectionId);
                const countSnap = await getDoc(traitCountsRef);
                
                let counts = countSnap.exists() ? countSnap.data() : {};
                
                traits.forEach(trait => {
                    const key = `${trait.trait_type}:${trait.value}`;
                    counts[key] = (counts[key] || 0) + 1;
                });
                
                await setDoc(traitCountsRef, counts);
                console.log("‚úÖ Trait counts updated");
            } catch (error) {
                console.error("Error updating trait counts:", error);
            }
        };

        window.loadTraitCounts = async () => {
            if (!db) return;
            
            try {
                const countsRef = collection(db, 'traitCounts');
                const snapshot = await getDocs(countsRef);
                
                state.traitCounts = {};
                snapshot.forEach(doc => {
                    // FIX: Load the 'counts' field from the document (for PFP traits saved in Firebase)
                    state.traitCounts[doc.id] = doc.data().counts || doc.data();
                });
                
                console.log(`‚úÖ Loaded trait counts for ${snapshot.size} collections`);
            } catch (error) {
                console.error("Error loading trait counts:", error);
            }
        };

        window.loadCollections = async () => {
            if (!db) return;
            
            try {
                // Try primary path first
                let collectionsRef = collection(db, 'collections');
                let snapshot = await getDocs(collectionsRef);
                
                state.collections = [];
                snapshot.forEach(doc => {
                    state.collections.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(`‚úÖ Loaded ${state.collections.length} collections`);
                if (state.collections.length > 0) {
                    console.log("üì¶ Sample collection:", state.collections[0]);
                    console.log("üìç Collections loaded from Firebase successfully");
                } else {
                    console.warn("‚ö†Ô∏è Query returned 0 collections");
                    console.log("üîç Check these paths in Firebase:");
                    console.log("   1.", `collections`);
                    console.log("   2.", `collections`);
                    console.log("üí° Collections may be stored elsewhere in your database");
                }
                
                // Load wallet mint tracking for whitelist phase display
                await window.loadWalletMintTracking();
                
                window.renderCollections();
                window.populateWhitelistCollections(); // Populate whitelist dropdown
                window.populateVerificationSelector(); // Populate verification dropdown
                window.populateCommentCollectionDropdown(); // Populate comment dropdown
                window.renderMyWhitelists(); // Render My Whitelists section
                window.renderPreMintCollections(); // Render Pre-Mint Collections section
                window.updateAirdropVisibility();
                
                // Show/hide verification panel (escrow only)
                const verificationPanel = document.getElementById('verificationPanel');
                if (verificationPanel && state.address === ESCROW_WALLET) {
                    verificationPanel.classList.remove('hidden');
                } else if (verificationPanel) {
                    verificationPanel.classList.add('hidden');
                }
                
            } catch (error) {
                console.error("Error loading collections:", error);
            }
        };

        // DEBUG HELPER: Show all collections with their current state
        window.debugCollections = () => {
            console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            console.log("üîç ALL COLLECTIONS DEBUG INFO");
            console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            console.log(`Total collections: ${state.collections.length}`);
            console.log(`Total NFTs in state: ${state.nfts.length}`);
            
            // Group NFTs by collectionToken
            const nftsByToken = {};
            state.nfts.forEach(n => {
                const key = getNormalizedId(n.collectionToken) || 'NO_TOKEN';
                if (!nftsByToken[key]) nftsByToken[key] = [];
                nftsByToken[key].push(n);
            });
            
            console.log(`\nNFTs grouped by collectionToken:`);
            Object.entries(nftsByToken).forEach(([token, nfts]) => {
                const col = state.collections.find(c => getNormalizedId(c.collectionToken) === token);
                console.log(`  ${col?.collectionTitle || 'UNKNOWN'} (${token.substring(0, 30)}...): ${nfts.length} NFTs`);
                nfts.forEach(n => {
                    console.log(`    - ${n.name} | owner: ${(n.owner||'').substring(0,20)}... | status: ${n.status || 'none'} | listed: ${n.isListed} | inEscrow: ${n.inEscrow}`);
                });
            });
            
            state.collections.forEach((col, idx) => {
                const colToken = getNormalizedId(col.collectionToken);
                const matchedNFTs = state.nfts.filter(n => getNormalizedId(n.collectionToken) === colToken);
                const byIdNFTs = state.nfts.filter(n => n.collectionId === col.collectionId);
                
                console.log(`\n[${idx + 1}] ${col.collectionTitle || 'Untitled'}`);
                console.log(`    ID: ${col.collectionId}`);
                console.log(`    Token: ${col.collectionToken}`);
                console.log(`    Minted: ${col.mintedCount || 0} / ${col.totalSupply || 0}`);
                console.log(`    NFTs matched by token: ${matchedNFTs.length}`);
                console.log(`    NFTs matched by collectionId: ${byIdNFTs.length}`);
                if (matchedNFTs.length !== byIdNFTs.length) {
                    console.warn(`    ‚ö†Ô∏è MISMATCH! Some NFTs have wrong collectionToken!`);
                    byIdNFTs.forEach(n => {
                        if (!matchedNFTs.includes(n)) {
                            console.warn(`      ‚ùå ${n.name} has collectionToken: ${n.collectionToken} (expected: ${col.collectionToken})`);
                        }
                    });
                }
                console.log(`    Blind Mint: ${col.blindMintEnabled ? 'YES' : 'NO'}`);
            });
            
            console.log("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            console.log("üí° Type: window.loadCollections() to refresh");
            console.log("üí° Type: window.showAllCollections() to bypass filters");
            console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        };

        // EMERGENCY: Show ALL collections regardless of filters
        window.showAllCollections = () => {
            console.log("üö® EMERGENCY MODE: Showing ALL collections (bypassing filters)");
            console.log("üìä Total collections in state:", state.collections.length);
            
            // Log each collection's details
            state.collections.forEach((col, idx) => {
                console.log(`\n[${idx + 1}] ${col.collectionTitle || 'Untitled'}`);
                console.log(`    Minted: ${col.mintedCount || 0} / ${col.totalSupply || 0}`);
                console.log(`    Remaining: ${col.remainingSupply}`);
                console.log(`    Blind: ${col.blindMintEnabled ? 'YES' : 'NO'}`);
            });
            
            const blindDropContainer = document.getElementById('dropGrid');
            const regularContainer = document.getElementById('regularCollectionGrid');
            
            if (!blindDropContainer || !regularContainer) {
                console.error("‚ùå Grid elements not found!");
                return;
            }
            
            // Get the render function from renderCollections
            const renderCollectionCard = (col, isBlindMint) => {
                // Simplified version - just show the collection
                const displayImage = isBlindMint 
                    ? getIPFSUrl('bafybeidgzwxcrhvf2jpo65gtqrt33otfk4yqwjc5vadntpp4yntqohvgtm')
                    : (col.previewImageUrl || col.collectionThumbnail || 'https://via.placeholder.com/400?text=No+Image');
                
                const remainingDisplay = col.remainingSupply ?? '?';
                const canMint = (col.remainingSupply ?? 0) > 0;
                
                return `
                    <div class="glass-card p-6 border-${canMint ? 'cyan' : 'red'}-500/20 hover:border-${canMint ? 'cyan' : 'red'}-500/40 transition-all">
                        <img src="${displayImage}" class="w-full h-48 object-cover rounded-lg mb-4" />
                        <h4 class="orbitron text-sm font-bold text-white mb-2">${col.collectionTitle || 'Untitled'}</h4>
                        <p class="fira text-xs text-gray-400">Minted: ${col.mintedCount || 0} / ${col.totalSupply || 0}</p>
                        <p class="fira text-xs text-${remainingDisplay === '?' ? 'red' : 'gray'}-400">Remaining: ${remainingDisplay}</p>
                        <p class="fira text-xs text-gray-400">Blind: ${col.blindMintEnabled ? 'Yes' : 'No'}</p>
                        <button onclick="window.mintFromCollection('${col.collectionId}')" class="btn-primary w-full mt-4 ${!canMint ? 'opacity-50 cursor-not-allowed' : ''}">
                            ${canMint ? 'Mint Now' : 'Sold Out / Error'}
                        </button>
                    </div>
                `;
            };
            
            // Show ALL collections
            if (state.collections.length === 0) {
                regularContainer.innerHTML = '<p class="text-red-500 text-center py-20">‚ùå No collections found in database!<br>Check Firebase console.</p>';
            } else {
                const allHTML = state.collections.map(col => renderCollectionCard(col, col.blindMintEnabled)).join('');
                regularContainer.innerHTML = allHTML;
            }
            blindDropContainer.innerHTML = '<p class="text-yellow-500 text-center py-8">üö® Emergency Mode Active - All collections shown in Active Collections section above</p>';
            
            window.notify(`Showing ALL ${state.collections.length} collections`, "success");
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #2 & #3: MINT FUNCTIONS - USES KEETA MINT PIPELINE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BATCH MINT - Wrapper around existing mint (doesn't modify core logic)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.executeBatchMint = async (collectionId, quantity) => {
            if (!quantity || quantity < 1 || quantity > 10) {
                window.notify("Quantity must be between 1-10", "error");
                return { success: false, error: "Invalid quantity" };
            }
            if (!window.acquireTxLock(`batch_${collectionId}`)) return window.notify("Batch mint already in progress...", "warning");
            
            console.log(`üé® Starting batch mint: ${quantity} NFTs`);
            
            const results = {
                successful: [],
                failed: [],
                total: quantity
            };
            
            // Show batch progress modal
            window.showBatchMintProgress(quantity);
            
            // ‚ö° PARALLEL MINTING - All at once for max speed!
            console.log(`‚ö° Starting ${quantity} parallel mints...`);
            
            // Create array of mint promises
            const mintPromises = [];
            for (let i = 0; i < quantity; i++) {
                const current = i + 1;
                
                // Create mint promise
                const mintPromise = (async () => {
                    console.log(`\nüé® ‚ïê‚ïê‚ïê MINTING ${current}/${quantity} ‚ïê‚ïê‚ïê`);
                    window.updateBatchMintProgress(current, quantity, 'minting');
                    
                    try {
                        // Call YOUR EXISTING, WORKING mint function!
                        const result = await window.mintFromCollection(collectionId);
                        
                        if (result && result.success) {
                            results.successful.push(result);
                            window.updateBatchMintProgress(current, quantity, 'success');
                            console.log(`‚úÖ Mint ${current}/${quantity} successful`);
                            return { success: true, index: current, result };
                        } else {
                            results.failed.push({ index: current, error: result?.error || 'Unknown error' });
                            window.updateBatchMintProgress(current, quantity, 'failed');
                            console.error(`‚ùå Mint ${current}/${quantity} failed:`, result?.error);
                            return { success: false, index: current, error: result?.error };
                        }
                    } catch (error) {
                        results.failed.push({ index: current, error: error.message });
                        window.updateBatchMintProgress(current, quantity, 'failed');
                        console.error(`‚ùå Mint ${current}/${quantity} error:`, error);
                        return { success: false, index: current, error: error.message };
                    }
                })();
                
                mintPromises.push(mintPromise);
                
                // Tiny stagger (100ms) to prevent exact simultaneous hits
                if (i < quantity - 1) {
                    await new Promise(r => setTimeout(r, 100));
                }
            }
            
            // Wait for all mints to complete
            console.log(`‚è≥ Waiting for all ${quantity} mints to complete...`);
            await Promise.allSettled(mintPromises);
            console.log(`‚úÖ All ${quantity} mints processed!`);
            
            // Show final results
            window.showBatchMintResults(results);
            
            console.log(`\nüéâ Batch mint complete:`, results);
            return results;
        };

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BATCH MINT PROGRESS UI
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.showBatchMintProgress = (total) => {
            const modal = document.createElement('div');
            modal.id = 'batchMintModal';
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-md w-full mx-4">
                    <h3 class="orbitron text-xl text-cyan-400 font-bold mb-6 text-center">Batch Minting Progress</h3>
                    <div id="batchMintProgressContainer" class="space-y-4">
                        <!-- Progress items will be added here -->
                    </div>
                    <div class="mt-6 text-center">
                        <div class="text-sm text-gray-400">
                            <span id="batchMintSuccessCount">0</span> of <span id="batchMintTotal">${total}</span> completed
                        </div>
                        <div class="mt-2 text-xs text-gray-600">
                            Please wait... Do not close this window
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Create progress items
            const container = document.getElementById('batchMintProgressContainer');
            for (let i = 1; i <= total; i++) {
                const item = document.createElement('div');
                item.id = `batchMintItem${i}`;
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-black/40 border border-white/10';
                item.innerHTML = `
                    <div class="w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center text-sm font-bold">
                        ${i}
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-400">NFT #${i}</div>
                        <div class="text-xs text-gray-600" id="batchMintStatus${i}">Waiting...</div>
                    </div>
                    <div id="batchMintIcon${i}" class="text-2xl">‚è≥</div>
                `;
                container.appendChild(item);
            }
        };
        
        window.updateBatchMintProgress = (current, total, status) => {
            const item = document.getElementById(`batchMintItem${current}`);
            const statusEl = document.getElementById(`batchMintStatus${current}`);
            const iconEl = document.getElementById(`batchMintIcon${current}`);
            
            if (!item || !statusEl || !iconEl) return;
            
            if (status === 'minting') {
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-cyan-900/20 border border-cyan-500/30';
                statusEl.textContent = 'Minting...';
                statusEl.className = 'text-xs text-cyan-400';
                iconEl.textContent = '‚öôÔ∏è';
            } else if (status === 'success') {
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-green-900/20 border border-green-500/30';
                statusEl.textContent = 'Minted!';
                statusEl.className = 'text-xs text-green-400';
                iconEl.textContent = '‚úÖ';
                
                // Update success count
                const successCount = document.getElementById('batchMintSuccessCount');
                if (successCount) {
                    successCount.textContent = current;
                }
            } else if (status === 'failed') {
                item.className = 'flex items-center gap-3 p-3 rounded-lg bg-red-900/20 border border-red-500/30';
                statusEl.textContent = 'Failed';
                statusEl.className = 'text-xs text-red-400';
                iconEl.textContent = '‚ùå';
            }
        };
        
        window.showBatchMintResults = (results) => {
            const modal = document.getElementById('batchMintModal');
            if (!modal) return;
            
            const successful = results.successful.length;
            const failed = results.failed.length;
            const total = results.total;
            
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-md w-full mx-4">
                    <h3 class="orbitron text-xl text-cyan-400 font-bold mb-6 text-center">Batch Mint Complete!</h3>
                    
                    <div class="space-y-4 mb-6">
                        <div class="p-4 rounded-lg bg-green-900/20 border border-green-500/30">
                            <div class="text-3xl font-bold text-green-400 text-center">${successful}</div>
                            <div class="text-sm text-gray-400 text-center">Successfully Minted</div>
                        </div>
                        
                        ${failed > 0 ? `
                        <div class="p-4 rounded-lg bg-red-900/20 border border-red-500/30">
                            <div class="text-3xl font-bold text-red-400 text-center">${failed}</div>
                            <div class="text-sm text-gray-400 text-center">Failed</div>
                        </div>
                        ` : ''}
                        
                        <div class="p-4 rounded-lg bg-black/40 border border-white/10">
                            <div class="text-2xl font-bold text-white text-center">${total}</div>
                            <div class="text-sm text-gray-400 text-center">Total Attempted</div>
                        </div>
                    </div>
                    
                    <button onclick="document.getElementById('batchMintModal').remove(); window.renderCollection();" 
                            class="btn-primary w-full py-3">
                        View My NFTs
                    </button>
                </div>
            `;
        };

        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BATCH MINT UI TRIGGER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.showBatchMintModal = (collectionId) => {
            const modal = document.createElement('div');
            modal.id = 'batchMintQuantityModal';
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-md w-full mx-4">
                    <h3 class="orbitron text-xl text-cyan-400 font-bold mb-6 text-center">Batch Mint</h3>
                    
                    <div class="mb-6">
                        <label class="block text-sm text-gray-400 mb-3">How many NFTs to mint?</label>
                        <input type="number" id="batchMintQuantity" 
                               value="1" min="1" max="10" 
                               class="w-full bg-black/60 border border-cyan-500/30 p-4 rounded-xl text-3xl text-center text-cyan-400 outline-none font-bold focus:border-cyan-500">
                        <div class="text-xs text-gray-600 mt-2 text-center">Maximum 10 NFTs per batch</div>
                    </div>
                    
                    <div class="grid grid-cols-5 gap-2 mb-6">
                        <button onclick="document.getElementById('batchMintQuantity').value = 1" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">1</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = 3" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">3</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = 5" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">5</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = 10" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-white hover:border-cyan-500 transition-all">10</button>
                        <button onclick="document.getElementById('batchMintQuantity').value = ''" 
                                class="p-2 rounded bg-black/40 border border-white/10 text-gray-500 hover:border-red-500 transition-all">Clear</button>
                    </div>
                    
                    <div class="flex gap-3">
                        <button onclick="document.getElementById('batchMintQuantityModal').remove()" 
                                class="flex-1 p-3 rounded-lg border border-white/10 text-gray-400 hover:bg-white/5 transition-all">
                            Cancel
                        </button>
                        <button onclick="window.startBatchMint('${collectionId}')" 
                                class="flex-1 btn-primary p-3">
                            Start Minting
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        window.startBatchMint = async (collectionId) => {
            const quantity = parseInt(document.getElementById('batchMintQuantity')?.value || 1);
            
            if (isNaN(quantity) || quantity < 1 || quantity > 10) {
                window.notify("Please enter a quantity between 1-10", "error");
                return;
            }
            
            // Remove quantity modal
            document.getElementById('batchMintQuantityModal')?.remove();
            
            // If quantity is 1, just use normal mint
            if (quantity === 1) {
                await window.mintFromCollection(collectionId);
            } else {
                // Use batch mint
                await window.executeBatchMint(collectionId, quantity);
            }
        };

        window.mintFromCollection = async (collectionId) => {
            if (!state.address) {
                return window.notify("Connect wallet first", "error");
            }
            if (!window.acquireTxLock(`mint_${collectionId}`)) return window.notify("Mint already in progress...", "warning");
            
            // Clear any previous mint status
            const existingBadge = document.querySelector('.mint-status-badge');
            if (existingBadge) existingBadge.remove();
            
            try {
                window.showMintStatus('pending', 'Initializing mint...');
                
                const pipeline = window.createKeetaMintPipeline();
                const result = await pipeline.executeMint({
                    collectionId,
                    userWallet: state.address,
                    userClient: state.keetaClient,
                    userAccount: state.keetaAccount
                    // REMOVED: escrowClient and escrowAccount - not needed for minting!
                    // Minting goes directly to user wallet, no escrow involved
                });
                
                // CRITICAL: Only show ONE status based on result
                if (result.success) {
                    console.log("‚úÖ Mint pipeline succeeded:", result);
                    window.showMintStatus('confirmed', '‚úÖ Mint Confirmed!');
                    
                    // Single success notification
                    window.notify("‚úÖ NFT minted successfully!", "success");
                    
                    // Refresh UI with longer delay to ensure Firebase has propagated
                    window.refreshBalance();
                    setTimeout(async () => {
                        console.log("üîÑ Refreshing collections after mint...");
                        await window.loadNFTsFromFirebase();
                        await window.loadCollections(); // This will call renderCollections() internally
                        await window.loadTraitCounts();
                        console.log("‚úÖ Collections refreshed. Current collections:", state.collections.length);
                        if (state.collections.length > 0) {
                            const justMinted = state.collections.find(c => c.collectionId === collectionId);
                            if (justMinted) {
                                console.log(`üìä Collection ${collectionId} after mint:`, {
                                    mintedCount: justMinted.mintedCount,
                                    remainingSupply: justMinted.remainingSupply,
                                    blindMintEnabled: justMinted.blindMintEnabled
                                });
                            }
                        }
                    }, 1500); // Increased from 500ms to 1500ms
                } else {
                    // Only show failure if result.success is false
                    console.error("‚ùå Mint pipeline failed:", result.error);
                    window.showMintStatus('failed', result.error || 'Mint failed');
                    window.notify(`‚ùå Mint failed: ${result.error}`, "error");
                }
                
                return result;
                
            } catch (error) {
                console.error("‚ùå Mint exception:", error);
                window.showMintStatus('failed', 'Unexpected error');
                window.notify(`‚ùå Mint failed: ${error.message}`, "error");
                return { success: false, error: error.message };
            } finally {
                window.releaseTxLock(`mint_${collectionId}`);
            }
        };

        // FIX #7: Bulk minting function - OPTIMIZED FOR KEETA SPEED ‚ö°
        window.mintMultipleFromCollection = async (collectionId) => {
            if (!state.address) {
                return window.notify("Connect wallet first", "error");
            }
            
            // Get selected quantity
            const quantitySelect = document.getElementById(`mintQuantity_${collectionId}`);
            const quantity = parseInt(quantitySelect?.value || 1);
            
            if (quantity < 1 || quantity > 10) {
                return window.notify("Invalid quantity (1-10)", "error");
            }
            
            // Get collection info for optimistic UI
            const collection = state.collections.find(c => c.collectionId === collectionId);
            if (!collection) {
                return window.notify("Collection not found", "error");
            }
            
            try {
                // Show initial progress
                const progressMsg = `üé≤ Minting ${quantity} NFT${quantity > 1 ? 's' : ''}...`;
                window.notify(progressMsg, "success");
                console.log(`‚ö° Starting ${quantity} mints with OPTIMISTIC UI...`);
                
                let successCount = 0;
                let failedCount = 0;
                const startTime = Date.now();
                const optimisticNFTs = []; // Track optimistic NFTs for rollback
                
                // ‚ö° OPTIMISTIC UI: Create placeholder NFTs immediately
                if (PARALLEL_MINT_CONFIG.ENABLE_OPTIMISTIC_UI) {
                    for (let i = 0; i < quantity; i++) {
                        const optimisticId = `optimistic_${Date.now()}_${i}`;
                        const optimisticNFT = {
                            id: optimisticId,
                            name: `${collection.collectionTitle} #???`,
                            description: 'Minting in progress...',
                            collectionId: collectionId,
                            collectionTitle: collection.collectionTitle,
                            collectionToken: collection.collectionToken,
                            owner: state.address,
                            status: 'pending',
                            isOptimistic: true,
                            imagePath: getIPFSUrl('bafybeidgzwxcrhvf2jpo65gtqrt33otfk4yqwjc5vadntpp4yntqohvgtm'), // Dice image
                            mintedAt: new Date().toISOString(),
                            attributes: []
                        };
                        
                        // Add to state immediately
                        state.nfts.unshift(optimisticNFT);
                        optimisticNFTs.push(optimisticId);
                    }
                    
                    // Render UI immediately ‚ö°
                    window.renderCollection();
                    console.log(`‚ö° ${quantity} optimistic NFTs displayed instantly!`);
                }
                
                // ‚ö° SEQUENTIAL EXECUTION (CRITICAL for Keeta blockchain voting)
                // Keeta's voting consensus requires transactions to complete before submitting next one
                const mintMetrics = []; // Track performance for each mint
                
                for (let i = 0; i < quantity; i++) {
                    const mintNum = i + 1;
                    const optimisticId = optimisticNFTs[i];
                    const mintStart = performance.now();
                    
                    console.log(`üé® Mint ${mintNum}/${quantity} starting...`);
                    try {
                        const result = await window.mintFromCollection(collectionId);
                        const mintDuration = performance.now() - mintStart;
                        
                        if (result && result.success) {
                            successCount++;
                            console.log(`‚úÖ Mint ${mintNum}/${quantity} SUCCESS (${(mintDuration/1000).toFixed(1)}s)`);
                            
                            // Store performance metrics
                            mintMetrics.push({
                                mintNum,
                                success: true,
                                duration: mintDuration,
                                mintIndex: result.perfMetrics?.mintIndex,
                                timings: result.perfMetrics?.timings
                            });
                            
                            // Replace optimistic NFT with real one
                            if (PARALLEL_MINT_CONFIG.ENABLE_OPTIMISTIC_UI) {
                                setTimeout(async () => {
                                    // Remove optimistic, load real NFT
                                    state.nfts = state.nfts.filter(n => n.id !== optimisticId);
                                    await window.loadNFTsFromFirebase();
                                    window.renderCollection();
                                }, 500);
                            }
                        } else {
                            failedCount++;
                            console.error(`‚ùå Mint ${mintNum}/${quantity} FAILED:`, result?.error);
                            
                            // Store failure metrics
                            mintMetrics.push({
                                mintNum,
                                success: false,
                                duration: mintDuration,
                                error: result?.error
                            });
                            
                            // Remove failed optimistic NFT
                            if (PARALLEL_MINT_CONFIG.ENABLE_OPTIMISTIC_UI) {
                                state.nfts = state.nfts.filter(n => n.id !== optimisticId);
                                window.renderCollection();
                            }
                        }
                    } catch (error) {
                        console.error(`‚ùå Mint ${mintNum}/${quantity} exception:`, error);
                        failedCount++;
                        
                        // Remove failed optimistic NFT
                        if (PARALLEL_MINT_CONFIG.ENABLE_OPTIMISTIC_UI) {
                            state.nfts = state.nfts.filter(n => n.id !== optimisticId);
                            window.renderCollection();
                        }
                    }
                    
                    // SAFETY: Configurable buffer between mints for voting system
                    // Uses PARALLEL_MINT_CONFIG.INTER_MINT_DELAY_MS (default 1000ms)
                    // Or 500ms if AGGRESSIVE_MODE is enabled (experimental)
                    if (i < quantity - 1) {
                        const delayMs = PARALLEL_MINT_CONFIG.AGGRESSIVE_MODE 
                            ? 500 
                            : PARALLEL_MINT_CONFIG.INTER_MINT_DELAY_MS;
                        console.log(`‚è≥ Waiting ${delayMs}ms before next mint...${PARALLEL_MINT_CONFIG.AGGRESSIVE_MODE ? ' ‚ö° AGGRESSIVE MODE' : ''}`);
                        await new Promise(resolve => setTimeout(resolve, delayMs));
                    }
                    
                    // Progress update
                    const completed = successCount + failedCount;
                    if (completed < quantity) {
                        console.log(`üìä Progress: ${completed}/${quantity} complete (${successCount} success, ${failedCount} failed)`);
                    }
                }
                
                const endTime = Date.now();
                const duration = ((endTime - startTime) / 1000).toFixed(1);
                
                // üìä BATCH PERFORMANCE ANALYTICS
                console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üìä BATCH MINT PERFORMANCE REPORT
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë ‚úÖ Success: ${successCount}/${quantity} mints
‚ïë ‚ùå Failed: ${failedCount}/${quantity} mints
‚ïë ‚è±Ô∏è  Total Time: ${duration}s
‚ïë ‚ö° Average Speed: ${(quantity / parseFloat(duration)).toFixed(2)} mints/second
‚ïë üìà Per-Mint Average: ${(parseFloat(duration) / quantity).toFixed(2)}s
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üéØ INDIVIDUAL MINT TIMINGS:
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                
                mintMetrics.forEach(m => {
                    const status = m.success ? '‚úÖ' : '‚ùå';
                    const time = (m.duration / 1000).toFixed(1);
                    console.log(`‚ïë   ${status} Mint #${m.mintNum}: ${time}s ${m.mintIndex !== undefined ? `(Index: ${m.mintIndex})` : ''}`);
                    if (m.timings) {
                        console.log(`‚ïë      ‚îî‚îÄ Breakdown: Val:${m.timings.validation}ms | Meta:${m.timings.metadata}ms | Token:${m.timings.tokenCreation}ms | Pay:${m.timings.payment}ms | DB:${m.timings.firebase}ms`);
                    }
                    if (m.error) {
                        console.log(`‚ïë      ‚îî‚îÄ Error: ${m.error}`);
                    }
                });
                
                // Calculate statistics
                const successfulMints = mintMetrics.filter(m => m.success);
                if (successfulMints.length > 0) {
                    const durations = successfulMints.map(m => m.duration);
                    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
                    const minDuration = Math.min(...durations);
                    const maxDuration = Math.max(...durations);
                    
                    console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üìà STATISTICS (Successful Mints Only):
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë   ‚è±Ô∏è  Average: ${(avgDuration/1000).toFixed(2)}s per mint
‚ïë   üèÉ Fastest: ${(minDuration/1000).toFixed(2)}s
‚ïë   üêå Slowest: ${(maxDuration/1000).toFixed(2)}s
‚ïë   üìä Variance: ${((maxDuration - minDuration)/1000).toFixed(2)}s`);
                }
                
                console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                
                // üíæ SAVE METRICS TO GLOBAL STATE
                const batchStats = {
                    timestamp: new Date().toISOString(),
                    quantity,
                    successCount,
                    failedCount,
                    duration: parseFloat(duration),
                    avgTime: parseFloat(duration) / quantity,
                    collectionId,
                    metrics: mintMetrics
                };
                
                state.performanceMetrics.batchMints.push(batchStats);
                state.performanceMetrics.totalMints += quantity;
                state.performanceMetrics.successfulMints += successCount;
                state.performanceMetrics.failedMints += failedCount;
                state.performanceMetrics.mintTimes.push(...mintMetrics.map(m => m.duration / 1000));
                state.performanceMetrics.lastUpdated = new Date().toISOString();
                
                // Keep only last 50 batches to prevent memory bloat
                if (state.performanceMetrics.batchMints.length > 50) {
                    state.performanceMetrics.batchMints = state.performanceMetrics.batchMints.slice(-50);
                }
                
                // Keep only last 500 individual mint times
                if (state.performanceMetrics.mintTimes.length > 500) {
                    state.performanceMetrics.mintTimes = state.performanceMetrics.mintTimes.slice(-500);
                }
                
                console.log(`‚úÖ Batch complete! ${successCount} success, ${failedCount} failed in ${duration}s`);
                console.log(`‚ö° Speed: ${(quantity / parseFloat(duration)).toFixed(1)} mints/second`);
                
                // Final notification
                if (successCount > 0) {
                    let message = `‚úÖ Successfully minted ${successCount}/${quantity} NFT${successCount > 1 ? 's' : ''}!`;
                    
                    // Add speed stats if enabled
                    if (PARALLEL_MINT_CONFIG.SHOW_SPEED_STATS && quantity > 1) {
                        const speed = (quantity / parseFloat(duration)).toFixed(1);
                        message += ` ‚ö° ${duration}s (${speed}/s)`;
                    }
                    
                    window.notify(message, "success");
                } else {
                    window.notify(`‚ùå All ${quantity} mints failed`, "error");
                }
                
                if (failedCount > 0) {
                    window.notify(`‚ö†Ô∏è ${failedCount} mint${failedCount > 1 ? 's' : ''} failed - check console`, "warning");
                }
                
                // Refresh collection data
                await window.loadCollections();
                window.renderCollections();
                
                // FIX #7: Also refresh user's collection view  
                setTimeout(async () => {
                    await window.loadNFTsFromFirebase();
                    window.renderCollection();
                }, 2000);
                
            } catch (error) {
                console.error("Bulk mint error:", error);
                window.notify(`‚ùå Bulk mint failed: ${error.message}`, "error");
            } finally {
                window.releaseTxLock(`batch_${collectionId}`);
            }
        };

        // ========================================
        // üéÅ CREATOR PRE-MINT FEATURE
        // Mint all NFTs to creator's wallet for airdrop distribution
        // ========================================
        window.preMintCollection = async (collectionId, totalQuantity) => {
            if (!state.address) {
                showNotification('Please connect your wallet first', 'error');
                return;
            }

            // Get collection to verify creator
            const collection = state.collections.find(c => c.id === collectionId || c.collectionId === collectionId);
            if (!collection) {
                showNotification('Collection not found', 'error');
                return;
            }

            if (collection.creator !== state.address) {
                showNotification('Only the creator can pre-mint', 'error');
                return;
            }

            // Confirm action
            const confirmed = await showCustomConfirm({
                icon: 'üéÅ',
                title: 'Pre-Mint Collection',
                message: `This will mint all ${totalQuantity} remaining NFTs to YOUR wallet. You can then airdrop them using the Airdrop feature. Continue?`,
                confirmText: `Yes, Pre-Mint ${totalQuantity} NFTs`,
                confirmClass: 'bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600'
            });

            if (!confirmed) return;

            console.log(`üéÅ PRE-MINTING ${totalQuantity} NFTs to creator wallet...`);

            // Since mintMultiple has a max of 10, we need to batch
            const BATCH_SIZE = 10;
            let remaining = totalQuantity;
            let totalMinted = 0;

            const quantitySelect = document.getElementById(`mintQuantity_${collectionId}`);
            
            while (remaining > 0) {
                const batchSize = Math.min(remaining, BATCH_SIZE);
                
                console.log(`üéÅ Minting batch: ${batchSize} NFTs (${totalMinted}/${totalQuantity} complete)`);
                
                if (quantitySelect) {
                    // Ensure the option exists
                    const existingOption = Array.from(quantitySelect.options).find(opt => opt.value == batchSize);
                    if (!existingOption) {
                        const option = document.createElement('option');
                        option.value = batchSize;
                        option.text = batchSize;
                        quantitySelect.appendChild(option);
                    }
                    quantitySelect.value = batchSize;
                }
                
                // Mint this batch
                await window.mintMultipleFromCollection(collectionId);
                
                totalMinted += batchSize;
                remaining -= batchSize;
                
                // Small delay between batches
                if (remaining > 0) {
                    console.log(`‚è≥ Waiting 2s before next batch...`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }

            console.log(`‚úÖ Pre-mint complete! Minted ${totalMinted} NFTs total`);
            showNotification(`Pre-mint complete! ${totalMinted} NFTs minted to your wallet`, 'success');
        };

        // üìä PERFORMANCE ANALYTICS FUNCTION
        window.showPerformanceReport = () => {
            const perf = state.performanceMetrics;
            
            if (perf.totalMints === 0) {
                console.log("üìä No minting data available yet. Mint some NFTs to see performance statistics!");
                return;
            }
            
            // Calculate statistics
            const avgMintTime = perf.mintTimes.length > 0 
                ? (perf.mintTimes.reduce((a, b) => a + b, 0) / perf.mintTimes.length).toFixed(2)
                : 0;
            const minMintTime = perf.mintTimes.length > 0 ? Math.min(...perf.mintTimes).toFixed(2) : 0;
            const maxMintTime = perf.mintTimes.length > 0 ? Math.max(...perf.mintTimes).toFixed(2) : 0;
            const successRate = ((perf.successfulMints / perf.totalMints) * 100).toFixed(1);
            
            // Recent performance (last 10 batches)
            const recentBatches = perf.batchMints.slice(-10);
            const recentAvgTime = recentBatches.length > 0
                ? (recentBatches.reduce((sum, b) => sum + b.avgTime, 0) / recentBatches.length).toFixed(2)
                : 0;
            
            console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üìä PUNKSWAP PERFORMANCE ANALYTICS DASHBOARD
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üìà OVERALL STATISTICS:
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë   üéØ Total Mints: ${perf.totalMints}
‚ïë   ‚úÖ Successful: ${perf.successfulMints} (${successRate}%)
‚ïë   ‚ùå Failed: ${perf.failedMints}
‚ïë   üì¶ Batch Operations: ${perf.batchMints.length}
‚ïë   üïê Last Updated: ${perf.lastUpdated ? new Date(perf.lastUpdated).toLocaleString() : 'N/A'}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë ‚è±Ô∏è  TIMING STATISTICS (ALL TIME):
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë   üìä Average Mint Time: ${avgMintTime}s
‚ïë   üèÉ Fastest Mint: ${minMintTime}s
‚ïë   üêå Slowest Mint: ${maxMintTime}s
‚ïë   üìè Time Variance: ${(maxMintTime - minMintTime).toFixed(2)}s
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üî• RECENT PERFORMANCE (Last 10 Batches):
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë   ‚è±Ô∏è  Recent Avg: ${recentAvgTime}s per mint
‚ïë   üìä Batches: ${recentBatches.length}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üìã BATCH HISTORY:
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);

            perf.batchMints.slice(-10).reverse().forEach((batch, index) => {
                const time = new Date(batch.timestamp).toLocaleTimeString();
                const date = new Date(batch.timestamp).toLocaleDateString();
                console.log(`‚ïë   ${index + 1}. ${date} ${time}`);
                console.log(`‚ïë      ‚îî‚îÄ ${batch.successCount}/${batch.quantity} success in ${batch.duration.toFixed(1)}s (avg ${batch.avgTime.toFixed(2)}s/mint)`);
            });

            console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üí° PERFORMANCE INSIGHTS:
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);

            // Generate insights
            if (avgMintTime < 5) {
                console.log(`‚ïë   üöÄ EXCELLENT: Your average mint time (${avgMintTime}s) is very fast!`);
            } else if (avgMintTime < 8) {
                console.log(`‚ïë   ‚úÖ GOOD: Your average mint time (${avgMintTime}s) is performing well.`);
            } else if (avgMintTime < 12) {
                console.log(`‚ïë   ‚ö†Ô∏è  MODERATE: Average mint time (${avgMintTime}s) is acceptable.`);
            } else {
                console.log(`‚ïë   üêå SLOW: Average mint time (${avgMintTime}s) is slower than expected.`);
                console.log(`‚ïë      Check your network connection and blockchain congestion.`);
            }
            
            if (successRate >= 95) {
                console.log(`‚ïë   ‚úÖ SUCCESS RATE: ${successRate}% - Excellent reliability!`);
            } else if (successRate >= 80) {
                console.log(`‚ïë   ‚ö†Ô∏è  SUCCESS RATE: ${successRate}% - Some issues detected.`);
            } else {
                console.log(`‚ïë   ‚ùå SUCCESS RATE: ${successRate}% - High failure rate!`);
                console.log(`‚ïë      Check console for error patterns.`);
            }
            
            const variance = maxMintTime - minMintTime;
            if (variance > 10) {
                console.log(`‚ïë   ‚ö†Ô∏è  HIGH VARIANCE: ${variance.toFixed(2)}s difference between fastest/slowest.`);
                console.log(`‚ïë      Network congestion or blockchain load may be affecting consistency.`);
            } else {
                console.log(`‚ïë   ‚úÖ CONSISTENT: Low variance (${variance.toFixed(2)}s) indicates stable performance.`);
            }

            console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
üí° TIP: Call window.showPerformanceReport() anytime to see updated statistics!
üí° TIP: Call window.clearPerformanceData() to reset all metrics.
`);
        };
        
        // Clear performance data
        window.clearPerformanceData = () => {
            state.performanceMetrics = {
                totalMints: 0,
                successfulMints: 0,
                failedMints: 0,
                batchMints: [],
                mintTimes: [],
                lastUpdated: null
            };
            console.log("‚úÖ Performance metrics cleared!");
        };

        window.executeMintSwap = async (nftAddr, collection, meta, mintIndex) => {
            try {
                console.log("‚öõÔ∏è Creating atomic swap...");
                
                // Check for phase-based pricing, then collection price
                const cp = window.getCollectionPrice(collection, state.address);
                let totalPrice = cp.price;
                let mintCurrency = cp.currency;
                
                const activePhase = window.getActivePhaseForWallet(collection.collectionId, state.address);
                if (activePhase) {
                    totalPrice = activePhase.priceKTA;
                    mintCurrency = 'KTA';
                    console.log(`üíé Phase pricing active: "${activePhase.name}" = ${totalPrice} KTA`);
                } else {
                    console.log(`üí∞ Standard pricing: ${totalPrice} ${mintCurrency}`);
                }
                
                // Balance check
                if (mintCurrency === 'PUNKS' && state.balancePunks < totalPrice) {
                    throw new Error(`Insufficient PUNKS balance. Need ${totalPrice}, have ${state.balancePunks}`);
                } else if (mintCurrency === 'KTA' && state.balanceKTA < totalPrice) {
                    throw new Error(`Insufficient KTA balance. Need ${totalPrice}, have ${state.balanceKTA}`);
                }
                
                const marketplaceFee = totalPrice * PRIMARY_SALE_MARKETPLACE_PERCENT;
                const creatorPayment = totalPrice * PRIMARY_SALE_CREATOR_PERCENT;
                const paymentToken = window.getTokenForCurrency(mintCurrency);
                
                console.log(`üí∞ Primary sale split: Creator ${creatorPayment} ${mintCurrency} (90%) | Marketplace ${marketplaceFee} ${mintCurrency} (10%)`);
                
                if (typeof state.keetaClient.init === 'function') {
                    await state.keetaClient.init();
                }
                // SECURE: Escrow operations handled by Cloud Functions (no client-side init needed)
                
                const buyerBuilder = state.keetaClient.initBuilder();
                buyerBuilder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                
                // Only send payment if price > 0 (skip for free mints)
                if (totalPrice > 0) {
                    console.log(`üí≥ Processing ${mintCurrency} payment...`);
                    buyerBuilder.send(
                        KeetaNet.lib.Account.fromPublicKeyString(collection.creator),
                        BigInt(Math.floor(creatorPayment * KTA_DECIMALS)),
                        paymentToken
                    );
                    
                    buyerBuilder.send(
                        KeetaNet.lib.Account.fromPublicKeyString(MARKETPLACE_FEE_WALLET),
                        BigInt(Math.floor(marketplaceFee * KTA_DECIMALS)),
                        paymentToken
                    );
                } else {
                    console.log("üéÅ FREE MINT - Skipping payment");
                }
                
                // Step 1: Process buyer payment
                await state.keetaClient.computeBuilderBlocks(buyerBuilder);
                const buyerTx = await state.keetaClient.publishBuilder(buyerBuilder);
                console.log("‚úÖ Payment published");
                
                // Step 2: Release NFT from escrow via Cloud Function (SECURE)
                console.log("üîí Calling Cloud Function to release minted NFT...");
                let escrowTx = null;
                try {
                    const releaseResult = await window.escrowMintRelease({
                        nftTokenId: nftAddr,
                        buyerAddress: state.address,
                        collectionId: collection.collectionId || collection.id
                    });
                    if (releaseResult.data && releaseResult.data.success) {
                        escrowTx = { hash: releaseResult.data.txHash };
                        console.log("‚úÖ NFT released from escrow via Cloud Function:", releaseResult.data.txHash);
                    }
                } catch (escrowErr) {
                    console.error("‚ö†Ô∏è Escrow mint release failed:", escrowErr);
                }
                
                console.log("‚úÖ Atomic swap complete!");
                
                // Custom replacer to handle BigInt serialization
                const bigIntReplacer = (key, value) => {
                    return typeof value === 'bigint' ? value.toString() : value;
                };
                
                console.log("üìù Buyer tx (full):", JSON.stringify(buyerTx, bigIntReplacer, 2));
                console.log("üìù Escrow tx (full):", JSON.stringify(escrowTx, bigIntReplacer, 2));
                
                // Extract transaction hash using universal helper
                let txHash = window.extractTxHash(buyerTx) || window.extractTxHash(escrowTx);
                console.log("üîç Final extracted tx hash:", txHash);
                
                // Brief delay to ensure blockchain confirmation
                await new Promise(r => setTimeout(r, 500));
                
                // SMART IMAGE PATH RESOLVER - Handles ALL IPFS formats
                function resolveImagePath(imageField, collectionCid, mintIndex) {
                    console.log(`üîç Resolving image path from: "${imageField}"`);
                    
                    if (!imageField) {
                        console.warn("‚ö†Ô∏è No image field in metadata, using default");
                        return `${collectionCid}/images/${String(mintIndex + 1).padStart(3, '0')}.png`;
                    }
                    
                    let imagePath = imageField;
                    
                    // 1. Remove ipfs:// protocol
                    imagePath = imagePath.replace(/^ipfs:\/\//, '');
                    
                    // 2. Handle {{COLLECTION_CID}} placeholder (Bueno format)
                    imagePath = imagePath.replace(/\{\{COLLECTION_CID\}\}/, collectionCid);
                    imagePath = imagePath.replace(/\{\{CID\}\}/, collectionCid);
                    
                    // 3. Check if path already has a CID
                    const hasCid = imagePath.match(/^(bafybei[a-z0-9]{52}|Qm[a-zA-Z0-9]{44})/);
                    
                    if (hasCid) {
                        // Path already includes full CID (e.g., "bafybei.../images/001.png")
                        console.log(`‚úÖ Path has CID: ${imagePath}`);
                        return imagePath;
                    }
                    
                    // 4. Check for various relative path formats
                    // Format: "images/001.png" or "images/1.png"
                    if (imagePath.match(/^images?\//i)) {
                        const fullPath = `${collectionCid}/${imagePath}`;
                        console.log(`‚úÖ Relative path: ${imagePath} ‚Üí ${fullPath}`);
                        return fullPath;
                    }
                    
                    // Format: "001.png" or "1.png" (just filename)
                    if (imagePath.match(/^\d+\.png$/i)) {
                        const fullPath = `${collectionCid}/images/${imagePath}`;
                        console.log(`‚úÖ Filename only: ${imagePath} ‚Üí ${fullPath}`);
                        return fullPath;
                    }
                    
                    // 5. Handle absolute paths that start with CID but might be malformed
                    // e.g., "CID/001.png" without images/ folder
                    if (imagePath.includes('/')) {
                        // Check if it's missing the collection CID
                        if (!hasCid) {
                            const fullPath = `${collectionCid}/${imagePath}`;
                            console.log(`‚úÖ Adding CID to path: ${imagePath} ‚Üí ${fullPath}`);
                            return fullPath;
                        }
                    }
                    
                    // 6. Last resort: assume it's a relative path and prepend CID + images/
                    const fullPath = `${collectionCid}/images/${imagePath}`;
                    console.log(`‚ö†Ô∏è Unknown format, guessing: ${imagePath} ‚Üí ${fullPath}`);
                    return fullPath;
                }
                
                // Use smart resolver
                const fullImagePath = resolveImagePath(meta.image, collection.ipfsCid, mintIndex);
                console.log(`üñºÔ∏è Final image path: ${fullImagePath}`);
                
                const docId = `nft_${getNormalizedId(collection.collectionToken)}_${mintIndex}`;
                
                await setDoc(doc(db, 'nfts', docId), {
                    name: meta.name || `Unit #${mintIndex + 1}`,
                    imageCid: fullImagePath,
                    priceKTA: collection.priceKTA,
                    pricePunks: collection.pricePunks,
                    status: 'minted',
                    tokenId: nftAddr,
                    collectionToken: collection.collectionToken,
                    collectionId: collection.collectionId,
                    collectionTitle: collection.collectionTitle,
                    collection: meta.collection || collection.collectionTitle,
                    collectionDesc: collection.collectionDesc,
                    creator: collection.creator,
                    owner: state.address,
                    collectionThumbnailCid: collection.collectionThumbnailCid,
                    mintedAt: new Date().toISOString(),
                    wasBlindMinted: true,
                    attributes: meta.attributes || [],  // FIX #3: FULL attributes
                    description: meta.description || '',
                    externalUrl: meta.external_url || ''
                });
                
                // NOTE: mintedCount already incremented atomically above (line ~2266)
                // No need to update again here
                
                const walletTrackingRef = doc(db, 'walletMintTracking', `${state.address}_${collection.collectionId}`);
                const trackingSnap = await getDoc(walletTrackingRef);
                const currentCount = trackingSnap.exists() ? trackingSnap.data().mintedCount : 0;
                
                await setDoc(walletTrackingRef, {
                    walletAddress: state.address,
                    collectionId: collection.collectionId,
                    mintedCount: currentCount + 1
                });
                
                await window.updateTraitCounts(collection.collectionId, meta.attributes || []);
                
                // Record mint transaction (don't let this break the flow)
                try {
                    const mintCp = window.getCollectionPrice(collection, state.address);
                    await window.recordTransaction({
                        type: 'mint',
                        nftId: docId,
                        nftName: meta.name || `${collection.collectionTitle} #${mintIndex + 1}`,
                        collection: collection.collectionTitle,
                        collectionId: collection.collectionId,
                        price: mintCp.price,
                        currency: mintCp.currency,
                        counterParty: collection.creator,
                        txHash: txHash
                    });
                    console.log("‚úÖ Transaction recorded with hash:", txHash);
                    await window.loadTransactions();
                } catch (txError) {
                    console.warn("‚ö†Ô∏è Could not record transaction:", txError.message);
                }
                
                window.notify("NFT minted successfully!", "success");
                window.refreshBalance();
                await window.loadNFTsFromFirebase();
                await window.loadCollections();
                await window.loadTraitCounts();
                
                // Start auto-sync for wallet changes
                window.startAutoSync(); // Load trait counts for color coding
                
            } catch (error) {
                console.error("Swap error:", error);
                throw error;
            }
        };

        // Collection rendering and Forge functions
        window.renderCollections = () => {
            console.log("üé≤ renderCollections called");
            const blindDropContainer = document.getElementById('dropGrid');
            const regularContainer = document.getElementById('regularCollectionGrid');
            
            if (!blindDropContainer || !regularContainer) {
                console.error("‚ùå Collection grid elements not found!");
                return;
            }
            
            // EMERGENCY DEBUG MODE: Set to true to show ALL collections (bypasses all filters)
            const SHOW_ALL_COLLECTIONS = false;
            
            // Active Collections: ALL collections except hidden ones (show even if minted out)
            const activeCollections = SHOW_ALL_COLLECTIONS 
                ? state.collections 
                : state.collections.filter(c => {
                    // Filter out hidden collections (test collections marked as hidden)
                    if (c.hidden === true) {
                        console.log(`   üôà Collection "${c.collectionTitle}" filtered out: marked as hidden`);
                        return false;
                    }
                    // IMPORTANT: Show ALL collections (even minted out) in Active Collections
                    return true;
                });
            
            console.log("üìä Active collections:", activeCollections.length);
            console.log("üìä Total collections in state:", state.collections.length);
            
            // Blind Drops: ONLY blind mint collections that still have supply remaining
            const blindDrops = activeCollections.filter(c => {
                if (!c.blindMintEnabled) return false;
                const remaining = c.remainingSupply ?? (c.totalSupply - (c.mintedCount || 0));
                return remaining > 0; // Only show in Blind Drops if supply remains
            });
            
            console.log(`   üé≤ Blind Drops: ${blindDrops.length}, ‚ö° All Active Collections: ${activeCollections.length}`);
            
            // Debug: Show blind mint collections and their status
            const allBlindMints = activeCollections.filter(c => c.blindMintEnabled === true);
            if (allBlindMints.length > 0) {
                console.log(`   üîç All blind mint collections (${allBlindMints.length}):`, allBlindMints.map(c => ({
                    id: c.collectionId,
                    title: c.collectionTitle,
                    mintedCount: c.mintedCount,
                    remaining: c.remainingSupply,
                    showInBlindDrops: c.mintedCount === 0
                })));
            }
            
            // Array of blind mint dice/cube images - 4 different dice images rotate randomly
            const DICE_IMAGES = [
                getIPFSUrl('bafybeidgzwxcrhvf2jpo65gtqrt33otfk4yqwjc5vadntpp4yntqohvgtm'),  // Original dice image
                getIPFSUrl('bafybeibpvuy7epndrgfnsy3m7rnb7p5qoqcy2xjf3lpaxmia6syo4gukci'),  // Image 1: Orange/Pink PUNKSWAP pattern
                getIPFSUrl('bafybeigcavce4rtjafivzojhxhryng3v4jpxx2vguoyrlonwz7duliykym'),  // Image 2: Blue dice with orange PUNKSWAP
                getIPFSUrl('bafybeie7qiwtuuky6rnsc4fozgkmmzqfmahrqdxpwyky4ocs54lv6wy2m4')   // Image 3: Cyan neon PUNKSWAP square
            ];
            
            // Helper function to get random dice image for a collection
            const getRandomDiceImage = (collectionId) => {
                // Use collection ID as seed for consistent image per collection (same collection = same dice)
                let hash = 0;
                for (let i = 0; i < collectionId.length; i++) {
                    hash = ((hash << 5) - hash) + collectionId.charCodeAt(i);
                    hash = hash & hash;
                }
                const index = Math.abs(hash) % DICE_IMAGES.length;
                return DICE_IMAGES[index];
            };
            
            // Render function for a single collection card
            const renderCollectionCard = (col, isBlindMint) => {
                
                let displayImage;
                if (isBlindMint) {
                    displayImage = getRandomDiceImage(col.collectionId);
                } else {
                    // For external collections: get image from first NFT
                    if (col.isExternal) {
                        const firstNFT = state.nfts.find(n => n.collectionId === col.collectionId || getNormalizedId(n.collectionToken) === getNormalizedId(col.collectionToken));
                        if (firstNFT) {
                            displayImage = firstNFT.image || firstNFT.imageUrl || getRandomDiceImage(col.collectionId);
                        } else {
                            displayImage = getRandomDiceImage(col.collectionId);
                        }
                    } else if (col.previewImageUrl) {
                        displayImage = col.previewImageUrl;
                    } else if (col.ipfsCid && col.scannedFiles && col.scannedFiles[0]) {
                        // Construct URL from first file - include images/ subfolder if not already in path
                        const sf = col.scannedFiles[0].replace('.json', '.png');
                        displayImage = getIPFSUrl(sf.includes('/') ? `${col.ipfsCid}/${sf}` : `${col.ipfsCid}/images/${sf}`);
                    } else if (col.collectionThumbnail) {
                        displayImage = getIPFSUrl(col.collectionThumbnail);
                    } else if (col.blindMintEnabled && col.mintedCount > 0) {
                        // For revealed blind mints: grab image from first minted NFT
                        const mintedNFT = state.nfts.find(n => n.collectionId === col.collectionId && n.wasBlindMinted);
                        if (mintedNFT) {
                            const nftImgPath = window.getNFTImagePath(mintedNFT);
                            displayImage = nftImgPath ? ((nftImgPath.startsWith('http://') || nftImgPath.startsWith('https://')) ? nftImgPath : getIPFSUrl(nftImgPath)) : getRandomDiceImage(col.collectionId);
                        } else {
                            displayImage = getRandomDiceImage(col.collectionId);
                        }
                    } else {
                        displayImage = getRandomDiceImage(col.collectionId);
                    }
                }
                
                // Check whitelist status
                const whitelistSettings = state.whitelistSettings[col.collectionId];
                let buttonClass = 'btn-primary w-full py-3 group-hover:bg-cyan-500/20 transition-all';
                let buttonText = isBlindMint ? 'üé≤ Mystery Forge' : '‚ö° Mint Now';
                let buttonDisabled = '';
                let statusBadge = '';
                let countdownHTML = '';
                let priceDisplay = '';
                let cardHoverClass = 'hover:border-cyan-500/40 hover:shadow-[0_0_40px_rgba(0,255,255,0.3)]';
                
                if (whitelistSettings && whitelistSettings.enabled) {
                    // Check if wallet is in any phase
                    let userPhase = null;
                    if (state.address && whitelistSettings.phases && whitelistSettings.phases.length > 0) {
                        console.log(`üîç UI Whitelist Check for collection ${col.collectionId}:`);
                        console.log(`   - User wallet: "${state.address}"`);
                        console.log(`   - Phases available:`, whitelistSettings.phases.length);
                        
                        // Log each phase details
                        whitelistSettings.phases.forEach((p, idx) => {
                            console.log(`   - Phase ${idx + 1}: "${p.name}" (${p.wallets?.length || 0} wallets)`);
                            if (p.wallets && p.wallets.length > 0) {
                                console.log(`     First wallet: "${p.wallets[0]}"`);
                            }
                        });
                        
                        userPhase = whitelistSettings.phases.find(phase => {
                            if (!phase.wallets) {
                                console.log(`   ‚ö†Ô∏è Phase "${phase.name}" has no wallets array`);
                                return false;
                            }
                            const found = phase.wallets.some(w => {
                                const phaseWallet = (w || '').toLowerCase().trim();
                                const userWallet = (state.address || '').toLowerCase().trim();
                                const match = phaseWallet === userWallet;
                                if (!match && phaseWallet && userWallet) {
                                    console.log(`   - No match in "${phase.name}": "${phaseWallet.substring(0,25)}..." !== "${userWallet.substring(0,25)}..."`);
                                }
                                if (match) {
                                    console.log(`   ‚úÖ FOUND! Wallet matches in phase "${phase.name}"`);
                                }
                                return match;
                            });
                            return found;
                        });
                        
                        if (!userPhase) {
                            console.log(`   ‚ùå Wallet not found in any phase`);
                            console.log(`   - Your address: "${state.address}"`);
                            console.log(`   - First phase wallets:`, whitelistSettings.phases[0]?.wallets?.slice(0, 3));
                        } else {
                            console.log(`   ‚úÖ User is in phase: "${userPhase.name}"`);
                        }
                    }
                    
                    // Check for time-based phases (start/end times)
                    const now = Date.now();
                    let phaseStartTime = userPhase?.startTime ? new Date(userPhase.startTime).getTime() : null;
                    let phaseEndTime = userPhase?.endTime ? new Date(userPhase.endTime).getTime() : null;
                    
                    // Check mint tracking for this wallet
                    const walletTracking = state.walletMintTracking?.[col.collectionId]?.[state.address] || null;
                    const usedMints = walletTracking?.count || 0;
                    const maxMints = userPhase?.maxMintsPerWallet || 1;
                    
                    if (state.address && userPhase) {
                        cardHoverClass = 'hover:border-green-500/60 hover:shadow-[0_0_50px_rgba(34,197,94,0.4)] hover:scale-[1.02]';
                        
                        // Check if phase hasn't started yet
                        if (phaseStartTime && now < phaseStartTime) {
                            const timeLeft = phaseStartTime - now;
                            const hours = Math.floor(timeLeft / 3600000);
                            const minutes = Math.floor((timeLeft % 3600000) / 60000);
                            const seconds = Math.floor((timeLeft % 60000) / 1000);
                            
                            buttonClass = 'w-full py-3 bg-orange-500/20 border border-orange-500/40 text-orange-300 cursor-not-allowed animate-pulse';
                            buttonText = `‚è∞ Starts in ${hours}h ${minutes}m ${seconds}s`;
                            buttonDisabled = 'disabled';
                            statusBadge = `<div class="absolute top-2 left-2 bg-orange-500/95 backdrop-blur-sm px-3 py-2 rounded-lg text-[9px] orbitron font-black text-white shadow-lg animate-pulse">
                                <div>‚è∞ ${userPhase.name.toUpperCase()}</div>
                                <div class="text-[8px] font-normal mt-0.5">${hours}h ${minutes}m ${seconds}s</div>
                            </div>`;
                            countdownHTML = `<div class="bg-orange-500/10 border border-orange-500/30 rounded-lg p-3 text-center">
                                <div class="text-orange-400 orbitron text-xs font-bold">Phase Starts In</div>
                                <div class="text-white orbitron text-2xl font-black mt-1">${hours}:${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}</div>
                            </div>`;
                        }
                        // Check if phase has ended
                        else if (phaseEndTime && now > phaseEndTime) {
                            buttonClass = 'w-full py-3 bg-red-500/20 border border-red-500/30 text-red-400 cursor-not-allowed';
                            buttonText = '‚è∞ Phase Ended';
                            buttonDisabled = 'disabled';
                            statusBadge = `<div class="absolute top-2 left-2 bg-red-500/90 backdrop-blur-sm px-3 py-2 rounded-lg text-[9px] orbitron font-black text-white shadow-lg">üîí ENDED</div>`;
                        }
                        // Check if max mints reached
                        else if (usedMints >= maxMints) {
                            buttonClass = 'w-full py-3 bg-gray-500/20 border border-gray-500/30 text-gray-400 cursor-not-allowed';
                            buttonText = `‚úì Max Reached (${maxMints})`;
                            buttonDisabled = 'disabled';
                            statusBadge = `<div class="absolute top-2 left-2 bg-gray-500/90 backdrop-blur-sm px-3 py-2 rounded-lg text-[9px] orbitron font-black text-white shadow-lg">‚úì MAXED</div>`;
                        } else {
                            // Can mint
                            const phasePrice = userPhase.priceKTA || 0;
                            const priceText = phasePrice === 0 ? 'FREE' : `${phasePrice} KTA`;
                            buttonText = `üé≤ Mint ${priceText} (${usedMints}/${maxMints})`;
                            statusBadge = `<div class="absolute top-2 left-2 bg-gradient-to-r from-green-500 to-emerald-500 backdrop-blur-sm px-3 py-2 rounded-lg text-[9px] orbitron font-black text-white shadow-lg border border-white/20 animate-pulse">
                                <div>‚úì ${userPhase.name.toUpperCase()}</div>
                                <div class="text-[10px] font-normal mt-0.5">${priceText}</div>
                            </div>`;
                            priceDisplay = `<div class="bg-gradient-to-r from-green-500/20 to-emerald-500/20 border border-green-500/40 rounded-lg p-3 text-center">
                                <div class="text-green-400 orbitron text-xs font-bold">Your Price</div>
                                <div class="${phasePrice === 0 ? 'text-green-300' : 'text-white'} orbitron text-3xl font-black mt-1">${phasePrice === 0 ? 'üéÅ FREE' : `${phasePrice} KTA`}</div>
                                <div class="text-green-300 fira text-[9px] mt-1">${usedMints}/${maxMints} minted</div>
                            </div>`;
                        }
                    } else if (state.address) {
                        // Not whitelisted
                        buttonClass = 'w-full py-3 bg-red-500/20 border border-red-500/40 text-red-300 cursor-not-allowed';
                        buttonText = 'üîí Not Whitelisted';
                        buttonDisabled = 'disabled';
                        statusBadge = '<div class="absolute top-2 left-2 bg-red-500/95 backdrop-blur-sm px-3 py-2 rounded-lg text-[9px] orbitron font-black text-white shadow-lg">üîí WHITELIST ONLY</div>';
                        cardHoverClass = 'hover:border-red-500/40';
                    } else {
                        // Not connected
                        buttonClass = 'w-full py-3 bg-purple-500/20 border border-purple-500/40 text-purple-300 hover:bg-purple-500/30 transition-all';
                        buttonText = 'üîå Connect Wallet';
                        statusBadge = '<div class="absolute top-2 left-2 bg-purple-500/95 backdrop-blur-sm px-3 py-2 rounded-lg text-[9px] orbitron font-black text-white shadow-lg">üîí WHITELIST ACTIVE</div>';
                        cardHoverClass = 'hover:border-purple-500/40';
                    }
                }
                
                return `
                <div class="glass-card p-6 space-y-4 transition-all duration-300 group ${cardHoverClass} cursor-pointer" onclick="window.viewCollection('${col.collectionToken}')">
                    <div class="aspect-square bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded-xl flex items-center justify-center overflow-hidden border border-cyan-500/30 shadow-[0_0_30px_rgba(0,255,255,0.2)] relative group-hover:shadow-[0_0_50px_rgba(0,255,255,0.4)] transition-all duration-300">
                        ${statusBadge}
                        <div class="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48cGF0dGVybiBpZD0iZ3JpZCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiBwYXR0ZXJuVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aCBkPSJNIDIwIDAgTCAwIDAgMCAyMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2JhKDAsMjU1LDI1NSwwLjEpIiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvcGF0dGVybj48L2RlZnM+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmlkKSIvPjwvc3ZnPg==')] opacity-20"></div>
                        <img src="${displayImage}" 
                             class="w-full h-full object-cover relative z-10 group-hover:scale-110 transition-transform duration-300 sharp-img will-change-transform" 
                             style="transform-origin: center; backface-visibility: hidden;"
                             onerror="this.style.display='none';this.parentElement.innerHTML+='<div class=\\'text-8xl relative z-10 animate-pulse\\' style=\\'filter: drop-shadow(0 0 20px rgba(0,255,255,0.5));\\'>üé≤</div>'" 
                             alt="${isBlindMint ? 'Mystery Drop' : col.collectionTitle}"/>
                    </div>
                    <div>
                        <div class="flex items-center gap-2">
                            <h3 class="orbitron text-lg font-bold text-cyan-400 group-hover:text-cyan-300 transition-colors">${col.collectionTitle}</h3>
                            ${col.verified ? '<div class="flex-shrink-0 w-5 h-5 bg-gradient-to-br from-blue-500 to-cyan-500 rounded-full flex items-center justify-center border-2 border-white/20 shadow-lg" title="Verified Collection"><svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg></div>' : ''}
                        </div>
                        <p class="fira text-xs text-gray-500 mt-1">${col.collectionDesc}</p>
                    </div>
                    
                    ${countdownHTML || priceDisplay || `<div class="flex justify-between items-center">
                        <span class="fira text-sm font-bold ${(() => {
                            const cp = window.getCollectionPrice(col, state.address);
                            return cp.price === 0 ? 'text-green-400' : (cp.currency === 'PUNKS' ? 'text-magenta-400' : 'text-white');
                        })()}">${(() => {
                            const cp = window.getCollectionPrice(col, state.address);
                            return cp.price === 0 ? 'üéÅ FREE' : `${cp.price} ${cp.currency}`;
                        })()}</span>
                        <span class="fira text-xs text-orange-400">Remaining: ${col.remainingSupply}/${col.totalSupply}</span>
                    </div>`}
                    
                    <!-- Quantity selector -->
                    <div class="flex items-center gap-2 ${buttonDisabled ? 'opacity-50 pointer-events-none' : ''}">
                        <label class="fira text-xs text-gray-400">Qty:</label>
                        <select id="mintQuantity_${col.collectionId}" 
                                onclick="event.stopPropagation()" 
                                onchange="event.stopPropagation()"
                                class="bg-black/40 border border-white/10 rounded px-2 py-1 text-xs text-white min-w-[60px]" 
                                ${buttonDisabled}>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="5">5</option>
                            <option value="10">10</option>
                        </select>
                        <span class="fira text-xs text-gray-500">NFTs</span>
                    </div>
                    
                    <button class="${buttonClass}" ${buttonDisabled} onclick="event.stopPropagation(); ${buttonDisabled ? '' : `window.mintMultipleFromCollection('${col.collectionId}')`}">
                        ${buttonText}
                    </button>
                    
                    <!-- Pre-Mint button removed per user request -->
                </div>
            `;
            };
            
            // Render blind drops (ALL blind mints with remaining supply stay as mystery)
            if (blindDrops.length === 0) {
                blindDropContainer.innerHTML = '<div class="col-span-full text-center text-gray-500 fira text-sm py-20">No blind mint collections available</div>';
            } else {
                blindDropContainer.innerHTML = blindDrops.map(col => renderCollectionCard(col, true)).join(''); // Always render as blind (dice image + Mystery Forge button)
            }
            
            // Render Active Collections (Include revealed blind mints - mintedCount > 0)
            const collectionsForActiveSection = activeCollections.filter(c => {
                // Show regular mints OR blind mints that have been revealed (mintedCount > 0)
                const shouldShow = !c.blindMintEnabled || (c.blindMintEnabled && c.mintedCount > 0);
                if (c.blindMintEnabled) {
                    console.log(`   üîç Blind mint "${c.collectionTitle}": mintedCount=${c.mintedCount}, remainingSupply=${c.remainingSupply}, showInActive=${shouldShow}`);
                }
                return shouldShow;
            });
            
            if (collectionsForActiveSection.length === 0) {
                regularContainer.innerHTML = '<div class="col-span-full text-center text-gray-500 fira text-sm py-20">No active collections</div>';
            } else {
                // Pagination: Show top 5 in active section
                const MAX_VISIBLE = 5;
                const collectionsToShow = collectionsForActiveSection.slice(0, MAX_VISIBLE);
                
                regularContainer.innerHTML = collectionsToShow.map(col => {
                    // Calculate stats for this collection
                    const colNFTs = state.nfts.filter(n => n.collectionId === col.collectionId);
                    const listed = colNFTs.filter(n => n.isListed);
                    const listedKTA = listed.filter(n => n.listedCurrency === 'KTA');
                    const listedPUNKS = listed.filter(n => n.listedCurrency === 'PUNKS');
                    const floorKTA = listedKTA.length > 0 ? Math.min(...listedKTA.map(n => n.listedPrice)) : null;
                    const floorPUNKS = listedPUNKS.length > 0 ? Math.min(...listedPUNKS.map(n => n.listedPrice)) : null;
                    const floorText = floorKTA ? `${floorKTA.toFixed(2)} KTA` : (floorPUNKS ? `${floorPUNKS} PUNKS` : 'N/A');
                    
                    // Calculate 24h volume (KTA + PUNKS)
                    let volume24h = 0;
                    colNFTs.forEach(n => {
                        if (n.soldAt && n.soldPrice && (n.soldCurrency === 'KTA' || n.soldCurrency === 'PUNKS')) {
                            const saleTime = new Date(n.soldAt).getTime();
                            const now = Date.now();
                            if (now - saleTime < 24 * 3600000) { 
                                volume24h += n.soldPrice;
                            }
                        }
                    });
                    
                    // Get display image
                    let displayImage;
                    if (col.isExternal) {
                        // External collections: get image from first NFT
                        const firstNFT = state.nfts.find(n => n.collectionId === col.collectionId || getNormalizedId(n.collectionToken) === getNormalizedId(col.collectionToken));
                        displayImage = firstNFT?.image || firstNFT?.imageUrl || 'https://via.placeholder.com/400?text=No+Image';
                    } else if (col.previewImageUrl) {
                        displayImage = col.previewImageUrl;
                        console.log(`üì∏ Using previewImageUrl for ${col.collectionTitle}:`, displayImage);
                    } else if (col.ipfsCid && col.scannedFiles && col.scannedFiles[0]) {
                        // FALLBACK STRATEGY: Try IPFS first, but use minted NFT image if CID is invalid
                        const sf2 = col.scannedFiles[0].replace('.json', '.png');
                        const imageCid = sf2.includes('/') ? `${col.ipfsCid}/${sf2}` : `${col.ipfsCid}/images/${sf2}`;
                        // Check if this is a known bad CID (testing)
                        if (col.ipfsCid.includes('bafybeie7qko5mlbdaix6kbdxcgukls7dezwn4ql3pq6bktcgcviwztceey') || 
                            col.ipfsCid.includes('bafybeicwvbme2i4jjnxlm5yjaof5rdgbmeujxb2jao4v3nvmsvr6e6oj4a')) {
                            // Bad CID detected - try to use a minted NFT's image instead
                            const mintedNFT = state.nfts.find(n => n.collectionId === col.collectionId);
                            if (mintedNFT) {
                                const nftImgPath = window.getNFTImagePath(mintedNFT);
                                displayImage = nftImgPath ? ((nftImgPath.startsWith('http://') || nftImgPath.startsWith('https://')) ? nftImgPath : getIPFSUrl(nftImgPath)) : 'https://via.placeholder.com/400?text=No+Image';
                                console.log(`üì∏ Using minted NFT image for ${col.collectionTitle}:`, displayImage);
                            } else {
                                // No minted NFT, use placeholder
                                displayImage = 'data:image/svg+xml;base64,' + btoa(`
                                    <svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
                                        <rect width="400" height="400" fill="#6366f1"/>
                                        <text x="200" y="200" font-family="Arial" font-size="32" fill="white" text-anchor="middle" dominant-baseline="middle">${col.collectionTitle || 'Collection'}</text>
                                    </svg>
                                `);
                                console.log(`üì∏ Using PLACEHOLDER for ${col.collectionTitle} (bad CID):`, 'SVG data URL');
                            }
                        } else {
                            displayImage = getIPFSUrl(imageCid);
                            console.log(`üì∏ Using scannedFiles for ${col.collectionTitle}:`, displayImage);
                        }
                    } else if (col.collectionThumbnail) {
                        // Use IPFS rotator for collection thumbnail
                        displayImage = getIPFSUrl(col.collectionThumbnail);
                        console.log(`üì∏ Using collectionThumbnail for ${col.collectionTitle}:`, displayImage);
                    } else if (col.collectionThumbnailCid) {
                        // Use IPFS rotator for collection thumbnail CID
                        displayImage = getIPFSUrl(col.collectionThumbnailCid);
                        console.log(`üì∏ Using collectionThumbnailCid for ${col.collectionTitle}:`, displayImage);
                    } else if (col.blindMintEnabled && col.mintedCount > 0) {
                        // For revealed blind mints, show a minted NFT image
                        const mintedNFT = state.nfts.find(n => n.collectionId === col.collectionId && n.wasBlindMinted);
                        if (mintedNFT) {
                            const nftImgPath = window.getNFTImagePath(mintedNFT);
                            displayImage = nftImgPath ? ((nftImgPath.startsWith('http://') || nftImgPath.startsWith('https://')) ? nftImgPath : getIPFSUrl(nftImgPath)) : 'https://via.placeholder.com/400?text=No+Image';
                            console.log(`üì∏ Using minted NFT for ${col.collectionTitle}:`, displayImage);
                        } else {
                            displayImage = 'https://via.placeholder.com/400?text=No+Image';
                        }
                    } else if (col.blindMintEnabled && col.collectionThumbnailCid) {
                        // For unrevealed blind mints, use collection thumbnail if available
                        displayImage = getIPFSUrl(col.collectionThumbnailCid);
                        console.log(`üì∏ Using blind mint thumbnail for ${col.collectionTitle}:`, displayImage);
                    } else {
                        displayImage = 'https://via.placeholder.com/400?text=No+Image';
                        console.warn(`‚ö†Ô∏è No image source found for ${col.collectionTitle}. Collection data:`, {
                            ipfsCid: col.ipfsCid,
                            scannedFiles: col.scannedFiles,
                            collectionThumbnail: col.collectionThumbnail,
                            collectionThumbnailCid: col.collectionThumbnailCid,
                            previewImageUrl: col.previewImageUrl,
                            blindMintEnabled: col.blindMintEnabled,
                            mintedCount: col.mintedCount
                        });
                    }
                    
                    const volumeBadge = volume24h > 0 ? `
                        <div class="absolute top-2 right-2 bg-orange-500/90 px-2 py-1 rounded text-[10px] orbitron font-black text-black">
                            ${volume24h.toFixed(1)} KTA VOL
                        </div>
                    ` : '';
                    
                    const blindBadge = '';
                    
                    // Extract clean CID for error handling
                    let imageCid = '';
                    if (displayImage && displayImage.includes('/ipfs/')) {
                        imageCid = displayImage.split('/ipfs/')[1] || '';
                    } else if (displayImage && !displayImage.startsWith('http')) {
                        imageCid = displayImage;
                    }
                    
                    return `
                    <div onclick="window.viewCollection('${col.collectionToken || col.collectionId}')" class="glass-card p-6 flex flex-col group cursor-pointer border-white/5 hover:border-cyan-500/40 transition-all relative">
                        ${volumeBadge}
                        ${blindBadge}
                        <img src="${displayImage}" 
                             ${imageCid ? `onerror="handleIPFSImageError(this, '${imageCid}')"` : ''}
                             class="sharp-img rounded-xl aspect-square object-cover mb-6 border border-white/10 group-hover:scale-105 transition-transform duration-300 shadow-2xl will-change-transform" 
                             style="transform-origin: center; backface-visibility: hidden;">
                        <h4 class="orbitron text-xs font-black text-white mb-2 uppercase">${col.collectionTitle || 'Unknown'}</h4>
                        <div class="flex justify-between items-center mt-2 fira text-[9px] font-black uppercase">
                            <span class="text-gray-600">${colNFTs.length}${col.totalSupply ? ' / ' + col.totalSupply : ''} SUPPLY</span>
                            <span class="text-cyan-400">Floor: ${floorText}</span>
                        </div>
                        ${!col.isExternal && (col.remainingSupply > 0) ? `
                        <div class="flex justify-between items-center mt-1 fira text-[9px] font-black uppercase">
                            <span class="text-gray-600">${col.mintedCount || 0} MINTED</span>
                            <span class="text-green-400">${col.remainingSupply || 0} LEFT</span>
                        </div>
                        ` : ''}
                        <button onclick="event.stopPropagation(); window.viewCollection('${(col.collectionToken || col.collectionId).replace(/'/g, "\\'")}')" class="w-full mt-3 p-2 border border-cyan-500/30 text-cyan-400 rounded-lg text-[8px] hover:bg-cyan-500/10 orbitron font-bold uppercase transition-all">
                            View Collection
                        </button>
                        <!-- Make Offer button hidden - Coming soon in v1.1
                        <button onclick="event.stopPropagation(); window.makeOfferOnCollection('${(col.collectionToken || col.collectionId).replace(/'/g, "\\'")}')" class="w-full mt-3 p-2 border border-purple-500/30 text-purple-400 rounded-lg text-[8px] hover:bg-purple-500/10 orbitron font-bold uppercase transition-all">
                            Make Offer
                        </button>
                        -->
                    </div>`;
                }).join('');
            }
            
            // Start countdown timers if any
            window.startCountdownTimers?.();
            
            // Post-render: proactively load IPFS images via fetch to bypass CORS
            setTimeout(() => {
                document.querySelectorAll('img[src*="/ipfs/"]').forEach(img => {
                    if (img.complete && img.naturalWidth > 0) return; // Already loaded
                    const src = img.getAttribute('src');
                    if (src && src.includes('/ipfs/')) {
                        const cidPath = src.split('/ipfs/')[1];
                        if (cidPath) window.loadIPFSImage(img, cidPath);
                    }
                });
            }, 500);
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ALL COLLECTIONS PAGE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        state._allCollectionsSort = 'volume';
        state._allCollectionsSearch = '';

        window.renderAllCollections = () => {
            const grid = document.getElementById('allCollectionsGrid');
            if (!grid) return;

            let collections = (state.collections || []).filter(c => !c.hidden);

            // Search filter
            const search = (state._allCollectionsSearch || '').toLowerCase().trim();
            if (search) {
                collections = collections.filter(c => 
                    (c.collectionTitle || '').toLowerCase().includes(search) ||
                    (c.collectionId || '').toLowerCase().includes(search) ||
                    (c.creator || '').toLowerCase().includes(search)
                );
            }

            // Compute stats for sorting
            collections = collections.map(col => {
                const normalizedToken = getNormalizedId(col.collectionToken);
                const colNFTs = state.nfts.filter(n => 
                    n.collectionId === col.collectionId || 
                    getNormalizedId(n.collectionToken) === normalizedToken
                );
                const listed = colNFTs.filter(n => n.isListed);
                const listedKTA = listed.filter(n => n.listedCurrency === 'KTA');
                const listedPUNKS = listed.filter(n => n.listedCurrency === 'PUNKS');
                const floorKTA = listedKTA.length > 0 ? Math.min(...listedKTA.map(n => n.listedPrice)) : null;
                const floorPUNKS = listedPUNKS.length > 0 ? Math.min(...listedPUNKS.map(n => n.listedPrice)) : null;
                const floorText = floorKTA ? `${floorKTA.toFixed(2)} KTA` : (floorPUNKS ? `${floorPUNKS} PUNKS` : 'N/A');
                
                // Volume: check state.transactions AND NFT soldPrice data
                const formattedColId = `collection_${normalizedToken}`;
                const colTxs = (state.transactions || []).filter(tx => 
                    (tx.collectionId === col.collectionId || tx.collectionId === formattedColId) && tx.price > 0
                );
                let volume = colTxs.reduce((sum, tx) => sum + (tx.price || 0), 0);
                // Also add from NFT sold data if transactions aren't loaded
                if (volume === 0) {
                    colNFTs.forEach(n => {
                        if (n.soldPrice && n.soldPrice > 0) volume += n.soldPrice;
                    });
                }

                return { 
                    ...col, 
                    _listedCount: listed.length, 
                    _floorKTA: floorKTA, 
                    _floorPUNKS: floorPUNKS,
                    _floorText: floorText,
                    _volume: volume,
                    _totalNFTs: colNFTs.length,
                    _colNFTs: colNFTs
                };
            });

            // Sort
            switch (state._allCollectionsSort) {
                case 'volume':
                    collections.sort((a, b) => (b._volume || 0) - (a._volume || 0));
                    break;
                case 'floor':
                    collections.sort((a, b) => (b._floorKTA || 0) - (a._floorKTA || 0));
                    break;
                case 'listed':
                    collections.sort((a, b) => (b._listedCount || 0) - (a._listedCount || 0));
                    break;
                case 'newest':
                    collections.sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0));
                    break;
            }

            if (collections.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-500 fira text-sm py-20">No collections found</div>';
                return;
            }

            grid.innerHTML = collections.map(col => {
                const imgUrl = window.resolveCollectionImage(col);
                
                // Extract CID for IPFS error handling
                let imageCid = '';
                if (imgUrl && imgUrl.includes('/ipfs/')) {
                    imageCid = imgUrl.split('/ipfs/')[1] || '';
                }
                
                const supply = col.totalSupply || col._totalNFTs || '?';
                const minted = col._totalNFTs || col.mintedCount || 0;

                return `<div onclick="window.viewCollection('${(col.collectionToken || col.collectionId).replace(/'/g, "\\\\'")}')" 
                             class="glass-card overflow-hidden group cursor-pointer border-white/5 hover:border-cyan-500/40 transition-all duration-300">
                    <div class="relative h-48 overflow-hidden">
                        <img src="${imgUrl}" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110" 
                             ${imageCid ? `onerror="handleIPFSImageError(this, '${imageCid}')"` : `onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22 width=%22400%22 height=%22400%22/%3E%3C/svg%3E'"`}>
                        ${col._volume > 0 ? `<div class="absolute top-2 right-2 bg-cyan-500/80 text-black text-[9px] orbitron font-bold px-2 py-0.5 rounded">${col._volume.toFixed(1)} KTA VOL</div>` : ''}
                    </div>
                    <div class="p-4 space-y-3">
                        <h4 class="orbitron text-sm font-bold text-white truncate">${col.collectionTitle || 'Unnamed'}</h4>
                        <div class="grid grid-cols-2 gap-2 text-[10px] fira">
                            <div>
                                <div class="text-gray-500">Floor</div>
                                <div class="text-cyan-400 font-bold">${col._floorText}</div>
                            </div>
                            <div>
                                <div class="text-gray-500">Listed</div>
                                <div class="text-white font-bold">${col._listedCount}</div>
                            </div>
                            <div>
                                <div class="text-gray-500">Supply</div>
                                <div class="text-white font-bold">${minted} / ${supply}</div>
                            </div>
                            <div>
                                <div class="text-gray-500">Items</div>
                                <div class="text-white font-bold">${col._totalNFTs}</div>
                            </div>
                        </div>
                        <button onclick="event.stopPropagation(); window.viewCollection('${(col.collectionToken || col.collectionId).replace(/'/g, "\\\\'")}')" 
                                class="w-full p-2 border border-cyan-500/30 text-cyan-400 rounded-lg text-[10px] hover:bg-cyan-500/10 orbitron font-bold uppercase transition-all">
                            View Collection
                        </button>
                    </div>
                </div>`;
            }).join('');
        };

        window.filterAllCollections = (value) => {
            state._allCollectionsSearch = value;
            window.renderAllCollections();
        };

        window.sortAllCollections = (sortBy) => {
            state._allCollectionsSort = sortBy;
            // Update button styles
            ['volume', 'floor', 'listed', 'newest'].forEach(s => {
                const btn = document.getElementById(`sort${s.charAt(0).toUpperCase() + s.slice(1)}`);
                if (btn) {
                    btn.className = s === sortBy 
                        ? 'px-3 py-1.5 bg-cyan-500/20 text-cyan-400 rounded-lg transition-all text-xs orbitron font-bold'
                        : 'px-3 py-1.5 bg-black/20 text-gray-500 rounded-lg transition-all hover:text-white text-xs orbitron font-bold';
                }
            });
            window.renderAllCollections();
        };

        window.createBlindMintCollection = async () => {
            if (state.isForging) {
                window.notify("Collection creation already in progress", "error");
                return;
            }
            
            const collectionTitle = document.getElementById('collectionTitleInput')?.value.trim() || "";
            const cidVal = document.getElementById('batchFolderCid')?.value.trim() || "";
            const totalSupply = parseInt(document.getElementById('totalSupplyInput')?.value) || 10;
            const maxMintsPerWallet = parseInt(document.getElementById('maxMintsPerWalletInput')?.value) || 1;
            const pktaVal = parseFloat(document.getElementById('batchPriceKTA')?.value) || 0;
            const punksVal = parseFloat(document.getElementById('batchPricePunks')?.value) || 0;
            const isDrop = document.getElementById('enableDropMode')?.checked || false;
            const desc = document.getElementById('collectionDescInput')?.value || "";
            const colThumb = document.getElementById('collectionThumbnailInput')?.value.trim() || "";
            const collectionType = document.querySelector('input[name="collectionType"]:checked')?.value || "external_ipfs";
            const creatorRoyalty = parseFloat(document.getElementById('creatorRoyaltyPercent')?.value) || 5; // Default 5%
            
            if (!collectionTitle) return window.notify("Collection Title Required", "error");
            if (!cidVal) return window.notify("IPFS CID Required", "error");
            if (!state.keetaClient) return window.notify("Connect wallet first", "error");
            if (state.scannedFiles.length === 0) return window.notify("No files scanned", "error");
            if (totalSupply > state.scannedFiles.length) return window.notify(`Supply exceeds scanned files`, "error");
            
            // REMOVED: Escrow wallet not needed for collection creation
            // Collections are always created from user's wallet
            // Escrow is only for marketplace buy/sell, not for minting
            
            state.isForging = true;
            const startBtn = document.getElementById('startForgeBtn');
            if (startBtn) startBtn.disabled = true;
            
            window.debugLog("üöÄ Creating blind mint collection...");
            
            try {
                // Always use user's client/account for collection creation
                const client = state.keetaClient;
                const signer = state.keetaAccount;
                
                if (!client) throw new Error("Client not initialized");
                if (typeof client.init === 'function') await client.init();
                
                window.debugLog("üîß Creating collection token...");
                
                const cB = client.initBuilder(); 
                cB.updateAccounts({ signer, account: signer });
                const cID = cB.generateIdentifier(KeetaNet.lib.Account.AccountKeyAlgorithm.TOKEN);
                await client.computeBuilderBlocks(cB); 
                
                // FIX #8: Add collection metadata to token
                const collectionMetadata = {
                    name: collectionTitle,
                    symbol: collectionTitle.replace(/\s+/g, '').substring(0, 8).toUpperCase(),
                    description: desc || `${collectionTitle} NFT Collection`,
                    totalSupply: totalSupply,
                    tokenType: "COLLECTION",
                    standard: "KeeTa-Collection",
                    ipfsCid: cidVal,
                    thumbnail: colThumb,
                    createdAt: new Date().toISOString(),
                    creator: signer.publicKeyString.get(),
                    blindMintEnabled: isDrop,
                    priceKTA: pktaVal,
                    maxMintsPerWallet: maxMintsPerWallet
                };
                
                cB.modifyTokenSupply(1n, { 
                    account: cID.account,
                    metadata: JSON.stringify(collectionMetadata)
                });
                await client.publishBuilder(cB);
                const colAddr = cID.account.publicKeyString.get();
                
                window.debugLog(`‚úÖ Collection token: ${colAddr.substring(0, 12)}...`);

                const collectionId = `collection_${getNormalizedId(colAddr)}`;
                
                // RANDOM MINTING: Shuffle scanned files for blind mint
                let mintOrder = state.scannedFiles.slice(0, totalSupply);
                
                console.log("üîç PRE-SHUFFLE ORDER (first 10):", mintOrder.slice(0, 10));
                console.log("üé≤ Blind mint enabled?", isDrop);
                
                if (isDrop && mintOrder.length > 0) {
                    // Fisher-Yates shuffle for truly random order
                    for (let i = mintOrder.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [mintOrder[i], mintOrder[j]] = [mintOrder[j], mintOrder[i]];
                    }
                    console.log("üé≤ SHUFFLED! New order (first 10):", mintOrder.slice(0, 10));
                    console.log("üé≤ Collection will mint in this random order");
                } else {
                    console.log("‚ö†Ô∏è Shuffle SKIPPED - blind mint not enabled or no files");
                }
                
                await setDoc(doc(db, 'collections', collectionId), {
                    collectionId, collectionTitle, collectionName: collectionTitle, collection: collectionTitle,
                    collectionType, collectionToken: colAddr,
                    totalSupply, mintedCount: 0, remainingSupply: totalSupply, ipfsCid: cidVal,
                    priceKTA: state.priceMode !== 'punks' ? pktaVal : 0,
                    pricePunks: state.priceMode !== 'kta' ? punksVal : 0,
                    maxMintsPerWallet, blindMintEnabled: isDrop,
                    collectionDesc: desc || "Metadata encrypted.",
                    collectionThumbnailCid: colThumb, 
                    previewImageUrl: state.previewImageUrl || '',
                    creator: state.address,
                    createdBy: state.address, createdAt: new Date().toISOString(),
                    creatorRoyaltyPercent: creatorRoyalty / 100, // Convert 5 to 0.05
                    scannedFiles: mintOrder
                });
                
                window.debugLog(`‚úÖ Collection created: ${collectionTitle}`);
                window.notify(`Collection "${collectionTitle}" deployed!`, "success");
                
                document.getElementById('collectionTitleInput').value = '';
                document.getElementById('batchFolderCid').value = '';
                document.getElementById('collectionDescInput').value = '';
                document.getElementById('collectionThumbnailInput').value = '';
                state.scannedFiles = [];
                state.previewImageUrl = '';
                document.getElementById('forgeReadyArea')?.classList.add('hidden');
                
                await window.loadCollections();
                
            } catch (error) {
                console.error("Collection creation error:", error);
                
                // Check if it's an insufficient funds error
                if (error.message && error.message.includes('balance becomes negative')) {
                    window.notify(`‚ùå Escrow wallet needs funding! Send 10-20 KTA to: ${MARKETPLACE_FEE_WALLET.substring(0, 25)}...`, "error");
                    console.error("‚ö†Ô∏è ESCROW WALLET UNDERFUNDED");
                    console.error("üìç Send KTA to:", MARKETPLACE_FEE_WALLET);
                    console.error("üí° Recommended: 10-20 KTA for smooth operations");
                } else {
                    window.notify(`Collection creation failed: ${error.message}`, "error");
                }
            } finally {
                state.isForging = false;
                if (startBtn) startBtn.disabled = false;
            }
        };

        window.scanCollectionFolder = async () => {
            const cid = document.getElementById('batchFolderCid')?.value.trim() || "";
            const totalSupply = parseInt(document.getElementById('totalSupplyInput')?.value) || 10;
            
            if (!cid) return window.notify("CID Required", "error");
            
            try {
                window.notify("Scanning Protocol CID...", "success");
                console.log("üîç Scanning IPFS folder:", cid);
                
                const gateways = [
                    `https://gateway.pinata.cloud/ipfs/${cid}`,
                    `https://ipfs.io/ipfs/${cid}`,
                    `https://4everland.io/ipfs/${cid}`
                ];
                
                let html = null;
                
                for (const gateway of gateways) {
                    try {
                        const res = await fetch(gateway, { method: 'GET', mode: 'cors' });
                        if (res.ok) {
                            html = await res.text();
                            break;
                        }
                    } catch (err) {
                        console.warn(`Gateway failed: ${gateway}`);
                    }
                }
                
                if (!html) {
                    console.log("‚ö†Ô∏è IPFS scan failed, trying auto-detection...");
                    // Try to fetch first file to detect format
                    const testFormats = [
                        `001.json`,  // Standard format
                        `0001.json`, // 4-digit padding
                        `1.json`,    // 1-indexed JSON
                        `0`,         // Bueno format (no extension)
                        `1`          // Bueno 1-indexed
                    ];
                    
                    let detectedFormat = null;
                    for (const testFile of testFormats) {
                        try {
                            const res = await fetch(`https://ipfs.io/ipfs/${cid}/${testFile}`);
                            if (res.ok) {
                                detectedFormat = testFile;
                                console.log(`‚úÖ Detected format: ${testFile}`);
                                break;
                            }
                        } catch (e) { continue; }
                    }
                    
                    if (detectedFormat) {
                        // Generate file list based on detected format
                        if (detectedFormat.endsWith('.json')) {
                            if (detectedFormat.startsWith('0001')) {
                                // 4-digit padding
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(4, '0')}.json`);
                            } else if (detectedFormat.startsWith('001')) {
                                // 3-digit padding (standard)
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                            } else {
                                // No padding
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${i + 1}.json`);
                            }
                        } else {
                            // Bueno format (no extension)
                            if (detectedFormat === '0') {
                                // 0-indexed
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => String(i));
                            } else {
                                // 1-indexed
                                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => String(i + 1));
                            }
                        }
                        console.log(`üìã Generated ${state.scannedFiles.length} files in format: ${detectedFormat}`);
                    } else {
                        // Ultimate fallback: standard format
                        state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                        console.log("‚ö†Ô∏è Could not detect format, using standard: 001.json, 002.json...");
                    }
                } else {
                    // Parse HTML for file list
                    const matches = html.match(/href="([^"]*\.json[^"]*)"/gi) || [];
                    const jsonFiles = [...new Set(matches.map(m => m.match(/href="([^"]*)"/)[1].split('/').pop().split('?')[0]))].filter(f => f.endsWith('.json')).sort();
                    
                    if (jsonFiles.length > 0) {
                        state.scannedFiles = jsonFiles.slice(0, totalSupply);
                        console.log(`‚úÖ Found ${state.scannedFiles.length} .json files`);
                    } else {
                        // No .json files, check for Bueno format (plain numbers)
                        const allMatches = html.match(/href="([^"]+)"/gi) || [];
                        const numberFiles = [...new Set(allMatches.map(m => {
                            const match = m.match(/href="([^"]*)"/);
                            return match ? match[1].split('/').pop().split('?')[0] : null;
                        }))].filter(f => f && f !== '..' && f !== '.' && /^\d+$/.test(f)).sort((a, b) => parseInt(a) - parseInt(b));
                        
                        if (numberFiles.length > 0) {
                            state.scannedFiles = numberFiles.slice(0, totalSupply);
                            console.log(`‚úÖ Found ${state.scannedFiles.length} Bueno-format files (plain numbers)`);
                        } else {
                            // Fallback to standard
                            state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                        }
                    }
                }
                
                if (state.scannedFiles.length > 0) {
                    document.getElementById('forgeReadyArea')?.classList.remove('hidden');
                    document.getElementById('previewDetails')?.classList.remove('hidden');
                    
                    const countEl = document.getElementById('previewCount');
                    if (countEl) countEl.textContent = state.scannedFiles.length;
                    
                    try {
                        console.log("üì∏ [DEBUG] CID:", cid);
                        console.log("üì∏ [DEBUG] First file:", state.scannedFiles[0]);
                        console.log("üì∏ Loading preview from:", state.scannedFiles[0]);
                        const metadataFetchUrl = `${getIPFSUrl(cid)}/${state.scannedFiles[0]}`;
                        console.log("üì∏ [DEBUG] Fetching metadata from:", metadataFetchUrl);
                        const mR = await fetch(metadataFetchUrl);
                        console.log("üì∏ [DEBUG] Fetch response status:", mR.status, mR.ok);
                        const meta = await mR.json();
                        console.log("üì∏ Metadata:", meta);
                        
                        let imageUrl = '';
                        if (meta.image) {
                            if (meta.image.startsWith('ipfs://')) {
                                imageUrl = meta.image.startsWith('ipfs://') ? getIPFSUrl(meta.image.replace('ipfs://', '')) : meta.image;
                            } else if (meta.image.startsWith('http')) {
                                imageUrl = meta.image;
                            } else {
                                // All relative paths need CID prepended
                                imageUrl = `${getIPFSUrl(cid)}/${meta.image}`;
                            }
                        }
                        
                        console.log("üì∏ Image URL:", imageUrl);
                        
                        // Store preview URL in state for collection creation
                        state.previewImageUrl = imageUrl;
                        
                        const previewContainer = document.getElementById('previewImageContainer');
                        if (previewContainer && imageUrl) {
                            previewContainer.innerHTML = `<img src="${imageUrl}" class="sharp-img w-full h-full object-cover" onload="console.log('‚úÖ Preview image loaded')" onerror="console.error('‚ùå Preview image failed'); this.parentElement.innerHTML='<div class=\\'w-full h-full bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded flex items-center justify-center text-4xl\\'>üé®</div>'">`;
                        }
                        
                    } catch (e) {
                        console.warn("üì∏ Preview failed:", e);
                        const colThumb = document.getElementById('collectionThumbnailInput')?.value.trim() || "";
                        const previewContainer = document.getElementById('previewImageContainer');
                        if (previewContainer) {
                            if (colThumb) {
                                previewContainer.innerHTML = `<img src="${getIPFSUrl(colThumb)}" class="sharp-img w-full h-full object-cover" onerror="this.parentElement.innerHTML='<div class=\\'w-full h-full bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded flex items-center justify-center text-4xl\\'>üé®</div>'">`;
                            } else {
                                previewContainer.innerHTML = `<div class="w-full h-full bg-gradient-to-br from-purple-900/40 to-cyan-900/40 rounded flex items-center justify-center text-4xl">üé®</div>`;
                            }
                        }
                    }
                    
                    window.notify(`‚úÖ Validated ${state.scannedFiles.length} units`, "success");
                } else {
                    window.notify("No files found", "error");
                }
                
            } catch (e) { 
                console.error("Scan error:", e);
                state.scannedFiles = Array.from({length: totalSupply}, (_, i) => `${String(i + 1).padStart(3, '0')}.json`);
                if (state.scannedFiles.length > 0) {
                    document.getElementById('forgeReadyArea')?.classList.remove('hidden');
                    document.getElementById('previewDetails')?.classList.remove('hidden');
                }
            }
        };

        // Marketplace rendering with volume-based sorting
        window.renderMarketplace = () => {
            console.log("üé® renderMarketplace called");
            console.log("üìä state.nfts.length:", state.nfts?.length || 0);
            console.log("üìä state.collections.length:", state.collections?.length || 0);
            
            const grid = document.getElementById('collectionListGrid');
            if (!grid) {
                console.error("‚ùå collectionListGrid element not found!");
                return;
            }
            
            if (state.nfts.length === 0) {
                grid.innerHTML = Array.from({length: 5}).map(() => `<div class="unit-slot"></div>`).join('');
                return;
            }
            
            const search = document.getElementById('marketSearch')?.value.toLowerCase() || "";
            const collections = {};
            
            state.nfts.forEach(n => {
                const k = getNormalizedId(n.collectionToken);
                if (!collections[k]) collections[k] = { ...n, count: 0, floorKTA: null, floorPUNKS: null, volume24h: 0, salesCount: 0 };
                collections[k].count++;
                
                // Track sales for volume calculation
                if (n.soldAt && n.soldPrice && n.soldCurrency === 'KTA') {
                    const saleTime = new Date(n.soldAt).getTime();
                    const now = Date.now();
                    if (now - saleTime < 24 * 3600000) { // Last 24 hours
                        collections[k].volume24h += n.soldPrice;
                        collections[k].salesCount++;
                    }
                }
                
                if (n.isListed) {
                    if (n.listedCurrency === 'KTA') {
                        if (!collections[k].floorKTA || n.listedPrice < collections[k].floorKTA) collections[k].floorKTA = n.listedPrice;
                    } else if (n.listedCurrency === 'PUNKS') {
                        if (!collections[k].floorPUNKS || n.listedPrice < collections[k].floorPUNKS) collections[k].floorPUNKS = n.listedPrice;
                    }
                }
            });
            
            const filtered = Object.keys(collections).filter(k => (collections[k].collection || "").toLowerCase().includes(search));
            
            // Sort by 24h volume (highest first) - TRENDING
            const sorted = filtered.sort((a, b) => {
                const volA = collections[a].volume24h || 0;
                const volB = collections[b].volume24h || 0;
                return volB - volA; // Descending
            });
            
            grid.innerHTML = sorted.map(k => {
                const col = collections[k];
                const fullCollection = state.collections.find(c => getNormalizedId(c.collectionToken) === k);
                
                // For external collections, get image from first NFT
                let thumbUrl;
                if (fullCollection) {
                    thumbUrl = window.resolveCollectionImage(fullCollection);
                } else if (col.collectionThumbnailCid || col.imageCid) {
                    const thumbCid = col.collectionThumbnailCid || col.imageCid;
                    thumbUrl = thumbCid ? `${getIPFSUrl(thumbCid)}` : `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23000' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-family='monospace' font-size='20'%3ECLASSIFIED%3C/text%3E%3C/svg%3E`;
                } else {
                    thumbUrl = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23000' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-family='monospace' font-size='20'%3ECLASSIFIED%3C/text%3E%3C/svg%3E`;
                }
                const floorText = col.floorKTA ? `${col.floorKTA.toFixed(2)} KTA` : (col.floorPUNKS ? `${col.floorPUNKS} PUNKS` : 'N/A');
                
                // Get supply stats from fullCollection if available
                const nftsOnMarket = state.nfts.filter(n => getNormalizedId(n.collectionToken) === k || n.collectionId === fullCollection?.collectionId).length;
                const totalSupply = fullCollection?.totalSupply || col.count || nftsOnMarket || 0;
                const mintedCount = fullCollection?.mintedCount || nftsOnMarket || 0;
                const remainingSupply = fullCollection?.remainingSupply || 0;
                
                // Show volume badge for trending
                const volumeBadge = col.volume24h > 0 ? `
                    <div class="absolute top-2 right-2 bg-orange-500/90 px-2 py-1 rounded text-[7px] orbitron font-black text-black">
                        ${col.volume24h.toFixed(1)} KTA VOL
                    </div>
                ` : '';
                
                // No blind mint badge on trending cards
                const blindBadge = '';
                
                // Extract CID for error handling
                let trendingImgCid = '';
                if (thumbUrl && thumbUrl.includes('/ipfs/')) {
                    trendingImgCid = thumbUrl.split('/ipfs/')[1] || '';
                }
                
                return `
                <div onclick="window.viewCollection('${k}')" class="glass-card p-6 flex flex-col group cursor-pointer border-white/5 hover:border-cyan-500/40 transition-all relative">
                    ${volumeBadge}
                    ${blindBadge}
                    <img src="${thumbUrl}" class="sharp-img rounded-xl aspect-square object-cover mb-6 border border-white/10 group-hover:scale-105 transition-transform duration-300 shadow-2xl will-change-transform" style="transform-origin: center; backface-visibility: hidden;"
                         ${trendingImgCid ? `onerror="handleIPFSImageError(this, '${trendingImgCid}')"` : `onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22 width=%22400%22 height=%22400%22/%3E%3C/svg%3E'"`}>
                    <h4 class="orbitron text-xs font-black text-white mb-2 uppercase">${col.collection || col.collectionTitle || col.collectionName || 'Unknown Collection'}</h4>
                    <div class="flex justify-between items-center mt-2 fira text-[9px] font-black uppercase">
                        <span class="text-gray-600">${nftsOnMarket}${totalSupply ? ' / ' + totalSupply : ''} SUPPLY</span>
                        <span class="text-cyan-400">Floor: ${floorText}</span>
                    </div>
                    ${!fullCollection?.isExternal && remainingSupply > 0 ? `
                    <div class="flex justify-between items-center mt-1 fira text-[9px] font-black uppercase">
                        <span class="text-gray-600">${mintedCount} MINTED</span>
                        <span class="text-green-400">${remainingSupply} LEFT</span>
                    </div>
                    ` : ''}
                    <!-- Make Offer button hidden - Coming soon in v1.1
                    <button onclick="event.stopPropagation(); window.makeOfferOnCollection('${k.replace(/'/g, "\\'")}')" class="w-full mt-3 p-2 border border-purple-500/30 text-purple-400 rounded-lg text-[8px] hover:bg-purple-500/10 orbitron font-bold uppercase transition-all">
                        Make Offer
                    </button>
                    -->
                </div>`;
            }).join('');
            
            // Post-render: proactively load IPFS images in trending grid
            setTimeout(() => {
                grid.querySelectorAll('img[src*="/ipfs/"]').forEach(img => {
                    if (img.complete && img.naturalWidth > 0) return;
                    const src = img.getAttribute('src');
                    if (src && src.includes('/ipfs/')) {
                        const cidPath = src.split('/ipfs/')[1];
                        if (cidPath) window.loadIPFSImage(img, cidPath);
                    }
                });
            }, 500);
            
            // Dynamically add SHOW ALL button for escrow wallet only
            const buttonContainer = document.getElementById('activeCollectionsButtons');
            if (buttonContainer && state.address === ESCROW_WALLET) {
                // Check if button already exists
                if (!document.getElementById('showAllBtn')) {
                    const showAllBtn = document.createElement('button');
                    showAllBtn.id = 'showAllBtn';
                    showAllBtn.onclick = () => window.showAllCollections();
                    showAllBtn.className = 'px-4 py-2 bg-red-500/20 border border-red-500/50 text-red-400 rounded-lg text-xs orbitron font-bold hover:bg-red-500/30 transition-all';
                    showAllBtn.innerHTML = 'üö® SHOW ALL';
                    buttonContainer.insertBefore(showAllBtn, buttonContainer.firstChild);
                }
            } else if (buttonContainer) {
                // Remove button if not escrow wallet
                const existingBtn = document.getElementById('showAllBtn');
                if (existingBtn) existingBtn.remove();
            }
        };

        window.renderDrops = () => { window.renderCollections(); };

        // FIX #1: Enhanced collection rendering with full traits
        window.renderCollection = async () => {
            const grid = document.getElementById('collectionGrid');
            if (!grid) return;
            
            const my = state.nfts.filter(n => (n.owner || "").toLowerCase() === (state.address || "").toLowerCase() && n.status !== 'drop');
            
            if (my.length === 0) {
                grid.innerHTML = Array.from({length: 5}).map(() => `<div class="unit-slot"></div>`).join('');
                return;
            }
            
            // FIX #1: Fetch metadata for missing traits
            for (const nft of my) {
                if (!nft.attributes || nft.attributes.length === 0) {
                    await window.fetchNFTMetadata(nft);
                }
            }
            
            grid.innerHTML = my.map(n => {
                const isListed = n.isListed || false;
                const isPending = n.isOptimistic || n.status === 'pending';
                
                // Collection name display
                const collectionName = n.collectionName || n.collection || n.collectionTitle || 'Unknown Collection';
                
                // FIX: Build COMPLETE image URL (not partial path)
                const imgCid = window.getNFTImagePath(n);
                // Check if it's already a full URL (external NFTs) or needs gateway prefix
                const imgUrl = (imgCid && (imgCid.startsWith('http://') || imgCid.startsWith('https://'))) 
                    ? imgCid 
                    : imgCid ? getIPFSUrl(imgCid) : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E';
                
                // Render traits
                const traitsHTML = window.renderNFTTraits(n, 'toggle', false);
                
                // Show pending badge if optimistic
                const pendingBadge = isPending ? `
                    <div class="absolute top-2 right-2 z-10">
                        <div class="bg-gradient-to-br from-yellow-500 to-orange-600 text-white px-3 py-1.5 rounded-lg font-black text-[10px] orbitron shadow-lg border border-yellow-400/50 flex items-center gap-1.5 animate-pulse">
                            <span class="w-1.5 h-1.5 bg-white rounded-full animate-ping"></span>
                            <span>CONFIRMING</span>
                        </div>
                    </div>
                ` : '';
                
                // Show price badge if listed
                const priceBadge = isListed ? `
                    <div class="absolute top-3 right-3 bg-green-500 text-black px-3 py-1 rounded-lg font-black text-xs orbitron shadow-lg border-2 border-green-400">
                        ${n.listedPrice} ${n.listedCurrency}
                    </div>
                ` : '';
                
                const listingButtons = isListed ? `
                    <div class="flex gap-2 mt-3">
                        <button onclick="window.editNFTPrice('${n.id}')" class="flex-1 p-2 rounded-lg border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">Edit</button>
                        <button onclick="window.cancelListing('${n.id}')" class="flex-1 p-2 rounded-lg border border-red-500/30 text-[8px] orbitron font-bold uppercase text-red-400 hover:bg-red-500/10 transition-all">Cancel</button>
                    </div>
                ` : `
                    <div class="grid grid-cols-2 gap-2 mt-3">
                        <button onclick="window.listNFTForSale('${n.id}')" class="p-2 rounded-lg border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                            üí∞ List for Sale
                        </button>
                        <button onclick="window.createAuction('${n.id}')" class="p-2 rounded-lg border border-purple-500/30 text-[8px] orbitron font-bold uppercase text-purple-400 hover:bg-purple-500/10 transition-all">
                            üé™ Auction
                        </button>
                    </div>
                `;
                
                // Enhanced listing status badge
                const statusBadge = isListed ? `
                    <div class="absolute top-2 right-2 z-10">
                        <div class="bg-gradient-to-br from-green-500 to-emerald-600 text-white px-3 py-1.5 rounded-lg font-black text-[10px] orbitron shadow-lg border border-green-400/50 flex items-center gap-1.5">
                            <span class="w-1.5 h-1.5 bg-white rounded-full animate-pulse"></span>
                            <span>LISTED</span>
                        </div>
                        <div class="mt-1 bg-black/80 backdrop-blur-sm text-green-400 px-2 py-1 rounded text-[11px] orbitron font-bold text-center border border-green-500/30">
                            ${n.listedPrice} ${n.listedCurrency}
                        </div>
                    </div>
                ` : '';
                
                // Get collection royalty for accurate fee calculation
                const nftCollection = state.collections.find(c => 
                    c.collectionId === n.collectionId || 
                    c.collectionToken === n.collectionToken
                );
                const royaltyPercent = nftCollection?.creatorRoyaltyPercent || 0.05; // Default 5%
                const marketplaceFee = 0.03; // Always 3%
                const sellerPercent = 1 - royaltyPercent - marketplaceFee; // What seller gets
                const youReceive = n.listedPrice * sellerPercent;
                
                // Listing management dropdown (only show if listed)
                const listingDropdown = isListed ? `
                    <div class="mt-3 border border-green-500/30 rounded-lg overflow-hidden bg-green-500/5">
                        <button onclick="toggleListingDropdown('${n.id}')" 
                                class="w-full p-2 flex items-center justify-between text-[9px] orbitron font-bold uppercase text-green-400 hover:bg-green-500/10 transition-all">
                            <span>üìä Manage Listing</span>
                            <svg id="dropdown-icon-${n.id}" class="w-3 h-3 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                            </svg>
                        </button>
                        <div id="listing-dropdown-${n.id}" class="hidden border-t border-green-500/20 p-2 space-y-2">
                            <div class="text-[8px] text-gray-400 mb-2">
                                <div class="flex justify-between mb-1">
                                    <span>Listed Price:</span>
                                    <span class="text-green-400 font-bold">${n.listedPrice} ${n.listedCurrency}</span>
                                </div>
                                <div class="flex justify-between mb-1">
                                    <span>Creator Royalty:</span>
                                    <span class="text-yellow-400 font-bold">${(royaltyPercent * 100).toFixed(1)}%</span>
                                </div>
                                <div class="flex justify-between mb-1">
                                    <span>Marketplace Fee:</span>
                                    <span class="text-purple-400 font-bold">3%</span>
                                </div>
                                <div class="flex justify-between border-t border-white/10 pt-1 mt-1">
                                    <span class="font-bold">You receive:</span>
                                    <span class="text-cyan-400 font-bold">${youReceive.toFixed(2)} ${n.listedCurrency}</span>
                                </div>
                            </div>
                            <button onclick="window.editNFTPrice('${n.id}')" 
                                    class="w-full p-2 rounded border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                                ‚úèÔ∏è Edit Price
                            </button>
                            <button onclick="window.cancelListing('${n.id}')" 
                                    class="w-full p-2 rounded border border-red-500/30 text-[8px] orbitron font-bold uppercase text-red-400 hover:bg-red-500/10 transition-all">
                                ‚ùå Cancel Listing
                            </button>
                        </div>
                    </div>
                ` : `
                    <button onclick="window.listNFTForSale('${n.id}')" 
                            class="w-full mt-3 p-2 rounded-lg border border-cyan-500/30 text-[8px] orbitron font-bold uppercase text-cyan-400 hover:bg-cyan-500/10 transition-all">
                        üí∞ List for Sale
                    </button>
                `;
                
                return `
                <div class="glass-card p-4 flex flex-col group border-white/5 shadow-xl transition-all hover:border-magenta-500/30 hover:shadow-2xl hover:shadow-magenta-500/10 relative ${isPending ? 'opacity-75' : ''}">
                    ${isPending ? pendingBadge : statusBadge}
                    <img src="${imgUrl}" 
                         onerror="if(this.src.includes('ipfs')){handleIPFSImageError(this,'${imgCid}')}else{this.onerror=null}" 
                         class="sharp-img rounded-lg aspect-square object-cover mb-3 border border-white/5 shadow-2xl group-hover:scale-[1.02] transition-transform duration-300 ${isPending ? 'animate-pulse' : ''}">
                    <h4 class="orbitron text-[9px] font-bold text-white uppercase truncate">${n.name}</h4>
                    <div class="text-[8px] fira text-cyan-400 mt-1 truncate">${collectionName}</div>
                    ${isPending ? '<div class="text-[8px] text-yellow-400 mt-2 animate-pulse">‚è≥ Confirming on blockchain...</div>' : traitsHTML}
                    ${isPending ? '' : listingDropdown}
                </div>
                `;
            }).join('');
        };

        
        // Show NFTs in escrow and allow recovery
        window.showEscrowNFTs = async () => {
            const escrowNFTs = state.nfts.filter(n => n.inEscrow || (n.owner || '').toLowerCase() === (state.escrowAddress || '').toLowerCase());
            
            if (escrowNFTs.length === 0) {
                console.log('‚úÖ No NFTs in escrow');
                return;
            }
            
            console.log(`üîç Found ${escrowNFTs.length} NFTs in escrow:`);
            escrowNFTs.forEach(nft => {
                console.log(`  - ${nft.name} (${nft.tokenId})`);
            });
            
            // Automatically recover them
            for (const nft of escrowNFTs) {
                await window.recoverFromEscrow(nft.tokenId, nft.id);
            }
        };
        
        // Recover a single NFT from escrow
        window.recoverFromEscrow = async (nftTokenId, nftDocId) => {
            console.log(`üîÑ Recovering NFT ${nftTokenId} from escrow...`);
            
            try {
                // SECURITY UPDATE: Use Cloud Function for escrow operations
                console.log("üîí Calling secure backend to return NFT from escrow...");
                
                const result = await window.returnFromEscrow({
                    nftId: nftDocId,
                    sellerAddress: state.address
                });
                
                if (result.data.success) {
                    console.log('‚úÖ NFT returned by secure backend!');
                    console.log('üìù Return tx:', result.data.txHash);
                    
                    // Refresh UI
                    await window.loadNFTsFromFirebase();
                    await window.renderCollection();
                    
                    window.notify("‚úÖ NFT recovered successfully!", "success");
                } else {
                    throw new Error(result.data.message || "Recovery failed");
                }
                
            } catch (error) {
                console.error('‚ùå Recovery failed:', error);
                window.notify(`‚ùå Recovery failed: ${error.message}`, "error");
            }
        };

        
        // Toggle listing dropdown in Neural Vault
        window.toggleListingDropdown = (nftId) => {
            const dropdown = document.getElementById(`listing-dropdown-${nftId}`);
            const icon = document.getElementById(`dropdown-icon-${nftId}`);
            
            if (!dropdown) return;
            
            if (dropdown.classList.contains('hidden')) {
                dropdown.classList.remove('hidden');
                if (icon) icon.style.transform = 'rotate(180deg)';
            } else {
                dropdown.classList.add('hidden');
                if (icon) icon.style.transform = 'rotate(0deg)';
            }
        };

        window.goBackFromCollection = () => {
            const source = state._collectionViewSource || 'market';
            if (source === 'all-collections') {
                window.switchTab('all-collections');
                window.renderAllCollections();
            } else {
                window.switchTab('market');
            }
        };

        window.viewCollection = (colToken) => {
            // Track where user came from for back button
            state._collectionViewSource = state.currentTab || 'market';
            state.viewingCollection = colToken;
            window.switchTab('collection-view');
            
            // Update back button
            const backBtn = document.getElementById('colViewBackBtn');
            if (backBtn) {
                if (state._collectionViewSource === 'all-collections') {
                    backBtn.innerText = '‚Üê All Collections';
                } else {
                    backBtn.innerText = '‚Üê Explorer';
                }
            }
            
            // Debug: log all NFTs and their collectionToken matching
            const normalizedTarget = getNormalizedId(colToken);
            console.log(`üîç viewCollection: Looking for collectionToken matching: "${normalizedTarget}"`);
            console.log(`üîç Total NFTs in state: ${state.nfts.length}`);
            
            // Show all unique collectionTokens for debugging
            const allTokens = [...new Set(state.nfts.map(n => getNormalizedId(n.collectionToken)))];
            console.log(`üîç Unique collectionTokens in state:`, allTokens);
            
            // Check each NFT
            state.nfts.forEach(n => {
                const nToken = getNormalizedId(n.collectionToken);
                if (nToken === normalizedTarget) {
                    console.log(`  ‚úÖ MATCH: ${n.name} (id: ${n.id}, token: ${nToken})`);
                }
            });
            
            const colNfts = state.nfts.filter(n => getNormalizedId(n.collectionToken) === normalizedTarget);
            console.log(`üîç Matched ${colNfts.length} NFTs for this collection`);
            
            // Also check if any NFTs match by collectionId instead
            const colIdMatches = state.nfts.filter(n => n.collectionId && n.collectionId === colToken);
            if (colIdMatches.length > colNfts.length) {
                console.warn(`‚ö†Ô∏è ${colIdMatches.length} NFTs match by collectionId but only ${colNfts.length} match by collectionToken ‚Äî some NFTs may have mismatched collectionToken!`);
                colIdMatches.forEach(n => {
                    if (!colNfts.includes(n)) {
                        console.warn(`  ‚ùå MISSING from token match: ${n.name} (collectionToken: ${n.collectionToken}, expected: ${colToken})`);
                    }
                });
            }
            colNfts.sort((a, b) => {
                if (a.isListed && !b.isListed) return -1;
                if (!a.isListed && b.isListed) return 1;
                if (a.isListed && b.isListed) return (a.listedPrice || 0) - (b.listedPrice || 0);
                return 0;
            });
            
            const base = colNfts[0];
            if (!base) return;
            
            const listedNfts = colNfts.filter(n => n.isListed);
            const ktaListings = listedNfts.filter(n => n.listedCurrency === 'KTA');
            const floorKTA = ktaListings.length > 0 ? Math.min(...ktaListings.map(n => n.listedPrice)) : null;
            const floorDisplay = floorKTA ? `${floorKTA} KTA` : '‚Äî';
            
            const collectionTitle = base.collection || base.collectionTitle || base.collectionName || "Protocol Node";
            const verifiedBadge = base.verified ? '<span class="inline-flex items-center justify-center w-8 h-8 bg-gradient-to-br from-blue-500 to-cyan-500 rounded-full border-2 border-white/20 shadow-lg ml-3" title="Verified Collection"><svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg></span>' : '';
            document.getElementById('colPageTitle').innerHTML = collectionTitle + verifiedBadge;
            document.getElementById('colPageDesc').innerText = base.collectionDesc || "Description encrypted.";
            document.getElementById('colPageCreator').innerText = (base.creator || "---").substring(0, 24) + "...";
            
            // Supply: show items / totalSupply from collection metadata
            const colMeta = state.collections.find(c => 
                getNormalizedId(c.collectionToken) === normalizedTarget || 
                c.collectionId === `collection_${normalizedTarget}` ||
                c.collectionId === colToken
            );
            const totalSupply = colMeta?.totalSupply || colNfts.length;
            document.getElementById('colPageSupply').innerText = `${colNfts.length} / ${totalSupply}`;
            
            const floorEl = document.getElementById('colPageFloor');
            if (floorEl) floorEl.innerText = floorDisplay;
            
            let headerThumb = '';
            // Use universal resolver ‚Äî checks colMeta first (has thumbnail CID), then base NFT data
            if (colMeta) {
                headerThumb = window.resolveCollectionImage(colMeta);
            } else if (base.collectionThumbnailCid) {
                headerThumb = getIPFSUrl(base.collectionThumbnailCid);
            } else if (base.isExternal && (base.image || base.imageUrl)) {
                headerThumb = base.image || base.imageUrl;
            } else if (base.imageCid) {
                const imgPath = window.getNFTImagePath(base);
                headerThumb = (imgPath && (imgPath.startsWith('http://') || imgPath.startsWith('https://'))) ? imgPath : imgPath ? getIPFSUrl(imgPath) : '';
            }
            if (!headerThumb) {
                headerThumb = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23000' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-size='20'%3ECLASSIFIED%3C/text%3E%3C/svg%3E`;
            }
            document.getElementById('colPageImage').innerHTML = `<img src="${headerThumb}" class="sharp-img w-full h-full object-cover shadow-2xl border border-white/10">`;
            
            const gridHTML = colNfts.map(n => {
                if (!n.collectionId) n.collectionId = state.viewingCollection;
                let rarestPercent = 100;
                const collectionData = state.collections.find(c => c.collectionId === n.collectionId || (n.collectionToken && getNormalizedId(c.collectionToken) === getNormalizedId(n.collectionToken)));
                if (n.attributes && n.attributes.length > 0 && collectionData) {
                    n.attributes.forEach(trait => {
                        const rarity = window.calculateTraitRarity(trait, n.collectionId, collectionData.mintedCount);
                        if (rarity < rarestPercent) rarestPercent = rarity;
                    });
                }
                
                const rarityTier = window.getRarityTier(rarestPercent);
                
                // Use toggle mode for marketplace cards too
                const traitsHTML = window.renderNFTTraits(n, 'toggle', false);
                
                const isListed = n.isListed || false;
                const buyButton = isListed ? `
                    <div class="flex justify-between items-center mt-4">
                        <span class="fira text-[9px] text-cyan-400 font-bold">${n.listedPrice} ${n.listedCurrency}</span>
                        <button onclick="window.buyNFT('${n.id}')" class="btn-primary !py-1 px-4 !text-[8px]">Buy</button>
                    </div>
                ` : `
                    <div class="mt-4 space-y-2">
                        <div class="text-center text-[8px] text-gray-500 fira">Not Listed</div>
                    </div>
                `;
                
                const imgCid = window.getNFTImagePath(n);
                const imgUrl = (imgCid && (imgCid.startsWith('http://') || imgCid.startsWith('https://'))) ? imgCid : imgCid ? getIPFSUrl(imgCid) : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E';

                return `
                <div class="glass-card p-5 flex flex-col group border-white/5 transition-all hover:border-cyan-500/20 ${rarityTier.glow}">
                    <img src="${imgUrl}" 
                         onerror="if(this.src.includes('ipfs')){handleIPFSImageError(this,'${imgCid}')}else{this.onerror=null}" 
                         class="sharp-img rounded-lg aspect-square object-cover mb-4 shadow-xl">
                    <h4 class="orbitron text-[9px] font-black text-white truncate uppercase">${n.name}</h4>
                    ${traitsHTML}
                    ${buyButton}
                </div>
                `;
            }).join('');
            
            console.log(`üìê viewCollection: Rendering ${colNfts.length} NFT cards to colPageGrid`);
            document.getElementById('colPageGrid').innerHTML = gridHTML;
            
            // Post-render: proactively load IPFS images in collection page
            setTimeout(() => {
                document.querySelectorAll('#colPageGrid img[src*="/ipfs/"]').forEach(img => {
                    if (img.complete && img.naturalWidth > 0) return;
                    const src = img.getAttribute('src');
                    if (src && src.includes('/ipfs/')) {
                        const cidPath = src.split('/ipfs/')[1];
                        if (cidPath) window.loadIPFSImage(img, cidPath);
                    }
                });
            }, 500);
            
            // Initialize collection chart with slight delay to ensure canvas is ready
            setTimeout(() => {
                window.updateCollectionDepth(colToken);
            }, 100);
            
            // Load and render collection comments
            const commentTarget = 'collection_' + colToken;
            window.loadComments(commentTarget).then(() => {
                window.renderCollectionComments(commentTarget);
            });
            
            // Build trait filters
            window.buildTraitFilters(colNfts);
        };

        // Toggle filters dropdown
        window.toggleFiltersDropdown = () => {
            const dropdown = document.getElementById('filtersDropdown');
            if (dropdown) {
                dropdown.classList.toggle('hidden');
            }
        };

        // Build trait filter options
        window.buildTraitFilters = (nfts) => {
            const filtersContainer = document.getElementById('traitFilters');
            if (!filtersContainer) return;
            
            // Collect all unique traits
            const traitsByType = {};
            nfts.forEach(nft => {
                if (nft.attributes && Array.isArray(nft.attributes)) {
                    nft.attributes.forEach(trait => {
                        if (!traitsByType[trait.trait_type]) {
                            traitsByType[trait.trait_type] = new Set();
                        }
                        traitsByType[trait.trait_type].add(trait.value);
                    });
                }
            });
            
            // Build filter UI
            filtersContainer.innerHTML = Object.entries(traitsByType).map(([type, values]) => {
                const valuesArray = Array.from(values).sort();
                return `
                    <div class="filter-group">
                        <div class="text-xs orbitron text-gray-400 uppercase font-bold mb-2">${type}</div>
                        <div class="space-y-1">
                            ${valuesArray.map(value => `
                                <label class="flex items-center gap-2 text-xs fira text-gray-300 hover:text-cyan-400 cursor-pointer">
                                    <input 
                                        type="checkbox" 
                                        class="trait-filter-checkbox"
                                        data-trait-type="${type}" 
                                        data-trait-value="${value}"
                                        onchange="window.applyFilters()"
                                    >
                                    <span>${value}</span>
                                </label>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        };

        // Apply filters
        window.applyFilters = () => {
            const checkboxes = document.querySelectorAll('.trait-filter-checkbox:checked');
            const filters = {};
            
            checkboxes.forEach(cb => {
                const type = cb.dataset.traitType;
                const value = cb.dataset.traitValue;
                if (!filters[type]) filters[type] = [];
                filters[type].push(value);
            });
            
            state.collectionFilters = filters;
            
            // Update filter count badge
            const filterCount = Object.keys(filters).length;
            const badge = document.getElementById('filterCount');
            if (badge) {
                if (filterCount > 0) {
                    badge.textContent = filterCount;
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            }
            
            // Re-render collection with filters
            window.renderFilteredCollection();
        };

        // Clear all filters
        window.clearFilters = () => {
            state.collectionFilters = {};
            document.querySelectorAll('.trait-filter-checkbox').forEach(cb => {
                cb.checked = false;
            });
            document.getElementById('filterCount')?.classList.add('hidden');
            window.renderFilteredCollection();
        };

        // Set sort mode
        window.setSortMode = (mode) => {
            state.sortMode = mode;
            
            // Update button states
            document.querySelectorAll('.sort-btn').forEach(btn => {
                btn.classList.remove('active', 'border-cyan-500/30', 'text-cyan-400', 'bg-cyan-500/5');
                btn.classList.add('border-white/10', 'text-gray-400');
            });
            
            const activeBtn = document.getElementById(`sort-${mode}`);
            if (activeBtn) {
                activeBtn.classList.add('active', 'border-cyan-500/30', 'text-cyan-400', 'bg-cyan-500/5');
                activeBtn.classList.remove('border-white/10', 'text-gray-400');
            }
            
            window.renderFilteredCollection();
        };

        // Render collection with filters and sorting
        window.renderFilteredCollection = () => {
            if (!state.viewingCollection) return;
            
            const colToken = state.viewingCollection;
            let colNfts = state.nfts.filter(n => getNormalizedId(n.collectionToken) === getNormalizedId(colToken));
            
            console.log(`üîÑ renderFilteredCollection: ${colNfts.length} NFTs for ${colToken.substring(0, 30)}...`);
            
            // Update supply count
            const supplyEl = document.getElementById('colPageSupply');
            if (supplyEl) {
                const colMeta = state.collections.find(c => 
                    getNormalizedId(c.collectionToken) === getNormalizedId(colToken) || 
                    c.collectionId === `collection_${getNormalizedId(colToken)}` ||
                    c.collectionId === colToken
                );
                const totalSupply = colMeta?.totalSupply || colNfts.length;
                supplyEl.innerText = `${colNfts.length} / ${totalSupply}`;
            }
            
            // Apply trait filters
            if (Object.keys(state.collectionFilters).length > 0) {
                colNfts = colNfts.filter(nft => {
                    if (!nft.attributes) return false;
                    
                    // NFT must match ALL filter groups (AND logic)
                    return Object.entries(state.collectionFilters).every(([type, values]) => {
                        // Within a group, match ANY value (OR logic)
                        return nft.attributes.some(attr => 
                            attr.trait_type === type && values.includes(attr.value)
                        );
                    });
                });
            }
            
            // Apply sorting
            if (state.sortMode === 'price') {
                colNfts.sort((a, b) => {
                    if (a.isListed && !b.isListed) return -1;
                    if (!a.isListed && b.isListed) return 1;
                    if (a.isListed && b.isListed) return (a.listedPrice || 0) - (b.listedPrice || 0);
                    return 0;
                });
            } else if (state.sortMode === 'rarity') {
                colNfts.sort((a, b) => {
                    const rarestA = window.getLowestTraitRarity(a);
                    const rarestB = window.getLowestTraitRarity(b);
                    return rarestA - rarestB; // Lower % = more rare
                });
            } else if (state.sortMode === 'traits') {
                colNfts.sort((a, b) => {
                    const countA = a.attributes?.length || 0;
                    const countB = b.attributes?.length || 0;
                    return countB - countA; // More traits first
                });
            }
            
            const filteredGridHTML = colNfts.map(n => {
                let rarestPercent = 100;
                if (n.attributes && n.attributes.length > 0 && n.collectionId) {
                    const collectionData = state.collections.find(c => c.collectionId === n.collectionId);
                    if (collectionData) {
                        n.attributes.forEach(trait => {
                            const rarity = window.calculateTraitRarity(trait, n.collectionId, collectionData.mintedCount);
                            if (rarity < rarestPercent) rarestPercent = rarity;
                        });
                    }
                }
                
                const rarityTier = window.getRarityTier(rarestPercent);
                const traitsHTML = window.renderNFTTraits(n, 'toggle', false);
                
                const isListed = n.isListed || false;
                const buyButton = isListed ? `
                    <div class="flex justify-between items-center mt-4">
                        <span class="fira text-[9px] text-cyan-400 font-bold">${n.listedPrice} ${n.listedCurrency}</span>
                        <button onclick="window.buyNFT('${n.id}')" class="btn-primary !py-1 px-4 !text-[8px]">Buy</button>
                    </div>
                ` : `
                    <div class="mt-4 space-y-2">
                        <div class="text-center text-[8px] text-gray-500 fira">Not Listed</div>
                    </div>
                `;
                
                const imgCid = window.getNFTImagePath(n);
                const imgUrl = (imgCid && (imgCid.startsWith('http://') || imgCid.startsWith('https://'))) ? imgCid : imgCid ? getIPFSUrl(imgCid) : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E';

                return `
                <div class="glass-card p-5 flex flex-col group border-white/5 transition-all hover:border-cyan-500/20 ${rarityTier.glow}">
                    <img src="${imgUrl}" 
                         onerror="if(this.src.includes('ipfs')){handleIPFSImageError(this,'${imgCid}')}else{this.onerror=null}" 
                         class="sharp-img rounded-lg aspect-square object-cover mb-4 shadow-xl">
                    <h4 class="orbitron text-[9px] font-black text-white truncate uppercase">${n.name}</h4>
                    ${traitsHTML}
                    ${buyButton}
                </div>
                `;
            }).join('');
            
            console.log(`üìê renderFilteredCollection: Writing ${colNfts.length} cards to grid (filters: ${Object.keys(state.collectionFilters).length}, sort: ${state.sortMode})`);
            document.getElementById('colPageGrid').innerHTML = filteredGridHTML;
            
            // Post-render: proactively load IPFS images
            setTimeout(() => {
                document.querySelectorAll('#colPageGrid img[src*="/ipfs/"]').forEach(img => {
                    if (img.complete && img.naturalWidth > 0) return;
                    const src = img.getAttribute('src');
                    if (src && src.includes('/ipfs/')) {
                        const cidPath = src.split('/ipfs/')[1];
                        if (cidPath) window.loadIPFSImage(img, cidPath);
                    }
                });
            }, 500);
        };

        // Get lowest trait rarity for an NFT
        window.getLowestTraitRarity = (nft) => {
            if (!nft.attributes || nft.attributes.length === 0) return 100;
            const lookupId = nft.collectionId || state.viewingCollection;
            if (!lookupId) return 100;
            
            const collectionData = state.collections.find(c => c.collectionId === lookupId || (nft.collectionToken && getNormalizedId(c.collectionToken) === getNormalizedId(nft.collectionToken)));
            if (!collectionData) return 100;
            
            let lowestRarity = 100;
            nft.attributes.forEach(trait => {
                const rarity = window.calculateTraitRarity(trait, lookupId, collectionData.mintedCount);
                if (rarity < lowestRarity) lowestRarity = rarity;
            });
            
            return lowestRarity;
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIX #4: INLINE LISTING SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        window.listNFTForSale = async (nftId) => {
            const nft = state.nfts.find(n => n.id === nftId);
            if (!nft) return window.notify("NFT not found", "error");
            
            if (!nft.attributes || nft.attributes.length === 0) await window.fetchNFTMetadata(nft);
            
            state.listingNFT = nft;
            
            const listingImgPath = window.getNFTImagePath(nft);
            const preview = document.getElementById('listingNFTPreview');
            
            // FIX: Handle external NFTs (like PFP) that already have full URLs
            let imageUrl;
            if (nft.isExternal && listingImgPath && (listingImgPath.startsWith('http://') || listingImgPath.startsWith('https://'))) {
                imageUrl = listingImgPath; // Already a full URL
            } else if (listingImgPath) {
                imageUrl = getIPFSUrl(listingImgPath);
            } else {
                imageUrl = 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E';
            }
            
            if (preview) preview.innerHTML = `<img src="${imageUrl}" class="sharp-img w-full h-full object-cover rounded-xl">`;
            
            const nameEl = document.getElementById('listingNFTName');
            if (nameEl) nameEl.innerText = nft.name || "Unit";
            
            const traitsEl = document.getElementById('listingNFTTraits');
            if (traitsEl) {
                // Show all traits expanded in listing modal
                traitsEl.innerHTML = window.renderNFTTraits(nft, 'all');
            }
            
            document.getElementById('listingPriceInput').value = '';
            document.querySelector('input[name="listingCurrency"][value="KTA"]').checked = true;
            window.updateFeeBreakdown();
            
            document.getElementById('listingModal').classList.remove('hidden');
        };

        window.closeListingModal = () => {
            document.getElementById('listingModal').classList.add('hidden');
            state.listingNFT = null;
        };

        window.updateFeeBreakdown = () => {
            const priceInput = document.getElementById('listingPriceInput');
            const price = parseFloat(priceInput?.value || 0);
            
            if (isNaN(price) || price <= 0) {
                document.getElementById('sellerPayout').innerText = '0.00';
                document.getElementById('creatorRoyalty').innerText = '0.00';
                document.getElementById('marketplaceFee').innerText = '0.00';
                const royaltyPercentEl = document.getElementById('royaltyPercent');
                if (royaltyPercentEl) royaltyPercentEl.innerText = '5.0';
                return;
            }
            
            const currency = document.querySelector('input[name="listingCurrency"]:checked')?.value || 'KTA';
            
            // Get actual collection royalty from the NFT being listed
            const nft = state.listingNFT;
            const collection = state.collections.find(c => 
                c.collectionId === nft?.collectionId || 
                c.collectionToken === nft?.collectionToken
            );
            const royaltyPercent = collection?.creatorRoyaltyPercent || SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
            const marketplaceFeePercent = SECONDARY_SALE_MARKETPLACE_PERCENT;
            const sellerPercent = 1 - royaltyPercent - marketplaceFeePercent;
            
            const sellerAmount = price * sellerPercent;
            const royaltyAmount = price * royaltyPercent;
            const feeAmount = price * marketplaceFeePercent;
            
            document.getElementById('sellerPayout').innerText = `${sellerAmount.toFixed(2)} ${currency}`;
            document.getElementById('creatorRoyalty').innerText = `${royaltyAmount.toFixed(2)} ${currency}`;
            document.getElementById('marketplaceFee').innerText = `${feeAmount.toFixed(2)} ${currency}`;
            
            // Update royalty percentage display if element exists
            const royaltyPercentEl = document.getElementById('royaltyPercent');
            if (royaltyPercentEl) {
                royaltyPercentEl.innerText = `${(royaltyPercent * 100).toFixed(1)}`;
            }
        };

        window.confirmListing = async () => {
            if (!state.listingNFT) return window.notify("No NFT selected", "error");
            if (!window.acquireTxLock(`list_${state.listingNFT.id}`)) return window.notify("Listing already in progress...", "warning");
            
            const price = parseFloat(document.getElementById('listingPriceInput')?.value || 0);
            if (isNaN(price) || price <= 0) return window.notify("Invalid price", "error");
            
            const currency = document.querySelector('input[name="listingCurrency"]:checked')?.value || "KTA";
            
            try {
                window.notify("Creating listing...", "success");
                
                // ESCROW DEPOSIT: Send NFT to escrow wallet so it can be released to buyer on purchase
                // NOTE: User signs this transaction (sending their NFT to escrow address)
                // No escrow seed needed ‚Äî just the public address
                let escrowSuccess = false;
                if (ESCROW_ADDRESS && state.listingNFT.tokenId) {
                    try {
                        window.notify("Transferring NFT to escrow for secure listing...", "success");
                        
                        if (typeof state.keetaClient.init === 'function') {
                            await state.keetaClient.init();
                        }
                        
                        const listBuilder = state.keetaClient.initBuilder();
                        listBuilder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                        listBuilder.send(
                            KeetaNet.lib.Account.fromPublicKeyString(ESCROW_ADDRESS), // To escrow (public address)
                            1n, // 1 NFT token
                            KeetaNet.lib.Account.fromPublicKeyString(state.listingNFT.tokenId) // The NFT
                        );
                        
                        await state.keetaClient.computeBuilderBlocks(listBuilder);
                        const escrowTx = await state.keetaClient.publishBuilder(listBuilder);
                        
                        console.log("‚úÖ NFT sent to escrow for listing:", escrowTx);
                        escrowSuccess = true;
                    } catch (escrowError) {
                        console.error("‚ö†Ô∏è Escrow deposit failed:", escrowError.message);
                        // Continue with listing anyway ‚Äî trust-based fallback
                        window.notify("‚ö†Ô∏è Escrow deposit failed, listing as trust-based sale", "info");
                    }
                }
                
                // Update Firebase with listing info + escrow status
                await updateDoc(doc(db, 'nfts', state.listingNFT.id), {
                    isListed: true,
                    listedPrice: price,
                    listedCurrency: currency,
                    listedAt: new Date().toISOString(),
                    inEscrow: escrowSuccess // Track whether NFT is actually in escrow
                });
                
                // Create transaction record for listing
                const transactionId = `tx_listing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                // FIX: Properly get collection name for all NFTs including PFP
                const nftCollection = state.collections.find(c => 
                    c.collectionId === state.listingNFT.collectionId ||
                    c.collectionToken === state.listingNFT.collectionToken
                );
                const collectionName = nftCollection?.collectionTitle || state.listingNFT.collectionTitle || state.listingNFT.collection || 'Unknown Collection';
                
                const transactionData = {
                    id: transactionId,
                    type: 'listing',
                    nftId: state.listingNFT.id,
                    nftName: state.listingNFT.name,
                    nftImage: state.listingNFT.imagePath || state.listingNFT.imageCid,
                    collectionId: state.listingNFT.collectionId || state.listingNFT.collection,
                    collection: collectionName,
                    price: price,
                    currency: currency,
                    seller: state.address,
                    wallet: state.address, // For seller's transaction history
                    timestamp: new Date().toISOString(),
                    txHash: `listing_${state.listingNFT.id}`,
                    status: 'listed',
                    inEscrow: escrowSuccess
                };
                
                await setDoc(
                    doc(db, 'transactions', transactionId),
                    transactionData
                );
                
                console.log("‚úÖ Transaction record created for listing (escrow:", escrowSuccess, ")");
                
                window.notify(`‚úÖ Listed for ${price} ${currency}!${escrowSuccess ? ' (Secured in escrow)' : ''}`, "success");
                
                // Update local state immediately (BEFORE closing modal which clears state.listingNFT)
                const localNft = state.nfts.find(n => n.id === state.listingNFT.id);
                if (localNft) {
                    localNft.isListed = true;
                    localNft.listedPrice = price;
                    localNft.listedCurrency = currency;
                    localNft.inEscrow = escrowSuccess;
                }
                
                window.closeListingModal();
                
                await window.renderCollection();
                await window.renderMarketplace();
                
            } catch (error) {
                console.error("Listing error:", error);
                window.notify(`‚ùå Listing failed: ${error.message}`, "error");
            } finally {
                if (state.listingNFT) window.releaseTxLock(`list_${state.listingNFT.id}`);
            }
        };

        window.editNFTPrice = async (nftId) => {
            const nft = state.nfts.find(n => n.id === nftId);
            if (!nft) return;
            
            // Open the listing modal with current values pre-filled
            if (!nft.attributes || nft.attributes.length === 0) await window.fetchNFTMetadata(nft);
            
            state.listingNFT = nft;
            
            const editImgPath = window.getNFTImagePath(nft);
            const preview = document.getElementById('listingNFTPreview');
            if (preview) preview.innerHTML = `<img src="${editImgPath ? getIPFSUrl(editImgPath) : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E'}" class="sharp-img w-full h-full object-cover rounded-xl">`;
            
            const nameEl = document.getElementById('listingNFTName');
            if (nameEl) nameEl.innerText = nft.name || "Unit";
            
            const traitsEl = document.getElementById('listingNFTTraits');
            if (traitsEl) {
                traitsEl.innerHTML = window.renderNFTTraits(nft, 'all');
            }
            
            // Pre-fill with current listing values
            document.getElementById('listingPriceInput').value = nft.listedPrice || '';
            
            // Set currency
            const currencyRadio = document.querySelector(`input[name="listingCurrency"][value="${nft.listedCurrency || 'KTA'}"]`);
            if (currencyRadio) currencyRadio.checked = true;
            
            window.updateFeeBreakdown();
            
            // Show modal
            document.getElementById('listingModal').classList.remove('hidden');
        };

        window.cancelListing = async (nftId) => {
            if (!window.acquireTxLock(`cancel_${nftId}`)) return window.notify("Cancel already in progress...", "warning");
            try {
                const nft = state.nfts.find(n => n.id === nftId);
                if (!nft) return window.notify("NFT not found", "error");
                
                // Verify caller owns this NFT
                if ((nft.owner || '').toLowerCase() !== (state.address || '').toLowerCase()) {
                    return window.notify("You can only cancel your own listings", "error");
                }
                
                window.notify("Canceling listing...", "success");
                
                // If NFT was sent to escrow, return it via Cloud Function (SECURE)
                if (nft.inEscrow) {
                    try {
                        window.notify("Returning NFT from escrow...", "success");
                        
                        console.log("üîí Calling Cloud Function to return NFT from escrow...");
                        const result = await window.returnFromEscrow({
                            nftId: nftId,
                            sellerAddress: state.address
                        });
                        
                        if (result.data && result.data.success) {
                            console.log("‚úÖ NFT returned from escrow via Cloud Function:", result.data.txHash);
                        } else {
                            console.warn("‚ö†Ô∏è Escrow return response:", result.data);
                        }
                    } catch (escrowError) {
                        console.error("‚ö†Ô∏è Escrow return failed:", escrowError.message);
                        window.notify("‚ö†Ô∏è Could not return NFT from escrow ‚Äî contact support", "error");
                    }
                }
                
                await updateDoc(doc(db, 'nfts', nftId), {
                    isListed: false,
                    listedPrice: null,
                    listedCurrency: null,
                    inEscrow: false,
                    listedAt: null,
                    cancelledAt: new Date().toISOString()
                });
                
                // Record cancellation transaction
                try {
                    // FIX: Properly get collection name for all NFTs including PFP
                    const nftCollection = state.collections.find(c => 
                        c.collectionId === nft.collectionId ||
                        c.collectionToken === nft.collectionToken
                    );
                    const collectionName = nftCollection?.collectionTitle || nft.collectionTitle || nft.collection || 'Unknown Collection';
                    
                    await window.recordTransaction({
                        type: 'cancellation',
                        nftId,
                        nftName: nft.name,
                        collection: collectionName,
                        collectionId: nft.collectionId,
                        price: 0,
                        currency: 'KTA',
                        counterParty: null,
                        txHash: null
                    });
                } catch (e) { console.warn("Could not record cancellation:", e); }
                
                // Update local state immediately
                const nftIndex = state.nfts.findIndex(n => n.id === nftId);
                if (nftIndex !== -1) {
                    state.nfts[nftIndex].isListed = false;
                    state.nfts[nftIndex].listedPrice = null;
                    state.nfts[nftIndex].listedCurrency = null;
                    state.nfts[nftIndex].inEscrow = false;
                }
                
                window.notify("‚úÖ Listing cancelled successfully", "success");
                
                await window.renderCollection();
                await window.renderMarketplace();
                window.updateMarketChart();
                
            } catch (error) {
                console.error("Cancel error:", error);
                window.notify("‚ùå Cancel failed: " + error.message, "error");
            } finally {
                window.releaseTxLock(`cancel_${nftId}`);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ENHANCED CHART SYSTEM WITH REAL-TIME UPDATES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Populate collection selector
        window.populateChartSelector = () => {
            const selector = document.getElementById('chartCollectionSelector');
            if (!selector) return;
            
            const collections = {};
            state.nfts.forEach(n => {
                const k = getNormalizedId(n.collectionToken);
                if (!collections[k]) {
                    collections[k] = { title: n.collection || 'Unknown', token: k };
                }
            });
            
            selector.innerHTML = '<option value="all">Overall Marketplace</option>';
            Object.values(collections).forEach(col => {
                selector.innerHTML += `<option value="${col.token}">${col.title}</option>`;
            });
            
            selector.value = state.selectedChartCollection;
        };

        // Set timeframe for main chart
        window.setChartTimeframe = (timeframe) => {
            state.chartTimeframe = timeframe;
            
            // Update button states in main market view
            const marketTab = document.querySelector('#tab-market');
            if (marketTab) {
                marketTab.querySelectorAll('.chart-timeframe-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.timeframe === timeframe) {
                        btn.classList.add('active');
                    }
                });
            }
            
            console.log("üìä Chart timeframe changed to:", timeframe);
            
            // Force regenerate chart with new timeframe
            window.updateMarketChart();
        };

        // Set currency filter for chart
        window.setChartCurrency = (currency) => {
            state.chartCurrency = currency; // 'KTA', 'PUNKS', or 'ALL'
            
            // Update button active states
            ['KTA', 'PUNKS', 'ALL'].forEach(c => {
                const btn = document.getElementById(`chartCurrency${c}`);
                if (btn) {
                    if (c === currency) {
                        btn.className = 'px-3 py-1.5 text-[10px] orbitron font-black transition-all ' + 
                            (c === 'KTA' ? 'bg-cyan-500/30 text-cyan-400 border-r border-white/10' : 
                             c === 'PUNKS' ? 'bg-purple-500/30 text-purple-400 border-r border-white/10' : 
                             'bg-orange-500/30 text-orange-400');
                    } else {
                        btn.className = 'px-3 py-1.5 text-[10px] orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white ' +
                            (c !== 'ALL' ? 'border-r border-white/10' : '');
                    }
                }
            });
            
            console.log("üìä Chart currency changed to:", currency);
            window.updateMarketChart();
        };

        // Set timeframe for collection chart
        window.setCollectionChartTimeframe = (timeframe) => {
            state.collectionChartTimeframe = timeframe;
            
            // Update button states in collection view
            const collectionTab = document.querySelector('#tab-collection-view');
            if (collectionTab) {
                collectionTab.querySelectorAll('.chart-timeframe-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.timeframe === timeframe) {
                        btn.classList.add('active');
                    }
                });
            }
            
            console.log("üìä Collection chart timeframe changed to:", timeframe);
            
            // Force regenerate collection chart
            if (state.viewingCollection) {
                window.updateCollectionDepth(state.viewingCollection);
            }
        };

        // Update main market chart - FORCE REFRESH with new data
        window.updateMarketChart = async () => {
            const selector = document.getElementById('chartCollectionSelector');
            if (selector) {
                state.selectedChartCollection = selector.value;
            }
            
            console.log(`üîÑ Updating chart for: ${state.selectedChartCollection} | Timeframe: ${state.chartTimeframe}`);
            
            // Force destroy and recreate chart
            if (state.pulseChart) {
                state.pulseChart.destroy();
                state.pulseChart = null;
            }
            
            await window.initFloorPulseChart();
        };

        // Generate sophisticated market data based on actual sales
        window.getMarketPulseData = async () => {
            try {
                const selectedCollection = state.selectedChartCollection;
                let relevantNFTs = state.nfts || [];
                
                // Filter by collection if not "all"
                if (selectedCollection !== 'all') {
                    relevantNFTs = relevantNFTs.filter(n => 
                        getNormalizedId(n.collectionToken) === selectedCollection
                    );
                }
                
                // Get REAL transaction data from Firebase
                const txRef = collection(db, 'transactions');
                let txQuery;
                
                if (selectedCollection !== 'all') {
                    // Match the collectionId format: collection_<tokenId>
                    const formattedColId = `collection_${selectedCollection}`;
                    console.log(`üîç Filtering for collectionId: ${formattedColId}`);
                    txQuery = query(txRef, where('collectionId', '==', formattedColId));
                } else {
                    txQuery = txRef;
                }
                
                const txSnapshot = await getDocs(txQuery);
                const transactions = txSnapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                console.log(`üìä Found ${transactions.length} transactions for chart`);
                
                // Filter transactions by currency setting
                const chartCurrency = state.chartCurrency || 'KTA';
                
                // Separate KTA and PUNKS transactions
                const allValidTxs = transactions.filter(tx => 
                    (tx.type === 'sale' || tx.type === 'mint' || tx.type === 'purchase') && tx.price > 0 && tx.timestamp
                );
                const ktaOnlyTxs = allValidTxs.filter(tx => !tx.currency || tx.currency === 'KTA');
                const punksOnlyTxs = allValidTxs.filter(tx => tx.currency === 'PUNKS');
                
                // Select which transactions to chart based on currency filter
                let ktaTransactions;
                if (chartCurrency === 'PUNKS') {
                    ktaTransactions = punksOnlyTxs;
                } else if (chartCurrency === 'ALL') {
                    // ALL mode: show both but chart KTA line separately
                    // Volume will combine both currencies
                    ktaTransactions = allValidTxs;
                } else {
                    // KTA mode (default)
                    ktaTransactions = ktaOnlyTxs;
                }
                
                console.log(`üìä ${ktaTransactions.length} ${chartCurrency} transactions for charting (KTA: ${ktaOnlyTxs.length}, PUNKS: ${punksOnlyTxs.length})`);
                const recentTxs = ktaTransactions.slice(-5);
                console.log("üìä Recent transactions:", recentTxs.map(tx => `${tx.type}:${tx.price}${tx.currency || 'KTA'}@${new Date(tx.timestamp).toLocaleTimeString()}`));
                
                const allPrices = ktaTransactions.map(tx => tx.price);
                const uniquePrices = [...new Set(allPrices)];
                const currLabel = chartCurrency === 'PUNKS' ? 'PUNKS' : chartCurrency === 'ALL' ? 'mixed' : 'KTA';
                console.log("üìä Transaction price range:");
                console.log("   - Total transactions:", allPrices.length);
                console.log("   - Min price:", Math.min(...allPrices), currLabel);
                console.log("   - Max price:", Math.max(...allPrices), currLabel);
                console.log("   - Unique prices:", uniquePrices.length);
                console.log("   - All unique prices:", uniquePrices.sort((a,b) => a-b));
                
                if (uniquePrices.length === 1) {
                    console.warn("‚ö†Ô∏è CHART WILL BE FLAT: All sales are at the same price (" + uniquePrices[0] + " " + currLabel + ")");
                    console.warn("   To see price movement, make sales at different prices");
                }
                
                // Also check NFT soldAt data
                const soldNFTs = relevantNFTs.filter(n => n.soldAt && n.soldPrice && (n.soldCurrency === 'KTA' || n.soldCurrency === 'PUNKS'));
                console.log(`üìä ${soldNFTs.length} NFTs with soldAt data`);
                
                // Get current listings for floor price - FILTER BY SELECTED CURRENCY
                let listedNFTs;
                if (chartCurrency === 'PUNKS') {
                    listedNFTs = relevantNFTs.filter(n => n.isListed && n.listedCurrency === 'PUNKS');
                } else if (chartCurrency === 'KTA') {
                    listedNFTs = relevantNFTs.filter(n => n.isListed && (!n.listedCurrency || n.listedCurrency === 'KTA'));
                } else {
                    // ALL: show all listings but separate for floor calc
                    listedNFTs = relevantNFTs.filter(n => n.isListed);
                }
                
                // Calculate floor/ceiling/avg from LISTINGS first, fall back to TRANSACTION history
                // For ALL mode, calculate separate floors for each currency
                let currentFloor, ceiling, avgPrice;
                
                if (chartCurrency === 'ALL') {
                    // ALL mode: compute KTA and PUNKS floors separately
                    const ktaListings = listedNFTs.filter(n => !n.listedCurrency || n.listedCurrency === 'KTA').map(n => n.listedPrice).sort((a,b) => a-b);
                    const punksListings = listedNFTs.filter(n => n.listedCurrency === 'PUNKS').map(n => n.listedPrice).sort((a,b) => a-b);
                    const ktaTxPrices = ktaOnlyTxs.map(tx => tx.price).sort((a,b) => a-b);
                    const punksTxPrices = punksOnlyTxs.map(tx => tx.price).sort((a,b) => a-b);
                    
                    const ktaFloor = ktaListings[0] || ktaTxPrices[0] || 0;
                    const punksFloor = punksListings[0] || punksTxPrices[0] || 0;
                    
                    // Display KTA floor as primary (most common base currency)
                    currentFloor = ktaFloor || punksFloor;
                    ceiling = Math.max(
                        ktaListings[ktaListings.length - 1] || 0,
                        punksListings[punksListings.length - 1] || 0,
                        ktaTxPrices[ktaTxPrices.length - 1] || 0,
                        punksTxPrices[punksTxPrices.length - 1] || 0
                    );
                    
                    // Store dual floors for display
                    state._chartDualFloors = { ktaFloor, punksFloor };
                    
                    const txPrices = allValidTxs.map(tx => tx.price);
                    avgPrice = txPrices.length > 0 ? txPrices.reduce((a,b) => a+b, 0) / txPrices.length : 0;
                } else {
                    const listingPrices = listedNFTs.map(n => n.listedPrice).sort((a, b) => a - b);
                    const txPrices = ktaTransactions.map(tx => tx.price).sort((a, b) => a - b);
                    const activePrices = listingPrices.length > 0 ? listingPrices : txPrices;
                    
                    currentFloor = activePrices.length > 0 ? activePrices[0] : 0;
                    ceiling = activePrices.length > 0 ? activePrices[activePrices.length - 1] : 0;
                    avgPrice = txPrices.length > 0 
                        ? txPrices.reduce((a, b) => a + b, 0) / txPrices.length 
                        : (listingPrices.length > 0 ? listingPrices.reduce((a, b) => a + b, 0) / listingPrices.length : 0);
                    
                    state._chartDualFloors = null;
                }
                
                // Generate time series data based on timeframe
                const now = Date.now();
                let dataPoints = [];
                let intervals = 24;
                let intervalMs = 3600000;
                
                switch (state.chartTimeframe) {
                    case '1h':
                        intervals = 12;
                        intervalMs = 300000; // 5 min
                        break;
                    case '24h':
                        intervals = 24;
                        intervalMs = 3600000; // 1 hour
                        break;
                    case '7d':
                        intervals = 28;
                        intervalMs = 6 * 3600000; // 6 hours
                        break;
                    case '30d':
                        intervals = 30;
                        intervalMs = 24 * 3600000; // 1 day
                        break;
                    case 'all':
                        // Dynamic: span from first transaction to now
                        if (ktaTransactions.length > 0) {
                            const timestamps = ktaTransactions.map(tx => new Date(tx.timestamp).getTime());
                            const earliest = Math.min(...timestamps);
                            const totalSpan = now - earliest;
                            intervals = Math.min(60, Math.max(10, Math.ceil(totalSpan / (24 * 3600000))));
                            intervalMs = Math.max(3600000, Math.floor(totalSpan / intervals));
                        } else {
                            intervals = 30;
                            intervalMs = 24 * 3600000;
                        }
                        break;
                }
                
                // Build REAL data points from transactions
                // For ALL mode, use KTA txs for price line (can't mix currencies on one axis)
                // Volume will combine both currencies
                const chartLineTxs = chartCurrency === 'ALL' ? 
                    (ktaOnlyTxs.length > 0 ? ktaOnlyTxs : punksOnlyTxs) : ktaTransactions;
                const sortedAllTxs = [...chartLineTxs].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                let lastKnownPrice = sortedAllTxs.length > 0 ? sortedAllTxs[0].price : (currentFloor || 0);
                
                for (let i = intervals; i >= 0; i--) {
                    const timestamp = new Date(now - (i * intervalMs));
                    const intervalStart = timestamp.getTime();
                    const intervalEnd = intervalStart + intervalMs;
                    
                    // Find transactions in this time interval
                    // Price line: use chartLineTxs (currency-specific) to avoid mixing KTA+PUNKS
                    const intervalPriceTxs = chartLineTxs.filter(tx => {
                        const txTime = new Date(tx.timestamp).getTime();
                        return txTime >= intervalStart && txTime < intervalEnd;
                    });
                    // Volume: use all matching txs for the selected filter
                    const intervalVolTxs = ktaTransactions.filter(tx => {
                        const txTime = new Date(tx.timestamp).getTime();
                        return txTime >= intervalStart && txTime < intervalEnd;
                    });
                    
                    // Calculate average price for this interval (currency-specific)
                    let avgIntervalPrice = lastKnownPrice; // Carry forward last price
                    if (intervalPriceTxs.length > 0) {
                        const sum = intervalPriceTxs.reduce((acc, tx) => acc + tx.price, 0);
                        avgIntervalPrice = sum / intervalPriceTxs.length;
                        lastKnownPrice = avgIntervalPrice; // Update last known price
                    }
                    
                    // Calculate volume
                    const volume = intervalVolTxs.reduce((acc, tx) => acc + tx.price, 0);
                    
                    dataPoints.push({
                        timestamp: window.formatChartLabel(timestamp, state.chartTimeframe),
                        fullTimestamp: timestamp,
                        floorKTA: avgIntervalPrice,
                        volume: volume,
                        sales: intervalVolTxs.length
                    });
                }
                
                // Calculate price change from the CHART LINE (first vs last visible data point)
                // This matches what the user sees on the chart
                const firstChartPrice = dataPoints[0]?.floorKTA || 0;
                const lastChartPrice = dataPoints[dataPoints.length - 1]?.floorKTA || 0;
                const displayChange = firstChartPrice > 0 ? ((lastChartPrice - firstChartPrice) / firstChartPrice) * 100 : 0;
                
                // Volume and sales for the selected timeframe
                const timeframeMs = intervals * intervalMs;
                const timeframeStart = now - timeframeMs;
                const timeframeTxs = ktaTransactions.filter(tx => new Date(tx.timestamp).getTime() >= timeframeStart);
                const displayVolume = timeframeTxs.reduce((sum, tx) => sum + tx.price, 0);
                const displaySalesCount = timeframeTxs.length;
                
                // Avg price for the timeframe (not all-time)
                const timeframeAvgPrice = timeframeTxs.length > 0 
                    ? timeframeTxs.reduce((sum, tx) => sum + tx.price, 0) / timeframeTxs.length
                    : avgPrice;
                
                // Update stats display with REAL timeframe-specific data
                window.updateChartStats(
                    currentFloor, 
                    ceiling, 
                    timeframeAvgPrice, 
                    listedNFTs.length, 
                    relevantNFTs.length,
                    displayChange,
                    displaySalesCount,
                    displayVolume
                );
                
                console.log(`üìä Chart: ${dataPoints.length} points | Floor: ${currentFloor.toFixed(2)} | Change: ${displayChange.toFixed(2)}% | Volume: ${displayVolume.toFixed(2)} (${displaySalesCount} txs) | TF: ${state.chartTimeframe}`);
                
                return dataPoints;
                
            } catch (error) {
                console.error("Error generating market data:", error);
                // Return minimal data to prevent chart crash
                return [{
                    timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    floorKTA: 0,
                    volume: 0
                }];
            }
        };

        // Update chart statistics with real calculations
        window.updateChartStats = (floor, ceiling, avgPrice, listedCount, totalSupply, priceChange = 0, salesCount = 0, realVolume = 0) => {
            const chartCurrency = state.chartCurrency || 'KTA';
            const curr = chartCurrency === 'PUNKS' ? 'PUNKS' : 'KTA';
            const tfLabel = state.chartTimeframe === '1h' ? '1H' : state.chartTimeframe === '24h' ? '24H' : state.chartTimeframe === '7d' ? '7D' : state.chartTimeframe === '30d' ? '30D' : 'ALL';
            
            // Floor price - show dual floors in ALL mode
            const floorEl = document.getElementById('chartFloorPrice');
            if (floorEl) {
                if (chartCurrency === 'ALL' && state._chartDualFloors) {
                    const df = state._chartDualFloors;
                    const parts = [];
                    if (df.ktaFloor > 0) parts.push(`${df.ktaFloor.toFixed(2)} KTA`);
                    if (df.punksFloor > 0) parts.push(`${df.punksFloor.toFixed(2)} PUNKS`);
                    floorEl.innerText = parts.length > 0 ? parts.join(' / ') : '‚Äî';
                } else {
                    floorEl.innerText = floor ? `${floor.toFixed(2)} ${curr}` : '‚Äî';
                }
            }
            
            // Price change for selected timeframe
            const changeEl = document.getElementById('chartFloorChange');
            if (changeEl) {
                const sign = priceChange > 0 ? '+' : '';
                changeEl.innerText = `${sign}${priceChange.toFixed(2)}% (${tfLabel})`;
                changeEl.className = `chart-stat-change ${priceChange > 0 ? 'positive' : priceChange < 0 ? 'negative' : ''}`;
            }
            
            // Volume for selected timeframe
            const volumeDisplay = realVolume > 0 ? realVolume.toFixed(2) : '0.00';
            const volumeEl = document.getElementById('chart24hVolume');
            if (volumeEl) {
                if (chartCurrency === 'ALL') {
                    volumeEl.innerText = `${volumeDisplay} (mixed)`;
                } else {
                    volumeEl.innerText = `${volumeDisplay} ${curr}`;
                }
            }
            
            // Sales count
            const volumeChangeEl = document.getElementById('chartVolumeChange');
            if (volumeChangeEl) {
                volumeChangeEl.innerText = `${salesCount} sales (${tfLabel})`;
                volumeChangeEl.className = salesCount > 0 ? 'chart-stat-change positive' : 'chart-stat-change';
            }
            
            // Listed count
            const listedEl = document.getElementById('chartListedCount');
            if (listedEl) listedEl.innerText = listedCount;
            
            const listedPercent = totalSupply > 0 ? (listedCount / totalSupply * 100).toFixed(1) : 0;
            const listedPercentEl = document.getElementById('chartListedPercent');
            if (listedPercentEl) listedPercentEl.innerText = `${listedPercent}% of supply`;
            
            // Average price
            const avgEl = document.getElementById('chartAvgPrice');
            if (avgEl) {
                if (chartCurrency === 'ALL') {
                    avgEl.innerText = avgPrice ? `${avgPrice.toFixed(2)} (mixed)` : '‚Äî';
                } else {
                    avgEl.innerText = avgPrice ? `${avgPrice.toFixed(2)} ${curr}` : '‚Äî';
                }
            }
            
            // Avg vs floor percentage
            const avgVsFloor = floor && avgPrice && floor > 0 ? (((avgPrice - floor) / floor) * 100).toFixed(1) : '0';
            const avgChangeEl = document.getElementById('chartAvgChange');
            if (avgChangeEl) {
                const aboveBelow = parseFloat(avgVsFloor) >= 0 ? 'above' : 'below';
                avgChangeEl.innerText = `${Math.abs(parseFloat(avgVsFloor))}% ${aboveBelow} floor`;
                avgChangeEl.className = `chart-stat-change ${parseFloat(avgVsFloor) >= 0 ? 'positive' : 'negative'}`;
            }
        };

        // Initialize main market chart with sophisticated styling
        window.initFloorPulseChart = async () => {
            await window.loadChartJs();
            const canvas = document.getElementById('floorPulseChart');
            if (!canvas) {
                console.error("‚ùå Chart canvas not found!");
                return;
            }
            
            const loadingState = document.getElementById('chartLoadingState');
            const emptyState = document.getElementById('chartEmptyState');
            
            try {
                if (loadingState) loadingState.classList.remove('hidden');
                if (emptyState) emptyState.classList.add('hidden');
                
                console.log("üìä Generating market data...");
                const data = await window.getMarketPulseData();
                
                // CRITICAL: Always show chart, even with minimal data
                if (!data || data.length === 0) {
                    console.log("‚ö†Ô∏è No market data - creating placeholder chart");
                    // Create placeholder data
                    const placeholderData = [];
                    const now = Date.now();
                    for (let i = 24; i >= 0; i--) {
                        const timestamp = new Date(now - (i * 3600000));
                        placeholderData.push({
                            timestamp: timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                            floorKTA: 0,
                            volume: 0
                        });
                    }
                    
                    if (state.pulseChart) state.pulseChart.destroy();
                    
                    const ctx = canvas.getContext('2d');
                    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.2)');
                    gradient.addColorStop(1, 'rgba(0, 255, 255, 0.0)');
                    
                    state.pulseChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: placeholderData.map(d => d.timestamp),
                            datasets: [{
                                label: 'Floor Price',
                                data: placeholderData.map(d => d.floorKTA),
                                borderColor: '#00ffff',
                                backgroundColor: gradient,
                                borderWidth: 2,
                                tension: 0.4,
                                fill: true,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: false }
                            },
                            scales: {
                                x: {
                                    grid: { color: 'rgba(0, 255, 255, 0.05)', drawBorder: false },
                                    ticks: { color: '#666', font: { family: 'Fira Code', size: 9 } }
                                },
                                y: {
                                    grid: { color: 'rgba(0, 255, 255, 0.08)', drawBorder: false },
                                    ticks: { color: '#00ffff', font: { family: 'Fira Code', size: 10, weight: 'bold' } }
                                }
                            }
                        }
                    });
                    
                    if (loadingState) loadingState.classList.add('hidden');
                    console.log("üìä Placeholder chart created");
                    return;
                }
                
                if (state.pulseChart) state.pulseChart.destroy();
                
                const ctx = canvas.getContext('2d');
                
                // Create gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.0)');
                
                state.pulseChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.map(d => d.timestamp),
                        datasets: [{
                            label: 'Price',
                            data: data.map(d => d.floorKTA),
                            borderColor: '#00ffff',
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointHoverBackgroundColor: '#00ffff',
                            pointHoverBorderColor: '#fff',
                            pointHoverBorderWidth: 2,
                            yAxisID: 'y'
                        }, {
                            label: 'Volume',
                            data: data.map(d => d.volume),
                            type: 'bar',
                            backgroundColor: 'rgba(0, 255, 255, 0.15)',
                            borderColor: 'rgba(0, 255, 255, 0.3)',
                            borderWidth: 1,
                            yAxisID: 'yVol',
                            barPercentage: 0.6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#00ffff',
                                bodyColor: '#fff',
                                borderColor: '#00ffff',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: false,
                                filter: function(tooltipItem) {
                                    return tooltipItem.datasetIndex === 0; // Only show price line, not volume bars
                                },
                                callbacks: {
                                    label: function(context) {
                                        const cc = state.chartCurrency || 'KTA';
                                        const curr = cc === 'PUNKS' ? 'PUNKS' : 'KTA';
                                        const suffix = cc === 'ALL' ? ' (KTA line)' : '';
                                        return `Price: ${context.parsed.y.toFixed(4)} ${curr}${suffix}`;
                                    },
                                    afterBody: function(items) {
                                        if (!items.length) return '';
                                        const idx = items[0].dataIndex;
                                        const volData = items[0].chart.data.datasets[1]?.data;
                                        if (volData && volData[idx] > 0) {
                                            const cc = state.chartCurrency || 'KTA';
                                            const curr = cc === 'ALL' ? 'mixed' : (cc === 'PUNKS' ? 'PUNKS' : 'KTA');
                                            return `Vol: ${volData[idx].toFixed(2)} ${curr}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: 'rgba(0, 255, 255, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#666',
                                    font: { family: 'Fira Code', size: 9 },
                                    maxRotation: 0,
                                    autoSkipPadding: 20
                                }
                            },
                            y: {
                                grid: {
                                    color: 'rgba(0, 255, 255, 0.08)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#00ffff',
                                    font: { family: 'Fira Code', size: 10, weight: 'bold' },
                                    callback: function(value) {
                                        const curr = window.getChartCurrencyLabel(state.chartCurrency);
                                        return value.toFixed(2) + ' ' + curr;
                                    }
                                }
                            },
                            yVol: {
                                position: 'right',
                                display: false,
                                grid: { display: false },
                                beginAtZero: true,
                                // Scale volume to take up bottom 25% of chart
                                max: Math.max(...data.map(d => d.volume), 0.01) * 4
                            }
                        }
                    }
                });
                
                if (loadingState) loadingState.classList.add('hidden');
                console.log("‚úÖ Market chart initialized with", data.length, "data points");
                
            } catch (error) {
                console.error("‚ùå Chart failed:", error);
                if (loadingState) loadingState.classList.add('hidden');
                if (emptyState) emptyState.classList.remove('hidden');
            }
        };

        // Collection-specific chart
        // Collection Chart Currency Toggle (independent from market chart)
        window.setColChartCurrency = (currency) => {
            state.colChartCurrency = currency;
            ['KTA', 'PUNKS', 'ALL'].forEach(c => {
                const btn = document.getElementById(`colChartCurrency${c}`);
                if (btn) {
                    if (c === currency) {
                        btn.className = 'px-3 py-1 text-[10px] orbitron font-black bg-cyan-500/30 text-cyan-400 transition-all';
                    } else {
                        btn.className = 'px-3 py-1 text-[10px] orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white border-l border-white/10';
                    }
                }
            });
            if (state.viewingCollection) {
                window.updateCollectionDepth(state.viewingCollection);
            }
        };
        
        window.updateCollectionDepth = async (colToken) => {
            await window.loadChartJs();
            console.log(`üìä updateCollectionDepth called for: ${colToken}`);
            
            const canvas = document.getElementById('colPageChart');
            if (!canvas) {
                console.error("‚ùå Collection chart canvas not found!");
                return;
            }
            
            console.log("‚úÖ Canvas found, context:", canvas.getContext('2d'));
            
            const loadingState = document.getElementById('colChartLoadingState');
            const emptyState = document.getElementById('colChartEmptyState');
            
            try {
                if (loadingState) loadingState.classList.remove('hidden');
                if (emptyState) emptyState.classList.add('hidden');
                
                const colNfts = state.nfts.filter(n => 
                    getNormalizedId(n.collectionToken) === getNormalizedId(colToken)
                );
                
                console.log(`üì¶ Collection has ${colNfts.length} total NFTs`);
                
                // Get REAL transaction data for this collection
                const txRef = collection(db, 'transactions');
                // Match the collectionId format used when recording transactions
                const colId = `collection_${getNormalizedId(colToken)}`;
                console.log(`üîç Searching for transactions with collectionId: ${colId}`);
                const txQuery = query(txRef, where('collectionId', '==', colId));
                const txSnapshot = await getDocs(txQuery);
                const transactions = txSnapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                console.log(`üìä Found ${transactions.length} total transactions for this collection`);
                
                // Filter to KTA/PUNKS transactions (mints, purchases, sales)
                const colChartCurrency = state.colChartCurrency || 'KTA';
                const allColValidTxs = transactions.filter(tx => 
                    (tx.type === 'sale' || tx.type === 'mint' || tx.type === 'purchase') && tx.price > 0 && tx.timestamp
                );
                let ktaTransactions;
                if (colChartCurrency === 'KTA') {
                    ktaTransactions = allColValidTxs.filter(tx => !tx.currency || tx.currency === 'KTA');
                } else if (colChartCurrency === 'PUNKS') {
                    ktaTransactions = allColValidTxs.filter(tx => tx.currency === 'PUNKS');
                } else {
                    ktaTransactions = allColValidTxs; // ALL
                }
                
                console.log(`üìä ${ktaTransactions.length} ${colChartCurrency} transactions for this collection`);
                
                const listedNFTs = colNfts.filter(n => {
                    if (!n.isListed) return false;
                    if (colChartCurrency === 'KTA') return !n.listedCurrency || n.listedCurrency === 'KTA';
                    if (colChartCurrency === 'PUNKS') return n.listedCurrency === 'PUNKS';
                    return true; // ALL
                });
                
                console.log(`üìä ${listedNFTs.length} listed in KTA`);
                
                // Calculate floor price: use listings if available, otherwise last sale price
                let floor = 0;
                let ceiling = 0;
                let floorSource = 'none';
                
                if (listedNFTs.length > 0) {
                    // Use current listings for floor/ceiling
                    const prices = listedNFTs.map(n => n.listedPrice).sort((a, b) => a - b);
                    floor = prices[0];
                    ceiling = prices[prices.length - 1];
                    floorSource = 'listings';
                } else if (ktaTransactions.length > 0) {
                    // No listings - use last sale price as floor
                    const sortedTxs = ktaTransactions.sort((a, b) => 
                        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
                    );
                    floor = sortedTxs[0].price;
                    ceiling = floor;
                    floorSource = 'last sale';
                }
                
                console.log(`üìä Floor: ${floor} KTA (from ${floorSource})`);
                
                // Calculate total volume
                const totalVolume = ktaTransactions.reduce((sum, tx) => sum + tx.price, 0);
                
                // Update collection stats
                const currSuffix = colChartCurrency === 'ALL' ? 'KTA' : colChartCurrency;
                if (floor > 0) {
                    document.getElementById('colChartFloor').innerText = `${floor.toFixed(2)} ${currSuffix}`;
                    document.getElementById('colChartCeiling').innerText = `${ceiling.toFixed(2)} ${currSuffix}`;
                } else {
                    document.getElementById('colChartFloor').innerText = '‚Äî';
                    document.getElementById('colChartCeiling').innerText = '‚Äî';
                }
                document.getElementById('colChartVolume').innerText = `${totalVolume.toFixed(2)} ${colChartCurrency === 'ALL' ? 'KTA+PUNKS' : colChartCurrency}`;
                document.getElementById('colChartListed').innerText = listedNFTs.length;
                document.getElementById('colChartSupply').innerText = colNfts.length;
                
                // If no transactions, show empty state
                if (ktaTransactions.length === 0) {
                    console.log("‚ö†Ô∏è No transactions - showing empty state");
                    if (loadingState) loadingState.classList.add('hidden');
                    if (emptyState) emptyState.classList.remove('hidden');
                    return;
                }
                
                // Generate time series based on REAL transactions
                const now = Date.now();
                let intervals = 24;
                let intervalMs = 3600000;
                
                console.log(`üìä Collection chart using timeframe: ${state.collectionChartTimeframe}`);
                
                switch (state.collectionChartTimeframe) {
                    case '1h':
                        intervals = 12;
                        intervalMs = 300000; // 5 min
                        break;
                    case '24h':
                        intervals = 24;
                        intervalMs = 3600000; // 1 hour
                        break;
                    case '7d':
                        intervals = 28;
                        intervalMs = 6 * 3600000; // 6 hours
                        break;
                    case 'all':
                        // Dynamic: span from first transaction to now
                        if (ktaTransactions.length > 0) {
                            const timestamps = ktaTransactions.map(tx => new Date(tx.timestamp).getTime());
                            const earliest = Math.min(...timestamps);
                            const totalSpan = now - earliest;
                            intervals = Math.min(60, Math.max(10, Math.ceil(totalSpan / (24 * 3600000))));
                            intervalMs = Math.max(3600000, Math.floor(totalSpan / intervals));
                        } else {
                            intervals = 30;
                            intervalMs = 24 * 3600000;
                        }
                        break;
                }
                
                const data = [];
                let lastPrice = floor; // Start with floor price
                
                for (let i = intervals; i >= 0; i--) {
                    const timestamp = new Date(now - (i * intervalMs));
                    const intervalStart = timestamp.getTime();
                    const intervalEnd = intervalStart + intervalMs;
                    
                    // Find transactions in this time interval
                    const intervalTxs = ktaTransactions.filter(tx => {
                        const txTime = new Date(tx.timestamp).getTime();
                        return txTime >= intervalStart && txTime < intervalEnd;
                    });
                    
                    // Calculate average price for this interval (or carry forward last price)
                    let avgPrice = lastPrice; // Carry forward
                    if (intervalTxs.length > 0) {
                        const sum = intervalTxs.reduce((acc, tx) => acc + tx.price, 0);
                        avgPrice = sum / intervalTxs.length;
                        lastPrice = avgPrice; // Update last known price
                    }
                    
                    data.push({
                        timestamp: window.formatChartLabel(timestamp, state.collectionChartTimeframe),
                        price: avgPrice,
                        volume: intervalTxs.reduce((acc, tx) => acc + tx.price, 0),
                        txCount: intervalTxs.length
                    });
                }
                
                if (state.colPageChart) {
                    state.colPageChart.destroy();
                    state.colPageChart = null;
                }
                
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, 'rgba(188, 19, 254, 0.4)');
                gradient.addColorStop(1, 'rgba(188, 19, 254, 0.0)');
                
                state.colPageChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.map(d => d.timestamp),
                        datasets: [{
                            label: 'Floor Price',
                            data: data.map(d => d.price),
                            borderColor: '#bc13fe',
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointHoverBackgroundColor: '#bc13fe',
                            pointHoverBorderColor: '#fff',
                            pointHoverBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#bc13fe',
                                bodyColor: '#fff',
                                borderColor: '#bc13fe',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: false,
                                callbacks: {
                                    label: function(context) {
                                        const curr = window.getChartCurrencyLabel(state.colChartCurrency);
                                        return `Price: ${context.parsed.y.toFixed(4)} ${curr}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: 'rgba(188, 19, 254, 0.05)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#666',
                                    font: { family: 'Fira Code', size: 9 },
                                    maxRotation: 0
                                }
                            },
                            y: {
                                grid: {
                                    color: 'rgba(188, 19, 254, 0.08)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#bc13fe',
                                    font: { family: 'Fira Code', size: 10, weight: 'bold' },
                                    callback: function(value) {
                                        const curr = window.getChartCurrencyLabel(state.colChartCurrency);
                                        return value.toFixed(2) + ' ' + curr;
                                    }
                                }
                            }
                        }
                    }
                });
                
                if (loadingState) loadingState.classList.add('hidden');
                console.log(`‚úÖ Collection chart created with ${data.length} points`);
                
            } catch (error) {
                console.error("Collection chart error:", error);
                if (loadingState) loadingState.classList.add('hidden');
                if (emptyState) emptyState.classList.remove('hidden');
            }
        };

        // Start real-time chart updates (reduced frequency)
        window.startChartAutoUpdate = () => {
            // Clear existing interval
            if (state.chartUpdateInterval) {
                clearInterval(state.chartUpdateInterval);
            }
            
            // Update charts and transaction list every 60 seconds (less aggressive)
            state.chartUpdateInterval = setInterval(async () => {
                // Only update if on market tab (performance optimization)
                const marketTab = document.getElementById('tab-market');
                if (marketTab && !marketTab.classList.contains('hidden')) {
                    console.log("üîÑ Auto-updating market chart with fresh data...");
                    // FIX #10: Refresh NFT data before updating chart
                    await window.loadNFTsFromFirebase();
                    window.updateMarketChart();
                }
                
                // Update collection chart if viewing a collection
                if (state.viewingCollection) {
                    const collectionTab = document.getElementById('tab-collection-view');
                    if (collectionTab && !collectionTab.classList.contains('hidden')) {
                        console.log("üîÑ Auto-updating collection chart...");
                        window.updateCollectionDepth(state.viewingCollection);
                    }
                }
                
                // Auto-refresh transaction history when on transactions tab
                const txTab = document.getElementById('tab-transactions');
                if (txTab && !txTab.classList.contains('hidden') && state.address) {
                    window.loadTransactions();
                }
            }, 60000); // 60 seconds
            
            console.log("‚úÖ Chart auto-update started (60s interval)");
        };

        // Stop auto-updates
        window.stopChartAutoUpdate = () => {
            if (state.chartUpdateInterval) {
                clearInterval(state.chartUpdateInterval);
                state.chartUpdateInterval = null;
                console.log("‚è∏Ô∏è Chart auto-update stopped");
            }
        };

        // Buy NFT function
        // Universal tx hash extraction - tries every possible path
        window.extractTxHash = (txResult) => {
            if (!txResult) return null;
            
            // Method 1: voteStaple.blocks[0].$hash
            try { if (txResult?.voteStaple?.blocks?.[0]?.$hash) return txResult.voteStaple.blocks[0].$hash; } catch(e) {}
            
            // Method 2: Direct .hash property
            try { if (txResult?.hash) return txResult.hash; } catch(e) {}
            
            // Method 3: voteStaple.blocks[1].$hash (vote block)
            try { if (txResult?.voteStaple?.blocks?.[1]?.$hash) return txResult.voteStaple.blocks[1].$hash; } catch(e) {}
            
            // Method 4: $hash at root
            try { if (txResult?.$hash) return txResult.$hash; } catch(e) {}
            
            // Method 5: Deep search for any key containing 'hash' (case-insensitive)
            try {
                const json = JSON.stringify(txResult, (k, v) => typeof v === 'bigint' ? v.toString() : v);
                // Look for 64-char hex hash
                const hashMatch = json.match(/["']?\$?hash["']?\s*[:=]\s*["']([A-Fa-f0-9]{64})["']/);
                if (hashMatch) return hashMatch[1];
                // Look for any 64-char hex string (likely a hash)
                const hexMatch = json.match(/["']([A-Fa-f0-9]{64})["']/);
                if (hexMatch) return hexMatch[1];
            } catch(e) {}
            
            // Method 6: Check if txResult itself is a string hash
            if (typeof txResult === 'string' && /^[A-Fa-f0-9]{64}$/.test(txResult)) return txResult;
            
            // Method 7: Check result.data or result.txHash
            try { if (txResult?.data?.txHash) return txResult.data.txHash; } catch(e) {}
            try { if (txResult?.result?.hash) return txResult.result.hash; } catch(e) {}
            
            console.warn("‚ö†Ô∏è Could not extract tx hash. Full tx object keys:", Object.keys(txResult));
            return null;
        };
        
        window.buyNFT = async (nftId, isBlind = false) => {
            if (!state.keetaClient) return window.notify("Connect wallet first", "error");
            if (!window.acquireTxLock(`buy_${nftId}`)) return window.notify("Purchase already in progress...", "warning");
            
            try {
                // Step 1: Fetch NFT data
                const snap = await getDoc(doc(db, 'nfts', nftId));
                if (!snap.exists()) return window.notify("NFT not found", "error");
                
                const nft = snap.data();
                
                // FIX: Prevent buying your own NFT
                if (nft.owner && nft.owner.toLowerCase() === state.address.toLowerCase()) {
                    return window.notify("‚ùå Cannot buy your own NFT", "error");
                }
                
                // Determine price - FIX: Always use listedPrice for listed NFTs
                const price = nft.listedPrice || nft.priceKTA || 0;
                const currency = nft.listedCurrency || 'KTA';
                
                if (price <= 0) {
                    return window.notify("Invalid price", "error");
                }
                
                // Check balance
                if (currency === 'KTA' && state.balanceKTA < price) {
                    return window.notify(`Insufficient balance. Need ${price} KTA`, "error");
                }
                if (currency === 'PUNKS' && state.balancePunks < price) {
                    return window.notify(`Insufficient balance. Need ${price} PUNKS`, "error");
                }
                
                // Step 2: Confirm purchase
                window.notify(`Purchasing ${nft.name} for ${price} ${currency}...`, "success");
                
                // Variable to store transaction hash
                let txHash = null;
                
                // Initialize clients
                if (typeof state.keetaClient.init === 'function') {
                    await state.keetaClient.init();
                }
                
                // Step 3: Execute transaction
                if (isBlind) {
                    console.log("‚úÖ Blind mint purchase - releasing NFT via Cloud Function");
                    
                    // Step 3a: Buyer sends payment
                    const buyerBuilder = state.keetaClient.initBuilder();
                    buyerBuilder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                    const buyToken = window.getTokenForCurrency(currency);
                    buyerBuilder.send(KeetaNet.lib.Account.fromPublicKeyString(nft.creator), BigInt(Math.floor(price * KTA_DECIMALS)), buyToken);
                    
                    await state.keetaClient.computeBuilderBlocks(buyerBuilder);
                    const buyerTx = await state.keetaClient.publishBuilder(buyerBuilder);
                    console.log("‚úÖ Payment published for blind mint purchase");
                    
                    // Step 3b: Release NFT from escrow via Cloud Function (SECURE)
                    let escrowTx = null;
                    if (nft.inEscrow) {
                        try {
                            console.log("üîí Calling Cloud Function to release blind mint NFT...");
                            const releaseResult = await window.processNFTPurchase({
                                nftId: nftId,
                                buyerAddress: state.address
                            });
                            if (releaseResult.data && releaseResult.data.success) {
                                escrowTx = { hash: releaseResult.data.txHash };
                                console.log("‚úÖ Blind mint NFT released via Cloud Function:", releaseResult.data.txHash);
                            }
                        } catch (escrowErr) {
                            console.error("‚ö†Ô∏è Blind mint escrow release failed:", escrowErr);
                        }
                    }
                    
                    // Custom replacer to handle BigInt serialization
                    const bigIntReplacer = (key, value) => {
                        return typeof value === 'bigint' ? value.toString() : value;
                    };
                    
                    console.log("üìù Purchase buyerTx (full):", JSON.stringify(buyerTx, bigIntReplacer, 2));
                    
                    // Extract REAL transaction hash from blocks
                    let purchaseTxHash = window.extractTxHash(buyerTx) || window.extractTxHash(escrowTx);
                    console.log("üîç Extracted purchase tx hash:", purchaseTxHash);
                    txHash = purchaseTxHash;
                    
                    // Update database
                    await updateDoc(doc(db, 'nfts', nftId), {
                        status: 'transferred',
                        owner: state.address,
                        wasBlindMinted: true,
                        isListed: false,
                        listedPrice: null,
                        listedCurrency: null,
                        transferredAt: new Date().toISOString()
                    });
                    
                } else {
                    // Secondary sale with fee splits
                    const totalPrice = price;
                    // Use custom royalty if set, otherwise use default
                    const collection = state.collections.find(c => 
                        c.collectionId === nft.collectionId || 
                        c.collectionToken === nft.collectionToken
                    );
                    let royaltyPercent = collection?.creatorRoyaltyPercent || SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
                    // Safety: if royalty was stored as whole number (5 instead of 0.05), convert it
                    if (royaltyPercent > 1) royaltyPercent = royaltyPercent / 100;
                    const marketplaceFeePercent = SECONDARY_SALE_MARKETPLACE_PERCENT;
                    const sellerPercent = Math.max(0, 1 - royaltyPercent - marketplaceFeePercent);
                    
                    if (sellerPercent <= 0) {
                        console.error("‚ùå sellerPercent is zero or negative!", { royaltyPercent, marketplaceFeePercent, sellerPercent });
                        return window.notify("Fee calculation error ‚Äî seller would receive nothing. Check collection royalty settings.", "error");
                    }
                    
                    const sellerPayout = totalPrice * sellerPercent;
                    const creatorRoyalty = totalPrice * royaltyPercent;
                    const marketplaceFee = totalPrice * marketplaceFeePercent;
                    const feeTotal = sellerPayout + creatorRoyalty + marketplaceFee;
                    
                    console.log("üí∞ Fee breakdown:", {
                        totalPrice,
                        royaltyPercent: `${(royaltyPercent * 100).toFixed(1)}%`,
                        marketplaceFeePercent: `${(marketplaceFeePercent * 100).toFixed(1)}%`,
                        sellerPercent: `${(sellerPercent * 100).toFixed(1)}%`,
                        sellerPayout: sellerPayout.toFixed(6),
                        creatorRoyalty: creatorRoyalty.toFixed(6),
                        marketplaceFee: marketplaceFee.toFixed(6),
                        feeTotal: feeTotal.toFixed(6),
                        matchesTotal: Math.abs(feeTotal - totalPrice) < 0.001
                    });
                    
                    // SECURE: Escrow release handled by Cloud Function (no client-side escrow signing)
                    
                    // Determine if NFT is in escrow or still with seller
                    const nftInEscrow = nft.inEscrow === true;
                    console.log(`üì¶ NFT location: ${nftInEscrow ? 'ESCROW wallet' : 'SELLER wallet'}`);
                    
                    // Build payment transaction (buyer pays fee-split amounts)
                    const saleToken = window.getTokenForCurrency(currency);
                    const pB = state.keetaClient.initBuilder();
                    pB.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                    
                    // Send seller their cut
                    pB.send(
                        KeetaNet.lib.Account.fromPublicKeyString(nft.owner || nft.creator),
                        BigInt(Math.floor(sellerPayout * KTA_DECIMALS)),
                        saleToken
                    );
                    // Send creator royalty
                    pB.send(
                        KeetaNet.lib.Account.fromPublicKeyString(nft.creator),
                        BigInt(Math.floor(creatorRoyalty * KTA_DECIMALS)),
                        saleToken
                    );
                    // Send marketplace fee
                    pB.send(
                        KeetaNet.lib.Account.fromPublicKeyString(MARKETPLACE_FEE_WALLET),
                        BigInt(Math.floor(marketplaceFee * KTA_DECIMALS)),
                        saleToken
                    );
                    
                    let purchaseTx, escrowReleaseTx;
                    
                    // Step 1: Process buyer payment (buyer signs)
                    await state.keetaClient.computeBuilderBlocks(pB);
                    purchaseTx = await state.keetaClient.publishBuilder(pB);
                    console.log("‚úÖ Payment transaction published");
                    
                    // Step 2: If NFT is in escrow, release via Cloud Function (server signs)
                    if (nftInEscrow) {
                        console.log("üîí Calling Cloud Function to release NFT from escrow to buyer...");
                        try {
                            const releaseResult = await window.processNFTPurchase({
                                nftId: nftId,
                                buyerAddress: state.address
                            });
                            
                            if (releaseResult.data && releaseResult.data.success) {
                                console.log("‚úÖ NFT released from escrow via Cloud Function:", releaseResult.data.txHash);
                                escrowReleaseTx = { hash: releaseResult.data.txHash };
                            } else {
                                console.error("‚ö†Ô∏è Escrow release returned unexpected response:", releaseResult.data);
                                window.notify("‚ö†Ô∏è Payment sent but NFT escrow release may have failed ‚Äî contact support", "error");
                            }
                        } catch (escrowError) {
                            console.error("‚ùå Cloud Function escrow release failed:", escrowError);
                            window.notify("‚ö†Ô∏è Payment sent but NFT escrow release failed ‚Äî contact support for resolution", "error");
                        }
                    } else {
                        // NFT is NOT in escrow ‚Äî trust-based sale (payment only)
                        console.log("üí≥ Trust-based sale ‚Äî payment processed (NFT not in escrow)");
                        escrowReleaseTx = null;
                    }
                    
                    // Extract transaction hash
                    txHash = window.extractTxHash(purchaseTx) || window.extractTxHash(escrowReleaseTx);
                    
                    console.log("üìù Purchase tx:", purchaseTx);
                    console.log("üìù Escrow release tx:", escrowReleaseTx);
                    console.log("üîç Extracted tx hash:", txHash);
                    
                    // Update database
                    await updateDoc(doc(db, 'nfts', nftId), {
                        status: 'sold',
                        owner: state.address,
                        previousOwner: nft.owner,
                        isListed: false,
                        listedPrice: null,
                        listedCurrency: null,
                        inEscrow: false, // No longer in escrow
                        soldAt: new Date().toISOString(),
                        soldPrice: price,
                        soldCurrency: currency,
                        saleType: 'secondary',
                        lastTxHash: txHash
                    });
                }
                
                // Step 4: Update local state immediately (no waiting)
                const nftIndex = state.nfts.findIndex(n => n.id === nftId);
                if (nftIndex !== -1) {
                    state.nfts[nftIndex].owner = state.address;
                    state.nfts[nftIndex].isListed = false;
                    state.nfts[nftIndex].listedPrice = null;
                    state.nfts[nftIndex].listedCurrency = null;
                    // FIX #10: Update local state with sale data for charts
                    state.nfts[nftIndex].soldAt = new Date().toISOString();
                    state.nfts[nftIndex].soldPrice = price;
                    state.nfts[nftIndex].soldCurrency = currency;
                    state.nfts[nftIndex].saleType = 'secondary';
                    state.nfts[nftIndex].lastTxHash = txHash;
                }
                
                // Success notification
                window.notify(`‚úÖ ${nft.name} purchased successfully!`, "success");
                
                // Record transaction (don't let this break the flow)
                try {
                    // Generate collectionId if missing (for old NFTs)
                    let collectionId = nft.collectionId;
                    if (!collectionId && nft.collectionToken) {
                        collectionId = `collection_${getNormalizedId(nft.collectionToken)}`;
                        console.log("‚ö†Ô∏è NFT missing collectionId, generated:", collectionId);
                    }
                    
                    // FIX #10: Record BOTH purchase (buyer) AND sale (seller) transactions
                    await Promise.all([
                        // Buyer's purchase transaction
                        window.recordTransaction({
                            type: 'purchase',
                            nftId: nft.id || nftId,
                            nftName: nft.name,
                            collection: nft.collectionName || nft.collection,
                            collectionId: collectionId,
                            price: price,
                            currency: currency,
                            counterParty: nft.owner || nft.creator,
                            txHash: txHash
                        }),
                        // Seller's sale transaction (for chart completeness)
                        window.recordTransaction({
                            type: 'sale',
                            nftId: nft.id || nftId,
                            nftName: nft.name,
                            collection: nft.collectionName || nft.collection,
                            collectionId: collectionId,
                            price: price,
                            currency: currency,
                            counterParty: state.address, // Buyer
                            txHash: txHash,
                            sellerWallet: nft.owner || nft.creator // Track original seller
                        })
                    ]);
                    
                    console.log("‚úÖ Both purchase & sale transactions recorded with hash:", txHash);
                    
                    // Refresh transaction history
                    await window.loadTransactions();
                } catch (txError) {
                    console.warn("‚ö†Ô∏è Could not record transaction:", txError.message);
                }
                
                // Step 5: Update UI (async, don't wait)
                setTimeout(async () => {
                    window.refreshBalance();
                    await window.renderMarketplace();
                    await window.renderCollection();
                    // FIX #10: Force immediate chart update with fresh data
                    await window.loadNFTsFromFirebase();
                    window.updateMarketChart();
                }, 100);
                
            } catch (e) {
                console.error("Purchase error:", e);
                window.notify(`‚ùå Purchase failed: ${e.message}`, "error");
            } finally {
                window.releaseTxLock(`buy_${nftId}`);
            }
        };
        window.setPriceMode = (mode) => {
            state.priceMode = mode;
            document.querySelectorAll('.price-mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${mode}`)?.classList.add('active');
            const ktaBox = document.getElementById('ktaInputBox');
            const punksBox = document.getElementById('punksInputBox');
            if (ktaBox) ktaBox.style.opacity = (mode === 'kta' || mode === 'hybrid') ? "1" : "0.2";
            if (punksBox) punksBox.style.opacity = (mode === 'punks' || mode === 'hybrid') ? "1" : "0.2";
        };

        window.checkEscrowAccess = () => {
            const isEscrow = state.address && ESCROW_ADDRESS && state.address.toLowerCase().trim() === ESCROW_ADDRESS.toLowerCase().trim();
            
            // Show escrow admin tab only for escrow wallet
            document.getElementById('nav-escrow-admin')?.classList.toggle('hidden', !isEscrow);
            
            // Show diagnostics and maintenance ONLY for escrow wallet
            document.getElementById('escrowDiagnostics')?.classList.toggle('hidden', !isEscrow);
            document.getElementById('escrowMaintenanceProtocol')?.classList.toggle('hidden', !isEscrow);
            
            return isEscrow;
        };

        window.switchTab = (tab) => {
            state.currentTab = tab;
            try { sessionStorage.setItem('punkswap_current_tab', tab); } catch(e) {}
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            const cEl = document.getElementById(`tab-${tab}`);
            if (cEl) cEl.classList.remove('hidden');
            const nEl = document.getElementById(`nav-${tab}`);
            if (nEl) nEl.classList.add('active');
            window.refreshAuthGate();
            if (tab === 'collection' && state.address) window.renderCollection();
            if (tab === 'market') { 
                window.renderMarketplace(); 
                window.renderDrops(); 
                window.populateChartSelector();
                window.updateMarketChart(); 
            }
            if (tab === 'transactions' && state.address) {
                window.loadTransactions();
            }
            if (tab === 'portfolio' && state.address) {
                window.calculatePortfolio();
            }
            if (tab === 'all-collections') {
                window.renderAllCollections();
            }
            if (tab === 'offers' && state.address) {
                window.loadOffers();
                window.renderOffers();
            }
            if (tab === 'airdrop' && state.address) {
                // Check if already unlocked
                if (airdropState.unlocked) {
                    document.getElementById('airdropPasscodeGate')?.classList.add('hidden');
                    document.getElementById('airdropContent')?.classList.remove('hidden');
                    window.loadAirdropCollections();
                    window.renderAirdropHistory();
                } else {
                    // Show passcode gate
                    document.getElementById('airdropPasscodeGate')?.classList.remove('hidden');
                    document.getElementById('airdropContent')?.classList.add('hidden');
                    document.getElementById('airdropPasscodeInput').value = '';
                    document.getElementById('airdropPasscodeInput').focus();
                }
            }
            if (tab === 'escrow-admin' && state.address) {
                window.loadEscrowStats();
            }
        };

        // Toggle monitoring dropdown
        window.toggleMonitoring = () => {
            const dropdown = document.getElementById('monitoringDropdown');
            const btnText = document.getElementById('monitoringBtnText');
            
            if (dropdown && btnText) {
                const isHidden = dropdown.classList.contains('hidden');
                
                if (isHidden) {
                    dropdown.classList.remove('hidden');
                    btnText.innerText = 'Hide Monitoring';
                    window.renderWatchlist();
                } else {
                    dropdown.classList.add('hidden');
                    btnText.innerText = 'Show Monitoring';
                }
            }
        };
        
        // Render watchlist
        window.renderWatchlist = () => {
            const grid = document.getElementById('watchlistGrid');
            if (!grid) return;
            
            const monitored = state.watchlist || [];
            document.getElementById('monitoredCount').innerText = `${monitored.length} monitored`;
            
            if (monitored.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-500 fira text-sm py-10">No monitored NFTs yet</div>';
                return;
            }
            
            grid.innerHTML = monitored.map(nftId => {
                const nft = state.nfts.find(n => n.id === nftId);
                if (!nft) return '';
                const watchImgPath = window.getNFTImagePath(nft);
                return `
                    <div class="glass-card p-5 flex flex-col group border-white/5 hover:border-cyan-500/30 transition-all">
                        <img src="${watchImgPath ? getIPFSUrl(watchImgPath) : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22400%22%3E%3Crect fill=%22%23111%22/%3E%3C/svg%3E'}" class="sharp-img rounded-lg aspect-square object-cover mb-4">
                        <h4 class="orbitron text-[9px] font-bold text-white uppercase truncate">${nft.name}</h4>
                        <button onclick="window.removeFromWatchlist('${nftId}')" class="mt-2 p-2 text-[8px] text-gray-500 hover:text-red-400 transition-colors">Remove</button>
                    </div>
                `;
            }).join('');
        };
        
        window.addToWatchlist = (nftId) => {
            if (!state.watchlist.includes(nftId)) {
                state.watchlist.push(nftId);
                window.notify("Added to monitoring", "success");
            }
        };
        
        window.removeFromWatchlist = (nftId) => {
            state.watchlist = state.watchlist.filter(id => id !== nftId);
            window.renderWatchlist();
            window.notify("Removed from monitoring", "success");
        };
        
        window.runNeuralRepair = async () => { 
            window.notify("Running diagnostics...", "success"); 
            await window.loadNFTsFromFirebase(); 
            window.notify("Sync complete", "success"); 
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WHITELIST SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Toggle whitelist settings controls visibility (when user checks Enable Whitelist)
        window.toggleWhitelistSettingsUI = () => {
            const enabled = document.getElementById('whitelistEnabled')?.checked || false;
            const controls = document.getElementById('whitelistControls');
            if (controls) {
                if (enabled) controls.classList.remove('hidden');
                else controls.classList.add('hidden');
            }
        };

        // Load whitelist settings for collection
        window.loadWhitelistSettings = async (collectionId) => {
            try {
                console.log(`üîç Loading whitelist settings for: ${collectionId}`);
                const settingsRef = doc(db, 'whitelistSettings', collectionId);
                const snap = await getDoc(settingsRef);
                
                if (snap.exists()) {
                    const data = snap.data();
                    console.log(`‚úÖ Whitelist settings found:`, data);
                    console.log(`üìä Phases in settings:`, data.phases);
                    state.whitelistSettings[collectionId] = data;
                    
                    // Populate UI
                    document.getElementById('whitelistEnabled').checked = data.enabled || false;
                    
                    // Load phases
                    if (data.phases && Array.isArray(data.phases)) {
                        console.log(`‚úÖ Loading ${data.phases.length} phases into UI`);
                        window.whitelistPhases = data.phases;
                        window.renderWhitelistPhases();
                    } else {
                        console.log(`‚ö†Ô∏è No phases found in settings`);
                        window.whitelistPhases = [];
                        window.renderWhitelistPhases();
                    }
                    
                    window.toggleWhitelistSettingsUI?.();
                } else {
                    console.log(`‚ö†Ô∏è No whitelist settings found for ${collectionId}`);
                    state.whitelistSettings[collectionId] = { enabled: false, phases: [] };
                    document.getElementById('whitelistEnabled').checked = false;
                    window.whitelistPhases = [];
                    window.renderWhitelistPhases();
                    window.toggleWhitelistSettingsUI?.();
                }
                
                console.log(`üìä State after loading:`, state.whitelistSettings[collectionId]);
                
            } catch (error) {
                console.error("Error loading whitelist settings:", error);
            }
        };
        
        // Load whitelist wallets
        window.loadWhitelistWallets = async (collectionId) => {
            try {
                const walletsRef = collection(db, 'whitelistWallets');
                const q = query(walletsRef, where('collectionId', '==', collectionId));
                const snapshot = await getDocs(q);
                
                const wallets = [];
                snapshot.forEach((doc) => {
                    wallets.push({ id: doc.id, ...doc.data() });
                });
                
                state.whitelistWallets[collectionId] = wallets;
                window.renderWhitelistTable();
                
            } catch (error) {
                console.error("Error loading whitelist wallets:", error);
            }
        };
        
        // Add wallet to whitelist
        window.addWhitelistWallet = async () => {
            const wallet = document.getElementById('whitelistWallet').value.trim();
            const maxMints = parseInt(document.getElementById('whitelistMaxMints').value) || 1;
            
            if (!wallet) {
                return window.notify("Enter wallet address", "error");
            }
            
            // Basic validation - must start with 'keeta_' or be long enough
            if (wallet.length < 20) {
                return window.notify("Invalid wallet address", "error");
            }
            
            // Check for duplicates in current session
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) {
                return window.notify("No active collection", "error");
            }
            
            const existing = state.whitelistWallets[currentCollection.collectionId] || [];
            if (existing.some(w => w.walletAddress.toLowerCase() === wallet.toLowerCase())) {
                return window.notify("Wallet already whitelisted", "error");
            }
            
            try {
                const walletData = {
                    collectionId: currentCollection.collectionId,
                    walletAddress: wallet,
                    maxMints: maxMints,
                    usedMints: 0,
                    createdByCreator: true,
                    createdAt: new Date().toISOString()
                };
                
                const walletRef = doc(collection(db, 'whitelistWallets'));
                await setDoc(walletRef, walletData);
                
                // Add to local state
                if (!state.whitelistWallets[currentCollection.collectionId]) {
                    state.whitelistWallets[currentCollection.collectionId] = [];
                }
                state.whitelistWallets[currentCollection.collectionId].push({ id: walletRef.id, ...walletData });
                
                // Clear inputs
                document.getElementById('whitelistWallet').value = '';
                document.getElementById('whitelistMaxMints').value = '1';
                
                window.renderWhitelistTable();
                window.notify("Wallet added to whitelist", "success");
                
            } catch (error) {
                console.error("Error adding wallet:", error);
                window.notify("Failed to add wallet", "error");
            }
        };
        
        // Remove wallet from whitelist
        window.removeWhitelistWallet = async (collectionId, walletId) => {
            try {
                const walletRef = doc(db, 'whitelistWallets', walletId);
                await deleteDoc(walletRef);
                
                // Remove from local state
                if (state.whitelistWallets[collectionId]) {
                    state.whitelistWallets[collectionId] = state.whitelistWallets[collectionId].filter(w => w.id !== walletId);
                }
                
                window.renderWhitelistTable();
                window.notify("Wallet removed", "success");
                
            } catch (error) {
                console.error("Error removing wallet:", error);
                window.notify("Failed to remove wallet", "error");
            }
        };
        
        // Clear all whitelist wallets
        window.clearWhitelist = async () => {
            const confirmed = await window.showCustomConfirm({
                icon: '‚ö†Ô∏è',
                title: 'Clear All Wallets',
                message: 'Clear all whitelisted wallets?\n\nThis cannot be undone.',
                confirmText: 'üóëÔ∏è Yes, Clear All',
                danger: true
            });
            
            if (!confirmed) return;
            
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) return;
            
            const wallets = state.whitelistWallets[currentCollection.collectionId] || [];
            
            for (const wallet of wallets) {
                await window.removeWhitelistWallet(currentCollection.collectionId, wallet.id);
            }
        };
        
        // Handle file upload (CSV/JSON)
        window.handleWhitelistUpload = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) {
                return window.notify("No active collection", "error");
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                
                try {
                    let wallets = [];
                    
                    // Try JSON first
                    if (file.name.endsWith('.json')) {
                        const json = JSON.parse(text);
                        wallets = json.map(item => ({
                            wallet: item.wallet || item.wallet_address,
                            maxMints: item.max_mints || item.maxMints || 1
                        }));
                    } else {
                        // Parse CSV
                        const lines = text.trim().split('\n');
                        const hasHeader = lines[0].toLowerCase().includes('wallet');
                        const startIdx = hasHeader ? 1 : 0;
                        
                        for (let i = startIdx; i < lines.length; i++) {
                            const parts = lines[i].split(',');
                            if (parts.length >= 1 && parts[0].trim()) {
                                wallets.push({
                                    wallet: parts[0].trim(),
                                    maxMints: parseInt(parts[1]) || 1
                                });
                            }
                        }
                    }
                    
                    // Add all wallets
                    let added = 0;
                    let failed = 0;
                    
                    for (const item of wallets) {
                        try {
                            if (item.wallet && item.wallet.length > 20) {
                                const walletData = {
                                    collectionId: currentCollection.collectionId,
                                    walletAddress: item.wallet,
                                    maxMints: item.maxMints,
                                    usedMints: 0,
                                    createdByCreator: true,
                                    createdAt: new Date().toISOString()
                                };
                                
                                const walletRef = doc(collection(db, 'whitelistWallets'));
                                await setDoc(walletRef, walletData);
                                added++;
                            } else {
                                failed++;
                            }
                        } catch (error) {
                            failed++;
                        }
                    }
                    
                    await window.loadWhitelistWallets(currentCollection.collectionId);
                    window.notify(`‚úÖ Import complete: ${added} added, ${failed} failed`, "success");
                    
                    event.target.value = ''; // Reset file input
                    
                } catch (error) {
                    console.error("File upload error:", error);
                    window.notify("Failed to parse file", "error");
                }
            };
            
            reader.readAsText(file);
        };
        
        // Render whitelist table
        window.renderWhitelistTable = () => {
            const container = document.getElementById('whitelistTable');
            const countEl = document.getElementById('whitelistCount');
            
            const currentCollection = state.collections.find(c => c.blindMintEnabled);
            if (!currentCollection) {
                container.innerHTML = '<div class="text-center text-gray-600 fira text-xs py-8">No collection selected</div>';
                countEl.innerText = '0';
                return;
            }
            
            const wallets = state.whitelistWallets[currentCollection.collectionId] || [];
            countEl.innerText = wallets.length;
            
            if (wallets.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-600 fira text-xs py-8">No wallets added yet</div>';
                return;
            }
            
            container.innerHTML = wallets.map(w => `
                <div class="flex items-center justify-between p-3 bg-black/60 rounded-lg border border-white/5 hover:border-cyan-500/30 transition-all">
                    <div class="flex-1 min-w-0">
                        <div class="fira text-[10px] text-cyan-400 font-mono truncate">${w.walletAddress}</div>
                        <div class="fira text-[9px] text-gray-600 mt-1">Used: ${w.usedMints}/${w.maxMints} mints</div>
                    </div>
                    <button onclick="window.removeWhitelistWallet('${currentCollection.collectionId}', '${w.id}')" 
                            class="ml-3 px-3 py-1 rounded border border-red-500/30 text-red-400 text-[10px] hover:bg-red-500/10 transition-all">
                        Remove
                    </button>
                </div>
            `).join('');
        };
        
        // Load wallet mint tracking for current user
        window.loadWalletMintTracking = async () => {
            if (!state.address) {
                console.log("‚ö†Ô∏è No wallet connected, skipping mint tracking load");
                return {};
            }
            
            try {
                console.log("üì• Loading wallet mint tracking for:", state.address);
                const trackingRef = collection(db, 'walletMintTracking');
                const q = query(trackingRef, where('walletAddress', '==', state.address));
                const snapshot = await getDocs(q);
                
                // Initialize tracking object
                state.walletMintTracking = state.walletMintTracking || {};
                
                let trackCount = 0;
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const collectionId = data.collectionId;
                    
                    // Store by collection -> wallet -> data
                    if (!state.walletMintTracking[collectionId]) {
                        state.walletMintTracking[collectionId] = {};
                    }
                    
                    state.walletMintTracking[collectionId][state.address] = {
                        count: data.mintedCount || 0,
                        lastMintedAt: data.lastMintedAt || null
                    };
                    
                    trackCount++;
                    console.log(`  ‚úì ${collectionId}: ${data.mintedCount} mints`);
                });
                
                console.log(`‚úÖ Loaded ${trackCount} mint tracking records`);
                return state.walletMintTracking;
            } catch (error) {
                console.error("‚ùå Error loading wallet mint tracking:", error);
                state.walletMintTracking = {};
                return {};
            }
        };
        
        // Save whitelist settings
        // WHITELIST PHASES WITH CUSTOM PRICING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Populate whitelist collection selector dropdown
        window.populateWhitelistCollections = () => {
            const selector = document.getElementById('whitelistCollectionSelector');
            if (!selector) return;
            
            // Keep the placeholder
            selector.innerHTML = '<option value="">-- Select a Collection --</option>';
            
            // Add all collections
            state.collections.forEach(col => {
                const option = document.createElement('option');
                option.value = col.id;
                option.textContent = col.collectionTitle || col.name || col.id;
                selector.appendChild(option);
            });
            
            console.log(`‚úÖ Populated whitelist dropdown with ${state.collections.length} collections`);
        };
        
        window.whitelistPhases = [];
        
        window.addWhitelistPhase = () => {
            const phaseNumber = window.whitelistPhases.length + 1;
            const phaseId = `phase_${Date.now()}`;
            
            const phase = {
                id: phaseId,
                name: `Phase ${phaseNumber}`,
                priceKTA: 1,
                startTime: null,
                endTime: null,
                maxMintsPerWallet: 1,
                wallets: []
            };
            
            window.whitelistPhases.push(phase);
            window.renderWhitelistPhases();
        };
        
        window.removeWhitelistPhase = (phaseId) => {
            window.whitelistPhases = window.whitelistPhases.filter(p => p.id !== phaseId);
            window.renderWhitelistPhases();
        };
        
        window.renderWhitelistPhases = () => {
            const container = document.getElementById('whitelistPhasesContainer');
            if (!container) return;
            
            if (window.whitelistPhases.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-8 text-gray-500 fira text-sm border-2 border-dashed border-gray-700 rounded-xl">
                        <div class="text-4xl mb-2">üìã</div>
                        <div>No phases added yet</div>
                        <div class="text-xs mt-1">Click "+ Add Phase" above to create your first whitelist phase</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = window.whitelistPhases.map((phase, index) => `
                <div class="bg-gradient-to-br from-purple-900/20 to-pink-900/20 p-5 rounded-xl border-2 border-purple-500/30 space-y-4 hover:border-purple-500/50 transition-all">
                    <!-- Phase Header -->
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <label class="block text-[9px] fira text-purple-400 uppercase font-bold mb-1">Phase Name</label>
                            <input type="text" value="${phase.name}" 
                                   onchange="window.whitelistPhases[${index}].name = this.value"
                                   class="w-full bg-black/60 border-2 border-purple-500/30 rounded-lg px-3 py-2 text-white orbitron text-sm font-bold outline-none focus:border-purple-500">
                        </div>
                        <button onclick="window.removeWhitelistPhase('${phase.id}')" 
                                class="ml-3 px-3 py-2 bg-red-500/20 border border-red-500/30 rounded-lg text-red-400 hover:bg-red-500/30 transition-all text-xs orbitron font-bold">
                            ‚úï Remove
                        </button>
                    </div>
                    
                    <!-- Pricing & Limits -->
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-[9px] fira text-gray-400 uppercase font-bold mb-2">üí∞ Price (KTA)</label>
                            <input type="number" value="${phase.priceKTA}" step="0.1" min="0"
                                   onchange="window.whitelistPhases[${index}].priceKTA = parseFloat(this.value)"
                                   class="w-full bg-black/60 border-2 border-cyan-500/30 rounded-lg px-3 py-2 text-white fira text-sm outline-none focus:border-cyan-500">
                            <p class="text-[9px] text-gray-600 mt-1">${phase.priceKTA === 0 ? 'üéÅ Free mint!' : `${phase.priceKTA} KTA per NFT`}</p>
                        </div>
                        <div>
                            <label class="block text-[9px] fira text-gray-400 uppercase font-bold mb-2">üéØ Max Mints per Wallet</label>
                            <input type="number" value="${phase.maxMintsPerWallet}" min="1" max="100"
                                   onchange="window.whitelistPhases[${index}].maxMintsPerWallet = parseInt(this.value)"
                                   class="w-full bg-black/60 border-2 border-orange-500/30 rounded-lg px-3 py-2 text-white fira text-sm outline-none focus:border-orange-500">
                            <p class="text-[9px] text-gray-600 mt-1">Each wallet can mint ${phase.maxMintsPerWallet} time${phase.maxMintsPerWallet > 1 ? 's' : ''}</p>
                        </div>
                    </div>
                    
                    <!-- Time Window (Optional) -->
                    <div class="bg-black/40 p-4 rounded-lg border border-white/5">
                        <div class="flex items-center justify-between mb-3">
                            <div class="text-[9px] fira text-gray-400 uppercase font-bold">‚è∞ Time Window (Optional)</div>
                            <div class="text-[9px] fira text-gray-500">Current: ${new Date().toLocaleString()}</div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-[9px] fira text-gray-500 mb-1">üü¢ Start Time</label>
                                <input type="datetime-local" 
                                       id="startTime_${index}"
                                       value="${phase.startTime ? new Date(phase.startTime).toISOString().slice(0, 16) : ''}"
                                       onchange="
                                           window.whitelistPhases[${index}].startTime = this.value ? new Date(this.value).toISOString() : null;
                                           console.log('‚è∞ Start time updated:', window.whitelistPhases[${index}].startTime);
                                       "
                                       class="w-full bg-black/60 border border-green-500/30 rounded px-3 py-2 text-white fira text-[11px] outline-none focus:border-green-500">
                                ${phase.startTime ? `<div class="text-[8px] text-green-400 mt-1">‚úì Set to: ${new Date(phase.startTime).toLocaleString()}</div>` : ''}
                            </div>
                            <div>
                                <label class="block text-[9px] fira text-gray-500 mb-1">üî¥ End Time</label>
                                <input type="datetime-local"
                                       id="endTime_${index}"
                                       value="${phase.endTime ? new Date(phase.endTime).toISOString().slice(0, 16) : ''}"
                                       onchange="
                                           window.whitelistPhases[${index}].endTime = this.value ? new Date(this.value).toISOString() : null;
                                           console.log('‚è∞ End time updated:', window.whitelistPhases[${index}].endTime);
                                       "
                                       class="w-full bg-black/60 border border-red-500/30 rounded px-3 py-2 text-white fira text-[11px] outline-none focus:border-red-500">
                                ${phase.endTime ? `<div class="text-[8px] text-red-400 mt-1">‚úì Set to: ${new Date(phase.endTime).toLocaleString()}</div>` : ''}
                            </div>
                        </div>
                        <p class="text-[9px] text-gray-600 mt-2">üí° Leave empty for no time restrictions</p>
                    </div>
                    
                    <!-- Wallets -->
                    <div>
                        <label class="block text-[9px] fira text-gray-400 uppercase font-bold mb-2">üë• Whitelisted Wallets</label>
                        
                        <!-- Quick Actions -->
                        <div class="grid grid-cols-2 gap-2 mb-3">
                            ${state.address ? `
                            <button 
                                onclick="
                                    const wallet = '${state.address}';
                                    if (window.whitelistPhases[${index}].wallets.includes(wallet)) {
                                        window.notify('‚ö†Ô∏è Your wallet is already whitelisted', 'error');
                                        return;
                                    }
                                    window.whitelistPhases[${index}].wallets.push(wallet);
                                    window.renderWhitelistPhases();
                                    window.notify('‚úÖ Your wallet added!', 'success');
                                "
                                class="px-3 py-3 bg-gradient-to-r from-green-600 to-emerald-600 text-white rounded-lg text-[10px] orbitron font-bold hover:from-green-500 hover:to-emerald-500 transition-all shadow-lg">
                                ‚ö° Add My Wallet
                            </button>
                            ` : '<div></div>'}
                            <button 
                                onclick="document.getElementById('bulkImport_${index}').classList.toggle('hidden')"
                                class="px-3 py-3 bg-gradient-to-r from-purple-600 to-magenta-600 text-white rounded-lg text-[10px] orbitron font-bold hover:from-purple-500 hover:to-magenta-500 transition-all shadow-lg">
                                üìã Bulk Import
                            </button>
                        </div>
                        
                        <!-- Bulk Import Panel (Hidden by default) -->
                        <div id="bulkImport_${index}" class="hidden mb-3 p-4 bg-purple-900/20 border-2 border-purple-500/30 rounded-lg">
                            <div class="mb-3">
                                <label class="block text-[9px] fira text-gray-400 uppercase font-bold mb-2">üìù Paste Wallet Addresses</label>
                                <textarea 
                                    id="bulkWallets_${index}"
                                    class="w-full bg-black/60 border-2 border-purple-500/30 rounded-lg px-3 py-3 text-white fira text-[10px] outline-none font-mono resize-none focus:border-purple-500"
                                    rows="6"
                                    placeholder="Paste wallet addresses here (one per line):
keeta_abc123...
keeta_def456...
keeta_ghi789...

Or comma-separated:
keeta_abc123..., keeta_def456..., keeta_ghi789..."
                                ></textarea>
                            </div>
                            
                            <div class="flex gap-2">
                                <button 
                                    onclick="
                                        const textarea = document.getElementById('bulkWallets_${index}');
                                        const text = textarea.value.trim();
                                        if (!text) {
                                            window.notify('‚ö†Ô∏è Paste wallet addresses first', 'error');
                                            return;
                                        }
                                        
                                        // Split by newlines OR commas
                                        let wallets = text.split(/[\\n,]+/).map(w => w.trim()).filter(Boolean);
                                        
                                        // Validate and filter
                                        const validWallets = [];
                                        const invalidWallets = [];
                                        const duplicates = [];
                                        
                                        wallets.forEach(wallet => {
                                            if (!wallet.startsWith('keeta_')) {
                                                invalidWallets.push(wallet);
                                            } else if (window.whitelistPhases[${index}].wallets.includes(wallet)) {
                                                duplicates.push(wallet);
                                            } else if (validWallets.includes(wallet)) {
                                                duplicates.push(wallet);
                                            } else {
                                                validWallets.push(wallet);
                                            }
                                        });
                                        
                                        // Add valid wallets
                                        if (validWallets.length > 0) {
                                            window.whitelistPhases[${index}].wallets.push(...validWallets);
                                            window.renderWhitelistPhases();
                                        }
                                        
                                        // Show results
                                        let message = '';
                                        if (validWallets.length > 0) message += \`‚úÖ Added \${validWallets.length} wallet\${validWallets.length > 1 ? 's' : ''}\\n\`;
                                        if (duplicates.length > 0) message += \`‚ö†Ô∏è Skipped \${duplicates.length} duplicate\${duplicates.length > 1 ? 's' : ''}\\n\`;
                                        if (invalidWallets.length > 0) message += \`‚ùå \${invalidWallets.length} invalid wallet\${invalidWallets.length > 1 ? 's' : ''}\`;
                                        
                                        window.notify(message || '‚ö†Ô∏è No valid wallets found', validWallets.length > 0 ? 'success' : 'error');
                                        
                                        if (validWallets.length > 0) {
                                            textarea.value = '';
                                            document.getElementById('bulkImport_${index}').classList.add('hidden');
                                        }
                                    "
                                    class="flex-1 px-4 py-2 bg-gradient-to-r from-green-600 to-emerald-600 text-white rounded-lg text-xs orbitron font-bold hover:from-green-500 hover:to-emerald-500 transition-all">
                                    ‚ûï Import All
                                </button>
                                <button 
                                    onclick="
                                        document.getElementById('bulkWallets_${index}').value = '';
                                        document.getElementById('bulkImport_${index}').classList.add('hidden');
                                    "
                                    class="px-4 py-2 bg-gray-600 text-white rounded-lg text-xs orbitron font-bold hover:bg-gray-500 transition-all">
                                    Cancel
                                </button>
                            </div>
                        </div>
                        
                        <!-- Single Wallet Add (Alternative) -->
                        <details class="mb-3">
                            <summary class="cursor-pointer text-[10px] text-gray-400 hover:text-gray-300 fira mb-2">+ Add single wallet manually</summary>
                            <div class="flex gap-2 mt-2">
                                <input 
                                    id="addWalletInput_${index}"
                                    type="text"
                                    placeholder="keeta_abc123..."
                                    class="flex-1 bg-black/60 border-2 border-purple-500/30 rounded-lg px-3 py-2 text-white fira text-[10px] outline-none font-mono focus:border-purple-500">
                                <button 
                                    onclick="
                                        const input = document.getElementById('addWalletInput_${index}');
                                        const wallet = input.value.trim();
                                        if (!wallet) {
                                            window.notify('‚ö†Ô∏è Enter a wallet address', 'error');
                                            return;
                                        }
                                        if (!wallet.startsWith('keeta_')) {
                                            window.notify('‚ö†Ô∏è Invalid wallet format', 'error');
                                            return;
                                        }
                                        if (window.whitelistPhases[${index}].wallets.includes(wallet)) {
                                            window.notify('‚ö†Ô∏è Wallet already added', 'error');
                                            return;
                                        }
                                        window.whitelistPhases[${index}].wallets.push(wallet);
                                        input.value = '';
                                        window.renderWhitelistPhases();
                                        window.notify('‚úÖ Wallet added!', 'success');
                                    "
                                    class="px-4 py-2 bg-purple-600 text-white rounded-lg text-xs orbitron font-bold hover:bg-purple-500 transition-all whitespace-nowrap">
                                    Add
                                </button>
                            </div>
                        </details>
                        
                        <!-- Wallet List -->
                        <div class="space-y-2 max-h-60 overflow-y-auto bg-black/40 rounded-lg p-3 border border-white/5">
                            ${phase.wallets.length === 0 ? `
                                <div class="text-center py-8 text-gray-600 fira text-[10px]">
                                    No wallets added yet.<br><br>
                                    <span class="text-purple-400">üëÜ Use "Add My Wallet" or "Bulk Import" above</span>
                                </div>
                            ` : phase.wallets.map((wallet, walletIndex) => `
                                <div class="flex items-center gap-2 bg-black/60 border border-white/5 rounded px-3 py-2 group hover:border-purple-500/30 transition-all">
                                    <span class="text-purple-400 fira text-[10px] font-bold flex-shrink-0">#${walletIndex + 1}</span>
                                    <div class="flex-1 min-w-0 overflow-x-auto scrollbar-thin scrollbar-thumb-purple-500/30 scrollbar-track-transparent">
                                        <code class="text-white fira text-[10px] font-mono whitespace-nowrap block">${wallet}</code>
                                    </div>
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <button 
                                            onclick="navigator.clipboard.writeText('${wallet}'); window.notify('üìã Copied!', 'success')"
                                            class="text-cyan-400 hover:text-cyan-300 text-xs opacity-0 group-hover:opacity-100 transition-opacity"
                                            title="Copy wallet address">
                                            üìã
                                        </button>
                                        <button 
                                            onclick="
                                                if (confirm('Remove this wallet from whitelist?')) {
                                                    window.whitelistPhases[${index}].wallets.splice(${walletIndex}, 1);
                                                    window.renderWhitelistPhases();
                                                    window.notify('üóëÔ∏è Wallet removed', 'success');
                                                }
                                            "
                                            class="text-red-400 hover:text-red-300 text-xs font-bold"
                                            title="Remove wallet">
                                            ‚úï
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <!-- Wallet Count & Actions -->
                        <div class="flex justify-between items-center mt-2">
                            <p class="text-[9px] fira ${phase.wallets.length > 0 ? 'text-green-400' : 'text-gray-600'}">
                                ${phase.wallets.length > 0 ? `‚úì ${phase.wallets.length} wallet${phase.wallets.length > 1 ? 's' : ''} whitelisted` : 'No wallets added yet'}
                            </p>
                            ${phase.wallets.length > 0 ? `
                            <div class="flex gap-2">
                                <button 
                                    onclick="navigator.clipboard.writeText('${phase.wallets.join('\\n')}'); window.notify('üìã All wallets copied!', 'success')" 
                                    class="text-xs text-cyan-400 hover:text-cyan-300">
                                    üìã Copy All
                                </button>
                                <button 
                                    onclick="
                                        if (confirm('Remove ALL ${phase.wallets.length} wallets from this phase?')) {
                                            window.whitelistPhases[${index}].wallets = [];
                                            window.renderWhitelistPhases();
                                            window.notify('üóëÔ∏è All wallets removed', 'success');
                                        }
                                    "
                                    class="text-xs text-red-400 hover:text-red-300">
                                    üóëÔ∏è Clear All
                                </button>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        };
        
        window.getActivePhaseForWallet = (collectionId, walletAddress) => {
            // Try BOTH with and without collection_ prefix (Firebase keys are inconsistent)
            const cleanCollectionId = collectionId?.replace?.(/^collection_/, '') || collectionId;
            
            console.log(`üíé getActivePhaseForWallet called:`);
            console.log(`   - Original ID: ${collectionId}`);
            console.log(`   - Clean ID: ${cleanCollectionId}`);
            console.log(`   - Wallet: ${walletAddress}`);
            console.log(`   - Settings keys:`, Object.keys(state.whitelistSettings));
            
            // Try both possible keys (with and without collection_ prefix)
            const settings = state.whitelistSettings[cleanCollectionId] || state.whitelistSettings[collectionId];
            console.log(`   - Settings found:`, settings);
            
            if (!settings?.phases || settings.phases.length === 0) {
                console.log(`üíé No phases configured for collection: ${collectionId}`);
                return null;
            }
            
            const now = Date.now();
            console.log(`üíé Checking ${settings.phases.length} phases for wallet: ${walletAddress}`);
            
            // Find active phase for this wallet
            for (const phase of settings.phases) {
                console.log(`üíé Checking phase "${phase.name}":`, {
                    priceKTA: phase.priceKTA,
                    wallets: phase.wallets,
                    startTime: phase.startTime,
                    endTime: phase.endTime
                });
                
                // Check if wallet is in this phase (case-insensitive)
                const walletInPhase = phase.wallets.some(w => 
                    w.toLowerCase().trim() === walletAddress.toLowerCase().trim()
                );
                
                if (!walletInPhase) {
                    console.log(`üíé Wallet not in phase "${phase.name}"`);
                    continue;
                }
                
                console.log(`‚úÖ Wallet found in phase "${phase.name}"`);
                
                // Check if phase is active (time-based)
                if (phase.startTime) {
                    const startTime = new Date(phase.startTime).getTime();
                    if (now < startTime) {
                        console.log(`üíé Phase "${phase.name}" hasn't started yet`);
                        continue; // Phase hasn't started
                    }
                }
                
                if (phase.endTime) {
                    const endTime = new Date(phase.endTime).getTime();
                    if (now > endTime) {
                        console.log(`üíé Phase "${phase.name}" has ended`);
                        continue; // Phase has ended
                    }
                }
                
                console.log(`‚úÖ Active phase found: "${phase.name}" with price ${phase.priceKTA} KTA`);
                return phase; // Found active phase
            }
            
            console.log(`üíé No active phase found for wallet`);
            return null; // Not in any active phase
        };

        window.saveWhitelistSettings = async () => {
            const selectedCollectionId = document.getElementById('whitelistCollectionSelector').value;
            if (!selectedCollectionId) {
                return window.notify("Please select a collection first", "error");
            }
            
            const isEnabled = document.getElementById('whitelistEnabled').checked;
            
            if (!isEnabled) {
                // If disabled, just save that it's disabled
                try {
                    const settings = {
                        collectionId: selectedCollectionId,
                        enabled: false,
                        phases: [],
                        updatedAt: new Date().toISOString()
                    };
                    
                    const settingsRef = doc(db, 'whitelistSettings', selectedCollectionId);
                    await setDoc(settingsRef, settings, { merge: true });
                    state.whitelistSettings[selectedCollectionId] = settings;
                    
                    window.notify("‚úÖ Whitelist disabled for this collection", "success");
                    
                    // Reload collections to update UI cards
                    await window.loadCollections();
                    return;
                } catch (error) {
                    console.error("Error saving whitelist settings:", error);
                    window.notify("Failed to save settings", "error");
                    return;
                }
            }
            
            // If enabled, validate phases
            if (!window.whitelistPhases || window.whitelistPhases.length === 0) {
                return window.notify("‚ö†Ô∏è Please add at least one phase with wallets", "error");
            }
            
            // Validate each phase has wallets
            const emptyPhases = window.whitelistPhases.filter(p => !p.wallets || p.wallets.length === 0);
            if (emptyPhases.length > 0) {
                return window.notify(`‚ö†Ô∏è Phase "${emptyPhases[0].name}" has no wallets. Add wallet addresses or remove the phase.`, "error");
            }
            
            try {
                const settings = {
                    collectionId: selectedCollectionId,
                    enabled: true,
                    phases: window.whitelistPhases,
                    updatedAt: new Date().toISOString()
                };
                
                console.log("üíæ Saving whitelist settings:", settings);
                console.log("üìã Phases being saved:", settings.phases);
                
                // Detailed phase logging
                settings.phases.forEach((phase, i) => {
                    console.log(`   Phase ${i + 1}: "${phase.name}"`);
                    console.log(`      Price: ${phase.priceKTA} KTA`);
                    console.log(`      Max Mints: ${phase.maxMintsPerWallet || 1}`);
                    console.log(`      Start Time: ${phase.startTime || 'No restriction'}`);
                    console.log(`      End Time: ${phase.endTime || 'No restriction'}`);
                    console.log(`      Wallets: ${phase.wallets.length}`);
                    phase.wallets.forEach(w => console.log(`         - ${w}`));
                });
                
                const settingsRef = doc(db, 'whitelistSettings', selectedCollectionId);
                await setDoc(settingsRef, settings, { merge: true });
                
                console.log(`‚úÖ Saved to Firebase: whitelistSettings/${selectedCollectionId}`);
                
                // Verify what was saved by reading it back
                const verifySnap = await getDoc(settingsRef);
                console.log(`üîç Verification - Data in Firebase:`, verifySnap.data());
                
                state.whitelistSettings[selectedCollectionId] = settings;
                
                const totalWallets = settings.phases.reduce((sum, p) => sum + p.wallets.length, 0);
                window.notify(`‚úÖ Whitelist saved!\n${settings.phases.length} phases, ${totalWallets} wallets`, "success");
                
                // Reload collections to update UI cards
                await window.loadCollections();
                
                // Refresh My Whitelists
                window.refreshMyWhitelists();
                
            } catch (error) {
                console.error("‚ùå Error saving whitelist settings:", error);
                console.error("Error details:", error.message, error.stack);
                window.notify("Failed to save settings: " + error.message, "error");
            }
        };
        
        // Render My Whitelists
        window.renderMyWhitelists = () => {
            console.log("üîç renderMyWhitelists called");
            const container = document.getElementById('myWhitelistsContainer');
            if (!container) {
                console.warn("‚ùå myWhitelistsContainer not found in DOM");
                return;
            }
            
            console.log("üìä state.collections:", state.collections?.length || 0);
            console.log("üìä state.whitelistSettings:", Object.keys(state.whitelistSettings || {}).length);
            
            // Wait for collections to be loaded
            if (!state.collections || state.collections.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-8 text-gray-600 fira text-sm">
                        Loading collections...
                    </div>
                `;
                console.log("‚è≥ Waiting for collections to load");
                return;
            }
            
            // Wait for whitelist settings to be loaded
            if (!state.whitelistSettings || Object.keys(state.whitelistSettings).length === 0) {
                container.innerHTML = `
                    <div class="text-center py-8 border-2 border-dashed border-gray-700 rounded-xl">
                        <div class="text-4xl mb-2">üìù</div>
                        <div class="text-gray-500 fira text-sm">No active whitelists yet</div>
                        <div class="text-gray-600 fira text-xs mt-1">Configure one below!</div>
                    </div>
                `;
                console.log("‚ÑπÔ∏è No whitelist settings found");
                return;
            }
            
            const activeWhitelists = Object.entries(state.whitelistSettings)
                .filter(([_, settings]) => settings.enabled)
                .map(([collectionId, settings]) => {
                    const collection = state.collections.find(c => c.collectionId === collectionId);
                    return { collectionId, settings, collection };
                })
                .filter(w => w.collection);
            
            console.log("‚úÖ Found", activeWhitelists.length, "active whitelists");
            
            if (activeWhitelists.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-8 border-2 border-dashed border-gray-700 rounded-xl">
                        <div class="text-4xl mb-2">üìù</div>
                        <div class="text-gray-500 fira text-sm">No active whitelists yet</div>
                        <div class="text-gray-600 fira text-xs mt-1">Configure one below to get started!</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = activeWhitelists.map(({ collectionId, settings, collection }) => {
                const totalWallets = settings.phases.reduce((sum, p) => sum + p.wallets.length, 0);
                const phaseCount = settings.phases.length;
                
                // Get collection image
                const collectionImage = collection.collectionThumbnailCid 
                    ? getIPFSUrl(collection.collectionThumbnailCid)
                    : (collection.ipfsCid && collection.scannedFiles?.[0]
                        ? `${getIPFSUrl(collection.ipfsCid)}/${collection.scannedFiles[0]}`
                        : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23111%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%2300ffff%22 font-size=%2240%22%3E%F0%9F%8E%A8%3C/text%3E%3C/svg%3E');
                
                return `
                    <div class="bg-gradient-to-r from-cyan-900/20 to-purple-900/20 p-5 rounded-xl border-2 border-cyan-500/30 hover:border-cyan-500/50 transition-all">
                        <div class="flex gap-4">
                            <!-- Collection Image -->
                            <div class="flex-shrink-0">
                                <img src="${collectionImage}" 
                                     class="w-20 h-20 rounded-lg object-cover border-2 border-cyan-500/30"
                                     onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23111%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%2300ffff%22 font-size=%2240%22%3E%F0%9F%8E%A8%3C/text%3E%3C/svg%3E'">
                            </div>
                            
                            <!-- Content -->
                            <div class="flex-1">
                                <div class="flex items-center gap-2 mb-1">
                                    <h5 class="orbitron text-sm text-cyan-400 font-bold">${collection.collectionTitle}</h5>
                                    <span class="bg-green-500/20 text-green-400 px-2 py-0.5 rounded text-[8px] orbitron font-bold">ACTIVE</span>
                                </div>
                                <div class="flex gap-4 mt-2">
                                    <div class="text-xs">
                                        <span class="text-gray-500 fira">Phases:</span>
                                        <span class="text-white fira font-bold ml-1">${phaseCount}</span>
                                    </div>
                                    <div class="text-xs">
                                        <span class="text-gray-500 fira">Total Wallets:</span>
                                        <span class="text-white fira font-bold ml-1">${totalWallets}</span>
                                    </div>
                                </div>
                                <div class="mt-3 space-y-1">
                                    ${settings.phases.map(phase => `
                                        <div class="flex items-center gap-2 text-[10px]">
                                            <span class="text-purple-400 orbitron font-bold">${phase.name}:</span>
                                            <span class="text-${phase.priceKTA === 0 ? 'green' : 'cyan'}-400">${phase.priceKTA === 0 ? 'üéÅ FREE' : `${phase.priceKTA} KTA`}</span>
                                            <span class="text-gray-500">‚Ä¢</span>
                                            <span class="text-gray-400">${phase.wallets.length} wallets</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <!-- Buttons -->
                            <div class="flex flex-col gap-2">
                                <button onclick="window.loadWhitelistSettings('${collectionId}'); document.getElementById('whitelistCollectionSelector').value='${collectionId}'" 
                                        class="px-3 py-2 bg-cyan-500/20 border border-cyan-500/30 rounded-lg text-cyan-400 hover:bg-cyan-500/30 transition-all text-xs orbitron font-bold">
                                    ‚úèÔ∏è Edit
                                </button>
                                <button onclick="window.cancelWhitelist('${collectionId}')" 
                                        class="px-3 py-2 bg-red-500/20 border border-red-500/30 rounded-lg text-red-400 hover:bg-red-500/30 transition-all text-xs orbitron font-bold">
                                    üóëÔ∏è Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            console.log("‚úÖ My Whitelists rendered successfully");
        };
        
        // Refresh My Whitelists
        window.refreshMyWhitelists = async () => {
            if (!db) return;
            try {
                const settingsRef = collection(db, 'whitelistSettings');
                const snapshot = await getDocs(settingsRef);
                
                state.whitelistSettings = {};
                snapshot.forEach(doc => {
                    state.whitelistSettings[doc.id] = doc.data();
                });
                
                window.renderMyWhitelists();
            } catch (error) {
                console.error("Error refreshing whitelists:", error);
            }
        };
        
        // Render Pre-Mint Collections (Forge Hub)
        window.renderPreMintCollections = () => {
            const container = document.getElementById('preMintCollectionsContainer');
            if (!container) return;
            
            // Only show for connected wallet
            if (!state.address) {
                container.innerHTML = `
                    <div class="text-center py-8 text-gray-600 fira text-xs">
                        Connect wallet to use pre-mint feature
                    </div>
                `;
                return;
            }
            
            // Filter collections created by current user that can be pre-minted
            const myPreMintableCollections = (state.collections || []).filter(col => {
                const isMyCollection = col.creator && col.creator.toLowerCase() === state.address.toLowerCase();
                const hasSupply = col.remainingSupply > 0 && col.totalSupply > 0;
                const isNotExternal = !col.isExternal; // Exclude external collections like PFP
                return isMyCollection && hasSupply && isNotExternal;
            });
            
            if (myPreMintableCollections.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-8 border-2 border-dashed border-gray-700 rounded-xl">
                        <div class="text-4xl mb-2">üîí</div>
                        <div class="text-gray-500 fira text-sm">No collections available for pre-mint</div>
                        <div class="text-gray-600 fira text-xs mt-1">Only creators can pre-mint from their collections</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = myPreMintableCollections.map(col => {
                const mintedPercent = ((col.mintedCount || 0) / col.totalSupply * 100).toFixed(0);
                const remaining = col.remainingSupply || 0;
                
                return `
                    <div class="bg-black/60 border border-purple-500/20 rounded-xl p-4 hover:border-purple-500/40 transition-all">
                        <div class="flex items-start gap-4">
                            <!-- Collection Image -->
                            <div class="w-20 h-20 rounded-lg overflow-hidden bg-black/40 border border-white/5 flex-shrink-0">
                                ${col.thumbnailCid ? 
                                    `<img src="${getIPFSUrl(col.thumbnailCid)}" 
                                         alt="${col.collectionTitle}" 
                                         class="w-full h-full object-cover">`
                                : `<div class="w-full h-full flex items-center justify-center text-gray-600 text-2xl">üé®</div>`}
                            </div>
                            
                            <!-- Collection Info -->
                            <div class="flex-1 min-w-0">
                                <div class="flex items-start justify-between gap-2 mb-2">
                                    <div class="flex-1 min-w-0">
                                        <h5 class="orbitron text-sm font-bold text-white truncate">${col.collectionTitle || 'Untitled'}</h5>
                                        <div class="flex items-center gap-2 mt-0.5">
                                            <p class="fira text-[10px] text-gray-500">${col.blindMintEnabled ? 'üé≤ Blind Mint' : 'üëÅÔ∏è Regular'}</p>
                                            <span class="text-[10px] text-purple-400 fira">‚Ä¢ You're the creator</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Progress Bar -->
                                <div class="mb-3">
                                    <div class="flex justify-between text-[9px] fira text-gray-400 mb-1">
                                        <span>Minted: ${col.mintedCount || 0}/${col.totalSupply}</span>
                                        <span>${mintedPercent}%</span>
                                    </div>
                                    <div class="w-full bg-black/60 rounded-full h-2 border border-white/5">
                                        <div class="bg-gradient-to-r from-purple-500 to-magenta-500 h-full rounded-full transition-all" 
                                             style="width: ${mintedPercent}%"></div>
                                    </div>
                                </div>
                                
                                <!-- Pre-Mint Controls -->
                                <div class="flex items-center gap-2">
                                    <div class="flex items-center gap-1 bg-black/40 border border-purple-500/30 rounded-lg px-2 py-1">
                                        <button onclick="
                                            const input = document.getElementById('preMintAmount_${col.collectionId}');
                                            const val = parseInt(input.value) || 1;
                                            if (val > 1) input.value = val - 1;
                                        " class="text-purple-400 hover:text-purple-300 text-xs px-1">‚ñº</button>
                                        <input type="number" 
                                               id="preMintAmount_${col.collectionId}" 
                                               value="1" 
                                               min="1" 
                                               max="${remaining}"
                                               class="w-12 bg-transparent text-center text-white fira text-sm font-bold outline-none">
                                        <button onclick="
                                            const input = document.getElementById('preMintAmount_${col.collectionId}');
                                            const val = parseInt(input.value) || 1;
                                            if (val < ${remaining}) input.value = val + 1;
                                        " class="text-purple-400 hover:text-purple-300 text-xs px-1">‚ñ≤</button>
                                    </div>
                                    
                                    <button onclick="window.preMintToCreator('${col.collectionId}')" 
                                            class="flex-1 px-4 py-2 bg-gradient-to-r from-purple-600 to-magenta-600 rounded-lg text-white orbitron text-xs font-bold hover:from-purple-500 hover:to-magenta-500 transition-all shadow-lg">
                                        ‚ö° Reserve ${col.blindMintEnabled ? 'Mystery' : 'NFTs'}
                                    </button>
                                </div>
                                
                                <!-- Free Reserve Toggle -->
                                <div class="flex items-center gap-2 mt-2">
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="freeReserve_${col.collectionId}" 
                                               class="w-4 h-4 accent-green-500 cursor-pointer"
                                               onchange="window.toggleFreeReserve('${col.collectionId}', this.checked)">
                                        <span class="text-[10px] fira text-green-400 font-bold">üéÅ Free Reserve (0 KTA)</span>
                                    </label>
                                    <span class="text-[9px] fira text-gray-600">Current: ${col.priceKTA || 0} KTA</span>
                                </div>
                                
                                <div class="mt-2 text-[9px] fira text-gray-500">
                                    <span class="text-purple-400">${remaining} remaining</span> ‚Ä¢ For giveaways, auctions, reserves
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        };
        
        // Toggle free reserve pricing for creator pre-mints
        window.toggleFreeReserve = async (collectionId, isFree) => {
            const collection = state.collections.find(c => c.collectionId === collectionId);
            if (!collection) return;
            
            // Store original price if not already saved
            if (isFree) {
                if (!collection._originalPriceKTA && collection._originalPriceKTA !== 0) {
                    collection._originalPriceKTA = collection.priceKTA || 0;
                }
                collection.priceKTA = 0;
                window.notify(`üéÅ Reserve price set to FREE for ${collection.collectionTitle}`, "success");
                console.log(`üéÅ Free reserve ON for ${collection.collectionTitle} (original: ${collection._originalPriceKTA} KTA)`);
            } else {
                collection.priceKTA = collection._originalPriceKTA || 0;
                window.notify(`üí∞ Reserve price restored to ${collection.priceKTA} KTA`, "info");
                console.log(`üí∞ Free reserve OFF for ${collection.collectionTitle} (restored: ${collection.priceKTA} KTA)`);
            }
        };

        // Pre-mint to creator wallet (for reserves, giveaways, auctions)
        window.preMintToCreator = async (collectionId) => {
            // PASSWORD LOCK: Require passcode punks1234
            const passcode = prompt("üîí Enter passcode to access Reserve feature:");
            if (passcode !== "punks1234") {
                window.notify("‚ùå Invalid passcode", "error");
                return;
            }
            
            const amountInput = document.getElementById(`preMintAmount_${collectionId}`);
            const amount = parseInt(amountInput?.value) || 1;
            
            if (!state.address) {
                window.notify("‚ö†Ô∏è Connect wallet first", "error");
                return;
            }
            
            const collection = state.collections.find(c => c.collectionId === collectionId);
            if (!collection) {
                window.notify("‚ùå Collection not found", "error");
                return;
            }
            
            // Check if user is the creator
            if (!collection.creator || collection.creator.toLowerCase() !== state.address.toLowerCase()) {
                window.notify("üîí Only the collection creator can reserve NFTs", "error");
                return;
            }
            
            if (amount > collection.remainingSupply) {
                window.notify(`‚ö†Ô∏è Only ${collection.remainingSupply} remaining`, "error");
                return;
            }
            
            const confirmed = await window.showCustomConfirm({
                icon: 'üéÅ',
                title: 'Reserve NFTs',
                message: `Reserve ${amount} NFT${amount > 1 ? 's' : ''} from "${collection.collectionTitle}" to your wallet?
                
These will be minted to your wallet for:
‚Ä¢ Giveaways & contests
‚Ä¢ Auctions & special sales  
‚Ä¢ Team reserves
‚Ä¢ Promotional use`,
                confirmText: `Reserve ${amount} NFT${amount > 1 ? 's' : ''}`,
                confirmColor: 'purple'
            });
            
            if (!confirmed) return;
            
            try {
                window.notify(`‚ö° Reserving ${amount} NFT${amount > 1 ? 's' : ''}...`, "info");
                
                let successCount = 0;
                let failCount = 0;
                
                // Mint NFTs one at a time
                for (let i = 0; i < amount; i++) {
                    try {
                        console.log(`üéÅ Reserving NFT ${i + 1}/${amount}...`);
                        window.notify(`‚ö° Reserving ${i + 1}/${amount}...`, "info");
                        
                        const result = await window.mintFromCollection(collectionId);
                        
                        if (result && result.success) {
                            successCount++;
                            console.log(`‚úÖ Reserved ${i + 1}/${amount} successfully`);
                        } else {
                            failCount++;
                            console.error(`‚ùå Failed to reserve ${i + 1}/${amount}:`, result?.error);
                        }
                        
                        // Short delay between mints to avoid network congestion
                        if (i < amount - 1) {
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                        
                    } catch (error) {
                        failCount++;
                        console.error(`‚ùå Error reserving ${i + 1}/${amount}:`, error);
                    }
                }
                
                // Final status
                if (successCount === amount) {
                    window.notify(`‚úÖ Reserved all ${amount} NFT${amount > 1 ? 's' : ''} successfully!`, "success");
                } else if (successCount > 0) {
                    window.notify(`‚ö†Ô∏è Reserved ${successCount}/${amount} NFTs (${failCount} failed)`, "warning");
                } else {
                    window.notify(`‚ùå Failed to reserve NFTs`, "error");
                }
                
                // Restore original price if free reserve was used
                if (collection._originalPriceKTA !== undefined) {
                    collection.priceKTA = collection._originalPriceKTA;
                    delete collection._originalPriceKTA;
                    console.log(`üí∞ Price restored to ${collection.priceKTA} KTA after reserve`);
                    // Uncheck the toggle
                    const checkbox = document.getElementById(`freeReserve_${collectionId}`);
                    if (checkbox) checkbox.checked = false;
                }
                
                // Refresh collections to show updated counts
                setTimeout(async () => {
                    await window.loadCollections();
                }, 1500);
                
            } catch (error) {
                console.error("Reserve error:", error);
                window.notify("‚ùå Reservation failed: " + error.message, "error");
            }
        };
        
        // Custom confirmation modal
        window.showCustomConfirm = (options) => {
            return new Promise((resolve) => {
                const modal = document.getElementById('customConfirmModal');
                const icon = document.getElementById('confirmModalIcon');
                const title = document.getElementById('confirmModalTitle');
                const message = document.getElementById('confirmModalMessage');
                const confirmBtn = document.getElementById('confirmModalConfirm');
                const cancelBtn = document.getElementById('confirmModalCancel');
                
                // Set content
                icon.textContent = options.icon || '‚ö†Ô∏è';
                title.textContent = options.title || 'Confirm Action';
                message.textContent = options.message || 'Are you sure you want to proceed?';
                confirmBtn.textContent = options.confirmText || 'Confirm';
                
                // Set button style based on danger level
                if (options.danger) {
                    confirmBtn.className = 'w-full py-4 rounded-xl bg-red-500/20 border-2 border-red-500/50 text-red-400 hover:bg-red-500/30 orbitron font-bold text-sm transition-all';
                } else {
                    confirmBtn.className = 'w-full py-4 rounded-xl bg-cyan-500/20 border-2 border-cyan-500/50 text-cyan-400 hover:bg-cyan-500/30 orbitron font-bold text-sm transition-all';
                }
                
                // Show modal
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                
                // Handle clicks
                const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                };
                
                const handleCancel = () => {
                    cleanup();
                    resolve(false);
                };
                
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                    }
                };
                
                const cleanup = () => {
                    modal.classList.remove('flex');
                    modal.classList.add('hidden');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    document.removeEventListener('keydown', handleEscape);
                };
                
                confirmBtn.addEventListener('click', handleConfirm);
                cancelBtn.addEventListener('click', handleCancel);
                document.addEventListener('keydown', handleEscape);
            });
        };
        
        // Cancel/Disable whitelist
        window.cancelWhitelist = async (collectionId) => {
            const collection = state.collections.find(c => c.collectionId === collectionId);
            const collectionName = collection?.collectionTitle || 'this collection';
            
            const confirmed = await window.showCustomConfirm({
                icon: 'üóëÔ∏è',
                title: 'Cancel Whitelist',
                message: `Are you sure you want to cancel the whitelist for "${collectionName}"?\n\nThis will disable whitelist access but keep the phases saved. You can re-enable it later.`,
                confirmText: 'üóëÔ∏è Yes, Cancel Whitelist',
                danger: true
            });
            
            if (!confirmed) return;
            
            try {
                const settingsRef = doc(db, 'whitelistSettings', collectionId);
                await setDoc(settingsRef, { enabled: false }, { merge: true });
                
                state.whitelistSettings[collectionId].enabled = false;
                
                window.notify("‚úÖ Whitelist cancelled and disabled", "success");
                window.refreshMyWhitelists();
                await window.loadCollections();
            } catch (error) {
                console.error("Error cancelling whitelist:", error);
                window.notify("Failed to cancel whitelist", "error");
            }
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TRANSACTION HISTORY MANAGEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Record a transaction
        window.recordTransaction = async (txData) => {
            if (!state.address) return;
            
            try {
                const transaction = {
                    id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    timestamp: new Date().toISOString(),
                    wallet: state.address,
                    type: txData.type, // 'sale', 'purchase', 'listing', 'cancellation', 'mint'
                    nftId: txData.nftId,
                    nftName: txData.nftName,
                    collection: txData.collection,
                    collectionId: txData.collectionId,
                    price: txData.price || 0,
                    currency: txData.currency || 'KTA',
                    counterParty: txData.counterParty || null,
                    txHash: txData.txHash || null,
                    status: 'completed'
                };
                
                // Save to Firebase
                await setDoc(
                    doc(db, 'transactions', transaction.id),
                    transaction
                );
                
                console.log("‚úÖ Transaction recorded:", transaction.type, transaction.txHash ? "txHash:" + transaction.txHash.substring(0, 16) + "..." : "(no hash)");
                
                // Update wallet stats (KTA spent/earned tracking)
                if (transaction.currency === 'KTA' && transaction.price > 0) {
                    await window.updateWalletStats(transaction);
                }
                
                // Real-time: refresh transaction history so new tx shows immediately
                if (typeof window.loadTransactions === 'function') {
                    await window.loadTransactions();
                }
                
            } catch (error) {
                console.error("‚ùå Error recording transaction:", error);
            }
        };
        
        // Update wallet stats for KTA tracking
        window.updateWalletStats = async (transaction) => {
            try {
                const walletStatsRef = doc(db, 'walletStats', state.address);
                const walletStatsSnap = await getDoc(walletStatsRef);
                
                let stats = walletStatsSnap.exists() ? walletStatsSnap.data() : {
                    wallet: state.address,
                    totalSpent: 0,
                    totalEarned: 0,
                    totalMinted: 0,
                    totalPurchased: 0,
                    totalSold: 0,
                    lastUpdated: new Date().toISOString()
                };
                
                // Update based on transaction type
                if (transaction.type === 'mint' || transaction.type === 'purchase') {
                    stats.totalSpent += transaction.price;
                    if (transaction.type === 'mint') stats.totalMinted++;
                    if (transaction.type === 'purchase') stats.totalPurchased++;
                } else if (transaction.type === 'sale') {
                    stats.totalEarned += transaction.price;
                    stats.totalSold++;
                }
                
                stats.lastUpdated = new Date().toISOString();
                
                await setDoc(walletStatsRef, stats);
                console.log("üìä Wallet stats updated:", stats);
                
            } catch (error) {
                console.error("‚ùå Error updating wallet stats:", error);
            }
        };
        
        // Load user transactions
        window.loadTransactions = async () => {
            if (!state.address) return;
            
            try {
                console.log("üì• Loading transaction history...");
                
                const txRef = collection(db, 'transactions');
                
                // Try with ordering first
                let snapshot;
                try {
                    const q = query(txRef, where('wallet', '==', state.address), orderBy('timestamp', 'desc'));
                    snapshot = await getDocs(q);
                } catch (indexError) {
                    // If index doesn't exist, load without ordering (will sort client-side)
                    // To create index: Firebase Console > Firestore > Indexes > Create Index
                    // Collection: transactions, Fields: wallet (Ascending), timestamp (Descending)
                    if (!indexError.message.includes('index')) {
                        console.warn("‚ö†Ô∏è Query error:", indexError.message);
                    }
                    const q = query(txRef, where('wallet', '==', state.address));
                    snapshot = await getDocs(q);
                }
                
                state.allTransactions = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                // Sort manually if we couldn't use orderBy
                state.allTransactions.sort((a, b) => {
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });
                
                state.transactions = [...state.allTransactions];
                
                console.log(`‚úÖ Loaded ${state.transactions.length} transactions`);
                
                // Render transactions
                window.renderTransactions();
                window.updateTransactionStats();
                window.renderActivityFeed();  // FIX: Also render activity feed
                
            } catch (error) {
                console.error("‚ùå Error loading transactions:", error);
                
                // Check if it's an index error
                if (error.message && error.message.includes('index')) {
                    console.warn("‚ö†Ô∏è Firebase index needed for transactions. Creating index...");
                    console.log("üìã Index URL:", error.message.match(/https:\/\/[^\s]+/)?.[0]);
                    
                    // Show empty state for now
                    state.transactions = [];
                    state.allTransactions = [];
                    window.renderTransactions();
                    
                    // Show helpful message
                    const tbody = document.getElementById('transactionsTableBody');
                    if (tbody) {
                        tbody.innerHTML = `
                            <tr>
                                <td colspan="7" class="p-12 text-center">
                                    <div class="text-yellow-400 fira text-sm mb-2">‚ö†Ô∏è Database Index Required</div>
                                    <div class="text-gray-500 fira text-xs">Transaction history needs a database index.</div>
                                    <div class="text-gray-500 fira text-xs">This is a one-time setup. Creating automatically...</div>
                                </td>
                            </tr>
                        `;
                    }
                } else {
                    state.transactions = [];
                    state.allTransactions = [];
                }
            }
        };
        
        // Render transactions table
        window.renderTransactions = () => {
            const tbody = document.getElementById('transactionsTableBody');
            if (!tbody) return;
            
            if (state.transactions.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" class="p-12 text-center">
                            <div class="text-gray-500 fira text-sm">No transactions found</div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = state.transactions.map(tx => {
                const date = new Date(tx.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                // Type badge color
                const typeBadge = {
                    'sale': '<span class="px-2 py-1 bg-green-500/20 text-green-400 rounded text-xs font-bold">SALE</span>',
                    'purchase': '<span class="px-2 py-1 bg-purple-500/20 text-purple-400 rounded text-xs font-bold">PURCHASE</span>',
                    'listing': '<span class="px-2 py-1 bg-cyan-500/20 text-cyan-400 rounded text-xs font-bold">LISTING</span>',
                    'cancellation': '<span class="px-2 py-1 bg-red-500/20 text-red-400 rounded text-xs font-bold">CANCEL</span>',
                    'mint': '<span class="px-2 py-1 bg-yellow-500/20 text-yellow-400 rounded text-xs font-bold">MINT</span>'
                }[tx.type] || '<span class="px-2 py-1 bg-gray-500/20 text-gray-400 rounded text-xs font-bold">UNKNOWN</span>';
                
                const priceDisplay = tx.price > 0 
                    ? `${tx.price} ${tx.currency}` 
                    : (tx.price === 0 && tx.type !== 'cancellation' 
                        ? `<span class="text-green-400">FREE</span>` 
                        : '‚Äî');
                const counterPartyDisplay = tx.counterParty ? tx.counterParty.substring(0, 12) + '...' : '‚Äî';
                
                // Tx hash with copy button
                const txHashDisplay = tx.txHash ? `
                    <div class="flex items-center gap-2">
                        <span class="font-mono text-xs text-cyan-400">${tx.txHash.substring(0, 16)}...</span>
                        <button onclick="navigator.clipboard.writeText('${tx.txHash}'); window.notify('Tx hash copied!', 'success')" 
                                class="text-gray-500 hover:text-cyan-400 transition-colors" 
                                title="Copy full hash">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                            </svg>
                        </button>
                    </div>
                ` : '<span class="text-gray-600">‚Äî</span>';
                
                return `
                    <tr class="border-b border-white/5 hover:bg-white/5 transition-colors">
                        <td class="p-4 fira text-xs text-gray-400">${dateStr}</td>
                        <td class="p-4">${typeBadge}</td>
                        <td class="p-4 fira text-xs text-white font-bold truncate max-w-xs">${tx.nftName || 'Unknown'}</td>
                        <td class="p-4 fira text-xs text-cyan-400 truncate max-w-xs">${tx.collection || 'Unknown'}</td>
                        <td class="p-4 fira text-xs text-green-400 font-bold">${priceDisplay}</td>
                        <td class="p-4 fira text-xs text-gray-400">${counterPartyDisplay}</td>
                        <td class="p-4">${txHashDisplay}</td>
                    </tr>
                `;
            }).join('');
        };
        
        // Update transaction stats
        window.updateTransactionStats = () => {
            const totalCount = state.transactions.length;
            const sales = state.transactions.filter(tx => tx.type === 'sale');
            const purchases = state.transactions.filter(tx => tx.type === 'purchase' || tx.type === 'mint'); // Include mints!
            const mints = state.transactions.filter(tx => tx.type === 'mint');
            
            const totalSales = sales.reduce((sum, tx) => sum + (tx.price || 0), 0);
            const totalPurchases = purchases.reduce((sum, tx) => sum + (tx.price || 0), 0); // Now includes mint prices!
            
            document.getElementById('txTotalCount').innerText = totalCount;
            document.getElementById('txTotalSales').innerText = `${totalSales.toFixed(2)} KTA`;
            document.getElementById('txTotalPurchases').innerText = `${totalPurchases.toFixed(2)} KTA`;
            document.getElementById('txTotalMints').innerText = mints.length;
            
            // Last Recorded display
            const lastEl = document.getElementById('txLastRecorded');
            if (lastEl) {
                const latest = state.allTransactions?.[0];
                if (latest?.timestamp) {
                    const d = new Date(latest.timestamp);
                    const txInfo = latest.txHash ? `${latest.txHash.substring(0, 12)}...` : latest.nftName || latest.type;
                    lastEl.innerHTML = `Last recorded: ${d.toLocaleString()} <span class="text-cyan-500/80">(${txInfo})</span>`;
                } else {
                    lastEl.innerText = totalCount > 0 ? 'Last recorded: ‚Äî' : '‚Äî';
                }
            }
        };
        
        // Filter transactions
        window.filterTransactions = () => {
            const typeFilter = document.getElementById('txTypeFilter')?.value || 'all';
            const dateFilter = document.getElementById('txDateFilter')?.value || 'all';
            const searchInput = document.getElementById('txSearchInput')?.value.toLowerCase() || '';
            
            state.transactions = state.allTransactions.filter(tx => {
                // Type filter
                if (typeFilter !== 'all' && tx.type !== typeFilter) return false;
                
                // Date filter
                if (dateFilter !== 'all') {
                    const txDate = new Date(tx.timestamp);
                    const now = new Date();
                    
                    if (dateFilter === 'today') {
                        if (txDate.toDateString() !== now.toDateString()) return false;
                    } else if (dateFilter === 'week') {
                        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        if (txDate < weekAgo) return false;
                    } else if (dateFilter === 'month') {
                        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        if (txDate < monthAgo) return false;
                    }
                }
                
                // Search filter
                if (searchInput) {
                    const searchable = `${tx.nftName} ${tx.collection}`.toLowerCase();
                    if (!searchable.includes(searchInput)) return false;
                }
                
                return true;
            });
            
            window.renderTransactions();
            window.updateTransactionStats();
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PORTFOLIO & P/L FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // P&L Currency Toggle
        window.setPnLCurrency = (currency) => {
            state.pnlCurrency = currency;
            ['KTA', 'PUNKS'].forEach(c => {
                const btn = document.getElementById(`pnlCurrency${c}`);
                if (btn) {
                    if (c === currency) {
                        btn.className = 'px-4 py-2 text-xs orbitron font-black bg-cyan-500/30 text-cyan-400 transition-all';
                    } else {
                        btn.className = 'px-4 py-2 text-xs orbitron font-black bg-black/20 text-gray-500 transition-all hover:text-white border-l border-white/10';
                    }
                }
            });
            window.calculatePortfolio();
        };

        window.calculatePortfolio = async () => {
            try {
                console.log("üíº Calculating portfolio...");
                
                const currency = state.pnlCurrency || 'KTA';
                
                if (!state.address) {
                    console.warn("No wallet connected");
                    return;
                }
                
                // Get all NFTs owned by user
                const myNFTs = state.nfts.filter(nft => nft.owner === state.address);
                
                // Calculate current portfolio value based on floor prices
                // Track KTA and PUNKS separately
                let totalValueKTA = 0;
                let totalValuePUNKS = 0;
                let totalInvestedKTA = 0;
                let totalInvestedPUNKS = 0;
                let collectionBreakdown = {};
                
                for (const nft of myNFTs) {
                    // Get collection
                    const collection = state.collections.find(c => 
                        c.collectionId === nft.collectionId || 
                        c.collectionId === nft.collection
                    );
                    
                    // Current value = listing price if listed, otherwise floor price
                    let currentValue = 0;
                    let currentCurrency = 'KTA';
                    
                    if (nft.isListed && nft.listedPrice) {
                        currentValue = nft.listedPrice;
                        currentCurrency = nft.listedCurrency || 'KTA';
                    } else if (collection && collection.floorPrice) {
                        currentValue = collection.floorPrice;
                        currentCurrency = collection.floorCurrency || 'KTA';
                    }
                    
                    // Find acquisition cost (mint or purchase)
                    const acquisitionTx = state.allTransactions.find(tx => 
                        (tx.type === 'mint' || tx.type === 'purchase') &&
                        tx.nftId === nft.id &&
                        tx.wallet === state.address
                    );
                    
                    const costBasis = acquisitionTx?.price || 0;
                    const costCurrency = acquisitionTx?.currency || 'KTA';
                    
                    // Add to appropriate currency totals
                    if (currentCurrency === 'KTA') {
                        totalValueKTA += currentValue;
                    } else {
                        totalValuePUNKS += currentValue;
                    }
                    
                    if (costCurrency === 'KTA') {
                        totalInvestedKTA += costBasis;
                    } else {
                        totalInvestedPUNKS += costBasis;
                    }
                    
                    // Track by collection (with currency)
                    const collectionName = collection?.collectionTitle || nft.collection || 'Unknown';
                    if (!collectionBreakdown[collectionName]) {
                        collectionBreakdown[collectionName] = {
                            count: 0,
                            valueKTA: 0,
                            valuePUNKS: 0,
                            investedKTA: 0,
                            investedPUNKS: 0,
                            pnlKTA: 0,
                            pnlPUNKS: 0,
                            pnlPercentKTA: 0,
                            pnlPercentPUNKS: 0
                        };
                    }
                    
                    collectionBreakdown[collectionName].count++;
                    if (currentCurrency === 'KTA') {
                        collectionBreakdown[collectionName].valueKTA += currentValue;
                    } else {
                        collectionBreakdown[collectionName].valuePUNKS += currentValue;
                    }
                    
                    if (costCurrency === 'KTA') {
                        collectionBreakdown[collectionName].investedKTA += costBasis;
                    } else {
                        collectionBreakdown[collectionName].investedPUNKS += costBasis;
                    }
                }
                
                // Calculate P/L for each collection (separate currencies)
                for (const collectionName in collectionBreakdown) {
                    const data = collectionBreakdown[collectionName];
                    data.pnlKTA = data.valueKTA - data.investedKTA;
                    data.pnlPUNKS = data.valuePUNKS - data.investedPUNKS;
                    data.pnlPercentKTA = data.investedKTA > 0 ? ((data.pnlKTA / data.investedKTA) * 100) : 0;
                    data.pnlPercentPUNKS = data.investedPUNKS > 0 ? ((data.pnlPUNKS / data.investedPUNKS) * 100) : 0;
                }
                
                // Calculate total P/L (separate currencies)
                const totalPnLKTA = totalValueKTA - totalInvestedKTA;
                const totalPnLPUNKS = totalValuePUNKS - totalInvestedPUNKS;
                const totalPnLPercentKTA = totalInvestedKTA > 0 ? ((totalPnLKTA / totalInvestedKTA) * 100) : 0;
                const totalPnLPercentPUNKS = totalInvestedPUNKS > 0 ? ((totalPnLPUNKS / totalInvestedPUNKS) * 100) : 0;
                
                // Calculate realized gains (from sales)
                // Sales can be recorded with different fields, check all possibilities
                const soldNFTs = state.allTransactions.filter(tx => {
                    if (tx.type !== 'sale') return false;
                    
                    // Check if this wallet was the seller (multiple field possibilities)
                    const isSeller = 
                        tx.seller === state.address ||
                        tx.sellerWallet === state.address ||
                        (tx.wallet === state.address && tx.type === 'sale');
                    
                    return isSeller;
                });
                
                console.log(`üìä Found ${soldNFTs.length} sales by this wallet`);
                if (soldNFTs.length > 0) {
                    console.log(`   Sample sale:`, soldNFTs[0]);
                }
                
                let realizedGainsKTA = 0;
                let realizedGainsPUNKS = 0;
                
                for (const sale of soldNFTs) {
                    const purchaseTx = state.allTransactions.find(tx => 
                        (tx.type === 'mint' || tx.type === 'purchase') &&
                        tx.nftId === sale.nftId &&
                        tx.wallet === state.address &&
                        new Date(tx.timestamp) < new Date(sale.timestamp)
                    );
                    
                    if (purchaseTx) {
                        const gain = (sale.price || 0) - (purchaseTx.price || 0);
                        if (sale.currency === 'KTA') {
                            realizedGainsKTA += gain;
                        } else if (sale.currency === 'PUNKS') {
                            realizedGainsPUNKS += gain;
                        }
                    }
                }
                
                // Find best and worst performers (KTA only for now to avoid mixing currencies)
                let bestPerformer = null;
                let worstPerformer = null;
                let bestPnL = -Infinity;
                let worstPnL = Infinity;
                
                for (const nft of myNFTs) {
                    const collection = state.collections.find(c => 
                        c.collectionId === nft.collectionId || c.collectionId === nft.collection
                    );
                    
                    let currentValue = 0;
                    let currentCurrency = 'KTA';
                    if (nft.isListed && nft.listedPrice) {
                        currentValue = nft.listedPrice;
                        currentCurrency = nft.listedCurrency || 'KTA';
                    } else if (collection?.floorPrice) {
                        currentValue = collection.floorPrice;
                        currentCurrency = collection.floorCurrency || 'KTA';
                    }
                    
                    const acquisitionTx = state.allTransactions.find(tx => 
                        (tx.type === 'mint' || tx.type === 'purchase') &&
                        tx.nftId === nft.id &&
                        tx.wallet === state.address
                    );
                    
                    const costBasis = acquisitionTx?.price || 0;
                    const costCurrency = acquisitionTx?.currency || 'KTA';
                    
                    // Only compare if same currency
                    if (currentCurrency === costCurrency) {
                        const pnl = currentValue - costBasis;
                        
                        if (pnl > bestPnL) {
                            bestPnL = pnl;
                            bestPerformer = `${nft.name} (+${pnl.toFixed(2)} ${currentCurrency})`;
                        }
                        
                        if (pnl < worstPnL) {
                            worstPnL = pnl;
                            worstPerformer = `${nft.name} (${pnl.toFixed(2)} ${currentCurrency})`;
                        }
                    }
                }
                
                // Calculate average hold time
                let totalHoldTime = 0;
                let nftsWithTime = 0;
                const now = new Date();
                
                for (const nft of myNFTs) {
                    const acquisitionTx = state.allTransactions.find(tx => 
                        (tx.type === 'mint' || tx.type === 'purchase') &&
                        tx.nftId === nft.id &&
                        tx.wallet === state.address
                    );
                    
                    if (acquisitionTx) {
                        const holdTime = now - new Date(acquisitionTx.timestamp);
                        totalHoldTime += holdTime;
                        nftsWithTime++;
                    }
                }
                
                const avgHoldTime = nftsWithTime > 0 ? totalHoldTime / nftsWithTime : 0;
                const avgHoldDays = Math.floor(avgHoldTime / (1000 * 60 * 60 * 24));
                
                // Update UI - Portfolio Tab (detailed view)
                const isKTA = currency === 'KTA';
                const displayValue = isKTA ? totalValueKTA : totalValuePUNKS;
                const displayInvested = isKTA ? totalInvestedKTA : totalInvestedPUNKS;
                const displayPnL = isKTA ? totalPnLKTA : totalPnLPUNKS;
                const displayPnLPercent = isKTA ? totalPnLPercentKTA : totalPnLPercentPUNKS;
                const displayRealized = isKTA ? realizedGainsKTA : realizedGainsPUNKS;
                const currLabel = isKTA ? 'KTA' : 'PUNKS';
                const decimals = isKTA ? 2 : 0;
                
                document.getElementById('portfolioTotalValue').textContent = `${displayValue.toFixed(decimals)} ${currLabel}`;
                const punksValueEl = document.getElementById('portfolioTotalValuePunks');
                punksValueEl.classList.add('hidden');

                document.getElementById('portfolioTotalInvested').textContent = `${displayInvested.toFixed(decimals)} ${currLabel}`;
                const punksInvestedEl = document.getElementById('portfolioTotalInvestedPunks');
                punksInvestedEl.classList.add('hidden');

                document.getElementById('portfolioTotalNFTs').textContent = myNFTs.length;
                
                // P&L
                const pnlEl = document.getElementById('portfolioPnL');
                pnlEl.textContent = `${displayPnL >= 0 ? '+' : ''}${displayPnL.toFixed(decimals)} ${currLabel}`;
                pnlEl.className = `text-2xl fira font-black ${displayPnL >= 0 ? 'text-green-400' : 'text-red-400'}`;

                const pnlPunksEl = document.getElementById('portfolioPnLPunks');
                pnlPunksEl.classList.add('hidden');

                // P&L %
                const pnlPercentEl = document.getElementById('portfolioPnLPercent');
                pnlPercentEl.textContent = `${displayPnLPercent >= 0 ? '+' : ''}${displayPnLPercent.toFixed(2)}%`;

                const pnlPercentPunksEl = document.getElementById('portfolioPnLPercentPunks');
                pnlPercentPunksEl.classList.add('hidden');

                // Realized Gains
                document.getElementById('realizedGains').textContent = `${displayRealized >= 0 ? '+' : ''}${displayRealized.toFixed(decimals)} ${currLabel}`;
                const realizedPunksEl = document.getElementById('realizedGainsPunks');
                realizedPunksEl.classList.add('hidden');
                document.getElementById('bestPerformer').textContent = bestPerformer || '‚Äî';
                document.getElementById('worstPerformer').textContent = worstPerformer || '‚Äî';
                document.getElementById('avgHoldTime').textContent = avgHoldDays > 0 ? `${avgHoldDays} days` : '‚Äî';
                
                // Update UI - Neural Vault Summary (compact view)
                document.getElementById('vaultPortfolioValue').textContent = `${displayValue.toFixed(decimals)} ${currLabel}`;
                document.getElementById('vaultPortfolioInvested').textContent = `${displayInvested.toFixed(decimals)} ${currLabel}`;
                document.getElementById('vaultPortfolioNFTs').textContent = myNFTs.length;
                
                const vaultPnlEl = document.getElementById('vaultPortfolioPnL');
                vaultPnlEl.textContent = `${displayPnL >= 0 ? '+' : ''}${displayPnL.toFixed(decimals)} ${currLabel}`;
                vaultPnlEl.className = `text-xl fira font-black ${displayPnL >= 0 ? 'text-green-400' : 'text-red-400'}`;
                
                // Render collection breakdown
                const collectionList = document.getElementById('collectionPnLList');
                if (Object.keys(collectionBreakdown).length === 0) {
                    collectionList.innerHTML = `
                        <div class="text-center py-8 text-gray-500 fira text-sm">
                            No NFTs in portfolio
                        </div>
                    `;
                } else {
                    collectionList.innerHTML = Object.entries(collectionBreakdown)
                        .sort((a, b) => (isKTA ? b[1].valueKTA - a[1].valueKTA : b[1].valuePUNKS - a[1].valuePUNKS))
                        .map(([name, data]) => {
                            const val = isKTA ? data.valueKTA : data.valuePUNKS;
                            const inv = isKTA ? data.investedKTA : data.investedPUNKS;
                            const pnl = isKTA ? data.pnlKTA : data.pnlPUNKS;
                            const pnlPct = isKTA ? data.pnlPercentKTA : data.pnlPercentPUNKS;
                            const pnlIcon = pnl >= 0 ? 'üìà' : 'üìâ';
                            
                            return `
                                <div class="bg-black/20 p-4 rounded-lg border border-white/5 hover:border-cyan-500/30 transition-all">
                                    <div class="flex justify-between items-center mb-2">
                                        <div class="fira text-sm font-bold text-white">${name}</div>
                                        <div class="text-lg">${pnlIcon}</div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-3 text-xs">
                                        <div>
                                            <div class="text-gray-500">NFTs Owned</div>
                                            <div class="text-cyan-400 font-bold">${data.count}</div>
                                        </div>
                                        <div>
                                            <div class="text-gray-500">Current Value</div>
                                            <div class="text-white font-bold">${val.toFixed(decimals)} ${currLabel}</div>
                                        </div>
                                        <div>
                                            <div class="text-gray-500">Invested</div>
                                            <div class="text-purple-400 font-bold">${inv.toFixed(decimals)} ${currLabel}</div>
                                        </div>
                                        <div>
                                            <div class="text-gray-500">P/L</div>
                                            <div class="font-bold ${pnl >= 0 ? 'text-green-400' : 'text-red-400'}">${pnl >= 0 ? '+' : ''}${pnl.toFixed(decimals)} ${currLabel} (${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(1)}%)</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                }
                
                console.log("‚úÖ Portfolio calculated:", {
                    totalValueKTA, totalValuePUNKS,
                    totalInvestedKTA, totalInvestedPUNKS,
                    totalPnLKTA, totalPnLPUNKS,
                    realizedGainsKTA, realizedGainsPUNKS,
                    collections: Object.keys(collectionBreakdown).length
                });
                
            } catch (error) {
                console.error("‚ùå Error calculating portfolio:", error);
                window.notify("Failed to calculate portfolio", "error");
            }
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WHITELIST MANAGEMENT FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.toggleWhitelistUI = () => {
            const enabled = document.getElementById('enableWhitelist')?.checked || false;
            const container = document.getElementById('whitelistInputContainer');
            
            if (container) {
                if (enabled) {
                    container.classList.remove('hidden');
                } else {
                    container.classList.add('hidden');
                }
            }
        };
        
        window.updateWhitelistCount = () => {
            const textarea = document.getElementById('whitelistAddresses');
            if (!textarea) return;
            
            const addresses = textarea.value.split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr.length > 0);
            
            document.getElementById('whitelistCount').innerText = `${addresses.length} address${addresses.length !== 1 ? 'es' : ''}`;
        };
        
        window.validateWhitelist = () => {
            const textarea = document.getElementById('whitelistAddresses');
            if (!textarea) return;
            
            const addresses = textarea.value.split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr.length > 0);
            
            if (addresses.length === 0) {
                window.showWhitelistStatus('No addresses to validate', 'error');
                return;
            }
            
            const validAddresses = [];
            const invalidAddresses = [];
            
            addresses.forEach((addr, index) => {
                // Validate Keeta address format (starts with keeta_ and has proper length)
                if (addr.startsWith('keeta_') && addr.length > 20) {
                    validAddresses.push(addr);
                } else {
                    invalidAddresses.push(`Line ${index + 1}: ${addr.substring(0, 30)}...`);
                }
            });
            
            if (invalidAddresses.length > 0) {
                window.showWhitelistStatus(
                    `‚ö†Ô∏è Found ${invalidAddresses.length} invalid address(es):\n${invalidAddresses.slice(0, 5).join('\n')}${invalidAddresses.length > 5 ? '\n...' : ''}`, 
                    'error'
                );
            } else {
                window.showWhitelistStatus(
                    `‚úì All ${validAddresses.length} addresses are valid!`, 
                    'success'
                );
            }
        };
        
        window.showWhitelistStatus = (message, type) => {
            const statusEl = document.getElementById('whitelistStatus');
            if (!statusEl) return;
            
            statusEl.classList.remove('hidden');
            statusEl.className = 'p-3 rounded-lg border';
            
            if (type === 'success') {
                statusEl.classList.add('border-green-500/50', 'bg-green-500/10', 'text-green-400');
            } else {
                statusEl.classList.add('border-red-500/50', 'bg-red-500/10', 'text-red-400');
            }
            
            statusEl.innerHTML = `<div class="fira text-xs whitespace-pre-wrap">${message}</div>`;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusEl.classList.add('hidden');
            }, 5000);
        };
        
        window.clearWhitelist = () => {
            const textarea = document.getElementById('whitelistAddresses');
            if (textarea) {
                textarea.value = '';
                window.updateWhitelistCount();
                window.showWhitelistStatus('Whitelist cleared', 'success');
            }
        };
        
        window.importWhitelistCSV = () => {
            // Create file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv,.txt';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const addresses = text.split(/[\n,]/)
                        .map(addr => addr.trim())
                        .filter(addr => addr.startsWith('keeta_'));
                    
                    const textarea = document.getElementById('whitelistAddresses');
                    if (textarea) {
                        textarea.value = addresses.join('\n');
                        window.updateWhitelistCount();
                        window.showWhitelistStatus(`Imported ${addresses.length} addresses from CSV`, 'success');
                    }
                } catch (error) {
                    window.showWhitelistStatus('Failed to import CSV: ' + error.message, 'error');
                }
            };
            
            input.click();
        };
        
        window.getWhitelistAddresses = () => {
            const enabled = document.getElementById('enableWhitelist')?.checked || false;
            if (!enabled) return [];
            
            const textarea = document.getElementById('whitelistAddresses');
            if (!textarea) return [];
            
            return textarea.value.split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr.startsWith('keeta_') && addr.length > 20);
        };
        window.prepWipe = () => { document.getElementById('wipeStage1')?.classList.add('hidden'); document.getElementById('wipeStage2')?.classList.remove('hidden'); };
        window.resetWipe = () => { document.getElementById('wipeStage1')?.classList.remove('hidden'); document.getElementById('wipeStage2')?.classList.add('hidden'); };

        window.clearAllNFTs = async () => {
            if (!confirm("WARNING: Delete ALL NFTs, Collections, Traits? Continue?")) return;
            try {
                const nftsRef = collection(db, 'nfts');
                const nftsSnap = await getDocs(nftsRef);
                for (const document of nftsSnap.docs) await deleteDoc(document.ref);
                
                const colRef = collection(db, 'collections');
                const colSnap = await getDocs(colRef);
                for (const document of colSnap.docs) await deleteDoc(document.ref);
                
                const traitRef = collection(db, 'traitCounts');
                const traitSnap = await getDocs(traitRef);
                for (const document of traitSnap.docs) await deleteDoc(document.ref);
                
                const trackRef = collection(db, 'walletMintTracking');
                const trackSnap = await getDocs(trackRef);
                for (const document of trackSnap.docs) await deleteDoc(document.ref);
                
                const total = nftsSnap.docs.length + colSnap.docs.length + traitSnap.docs.length + trackSnap.docs.length;
                window.notify(`Purged ${total} records`, "success");
                
                await window.loadNFTsFromFirebase();
                await window.loadCollections();
                await window.loadTraitCounts();
                
                // Start auto-sync for wallet changes
                window.startAutoSync();
                window.resetWipe();
            } catch (error) {
                console.error("Wipe error:", error);
                window.notify("Purge failed: " + error.message, "error");
            }
        };

        async function initializeEscrowWallet() {
            try {
                console.log("üîê Initializing escrow (SECURE MODE - server-side signing)...");
                
                // SECURITY: No seed phrase in client. 
                // Escrow address is public and hardcoded (same as MARKETPLACE_FEE_WALLET)
                state.escrowAddress = ESCROW_ADDRESS;
                
                // escrowClient and escrowAccount are NO LONGER needed client-side
                // All escrow signing operations go through Cloud Functions:
                // - processNFTPurchase: releases NFT to buyer
                // - returnFromEscrow: returns NFT to seller
                state.escrowClient = null;
                state.escrowAccount = null;
                
                console.log("‚úÖ Escrow address set:", state.escrowAddress);
                console.log("üîí Escrow signing is SERVER-SIDE via Cloud Functions");
                
                // Check escrow balance via Cloud Function
                try {
                    const result = await window.getEscrowBalance();
                    if (result.data && result.data.success) {
                        state.escrowBalance = result.data.balance || 0;
                        console.log(`üí∞ Escrow wallet balance: ${state.escrowBalance.toFixed(4)} KTA`);
                        
                        // DIAGNOSTIC: Check if Cloud Function derives the correct address
                        if (result.data.address) {
                            console.log(`üîë Cloud Function derived address: ${result.data.address}`);
                            console.log(`üîë Expected escrow address:        ${ESCROW_ADDRESS}`);
                            if (result.data.addressMatch === false || result.data.address !== ESCROW_ADDRESS) {
                                console.error(`‚ùå ESCROW ADDRESS MISMATCH! Cloud Function wallet ‚â† Escrow wallet`);
                                console.error(`   Cloud Function derives: ${result.data.address}`);
                                console.error(`   NFTs are sent to:       ${ESCROW_ADDRESS}`);
                                console.error(`   FIX: Run 'firebase functions:secrets:set ESCROW_SEED' with correct seed`);
                            } else {
                                console.log(`‚úÖ ESCROW ADDRESS MATCH CONFIRMED - Cloud Functions can sign for escrow wallet`);
                            }
                        }
                        if (result.data.nftCount !== undefined) {
                            console.log(`üì¶ Escrow wallet holds ${result.data.nftCount} NFTs`);
                        }
                        
                        if (state.escrowBalance < 1) {
                            console.warn("‚ö†Ô∏è WARNING: Escrow wallet has low balance!");
                            console.warn("‚ö†Ô∏è Send KTA to:", state.escrowAddress);
                        }
                    }
                } catch (balError) {
                    console.warn("Could not check escrow balance via Cloud Function:", balError.message);
                    // Non-fatal ‚Äî balance check is informational only
                }
                
                return true;
            } catch (error) {
                console.error("‚ùå Escrow initialization failed:", error);
                return false;
            }
        }

        async function initializeMarketplace() {
            console.log("üöÄ Initializing PunkSwap Marketplace...");
            
            // TEST: Check if storage is working
            try {
                sessionStorage.setItem('test_key', 'test_value');
                const testValue = sessionStorage.getItem('test_key');
                if (testValue === 'test_value') {
                    console.log("‚úÖ sessionStorage is WORKING");
                    sessionStorage.removeItem('test_key');
                } else {
                    console.error("‚ùå sessionStorage BROKEN - can't retrieve saved data");
                }
            } catch (e) {
                console.error("‚ùå sessionStorage BLOCKED:", e.message);
            }
            
            // Initialize Firebase first
            const firebaseOk = await testFirebaseConnection();
            if (firebaseOk) {
                state.firebaseReady = true;
                
                // Load data in parallel for speed
                await Promise.all([
                    window.loadNFTsFromFirebase(),
                    window.loadCollections(),
                    window.loadTraitCounts(),
                    window.refreshMyWhitelists()
                ]);
                
                // Recalculate trait counts for all collections to ensure rarity is accurate
                console.log("üîÑ Calculating trait counts for all collections...");
                for (const collection of state.collections) {
                    try {
                        await window.calculateAndSaveTraitCounts(collection.collectionToken || collection.collectionId);
                    } catch (e) {
                        console.warn(`‚ö†Ô∏è Failed to calculate traits for ${collection.collectionTitle}:`, e);
                    }
                }
                await window.loadTraitCounts();
                console.log("‚úÖ All trait counts loaded");
                
                // Setup listeners
                window.setupNFTListener();
                
                // Initialize activity feed
                window.initActivityFeed();
            }
            
            // Initialize escrow
            await initializeEscrowWallet();
            
            // Restore last viewed tab or default to market
            const savedTab = sessionStorage.getItem('punkswap_current_tab') || 'market';
            // Only restore tabs that make sense after refresh (not collection-view which needs state)
            const restorableTabs = ['market', 'collection', 'transactions', 'portfolio', 'offers', 'all-collections', 'activity', 'admin', 'escrow-admin'];
            const tabToRestore = restorableTabs.includes(savedTab) ? savedTab : 'market';
            window.switchTab(tabToRestore);
            
            // CRITICAL FIX: Force chart initialization immediately
            console.log("üìä Initializing market chart...");
            
            // Populate collection selector first
            window.populateChartSelector();
            
            // Initialize the chart RIGHT NOW (no delay)
            await window.initFloorPulseChart();
            
            // Start real-time updates
            window.startChartAutoUpdate();
            
            console.log("‚úÖ PunkSwap fully initialized with charts active");
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ESCROW STATS DASHBOARD
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Store all escrow transactions for filtering
        window._escrowTxData = [];
        
        window.loadEscrowStats = async () => {
            try {
                console.log("üìä Loading escrow stats...");
                
                // Load ALL transactions from Firebase
                const txRef = collection(db, 'transactions');
                const snapshot = await getDocs(txRef);
                const allTx = [];
                snapshot.forEach(d => allTx.push({ id: d.id, ...d.data() }));
                
                // Sort by date descending
                allTx.sort((a, b) => {
                    const da = new Date(a.timestamp || a.createdAt || 0);
                    const db2 = new Date(b.timestamp || b.createdAt || 0);
                    return db2 - da;
                });
                
                window._escrowTxData = allTx;
                
                // Calculate stats - track KTA and PUNKS separately
                let ktaVolume = 0, ktaFees = 0, ktaRoyalties = 0;
                let punksVolume = 0, punksFees = 0, punksRoyalties = 0;
                let primaryCountKTA = 0, primaryCountPUNKS = 0;
                let primaryKTA = 0, primaryPUNKS = 0, primaryFeesKTA = 0, primaryFeesPUNKS = 0, primaryCreatorKTA = 0, primaryCreatorPUNKS = 0;
                let secondaryCountKTA = 0, secondaryCountPUNKS = 0;
                let secondaryKTA = 0, secondaryPUNKS = 0, secondaryFeesKTA = 0, secondaryFeesPUNKS = 0, secondaryRoyaltiesKTA = 0, secondaryRoyaltiesPUNKS = 0, secondarySellerKTA = 0, secondarySellerPUNKS = 0;
                let totalSales = 0;
                
                allTx.forEach(tx => {
                    const price = parseFloat(tx.price || tx.amount || 0);
                    const currency = (tx.currency || tx.priceCurrency || 'KTA').toUpperCase();
                    if (price <= 0) return;
                    if (currency !== 'KTA' && currency !== 'PUNKS') return;
                    
                    const isKTA = currency === 'KTA';
                    const isPrimary = tx.type === 'mint' || tx.type === 'primary' || tx.isPrimary === true;
                    const isSale = tx.type === 'sale' || tx.type === 'purchase' || tx.type === 'secondary';
                    
                    if (!isPrimary && !isSale) return;
                    totalSales++;
                    
                    if (isPrimary) {
                        const fee = price * PRIMARY_SALE_MARKETPLACE_PERCENT;
                        const creator = price * PRIMARY_SALE_CREATOR_PERCENT;
                        if (isKTA) {
                            primaryCountKTA++;
                            primaryKTA += price; primaryFeesKTA += fee; primaryCreatorKTA += creator;
                            ktaVolume += price; ktaFees += fee;
                        } else {
                            primaryCountPUNKS++;
                            primaryPUNKS += price; primaryFeesPUNKS += fee; primaryCreatorPUNKS += creator;
                            punksVolume += price; punksFees += fee;
                        }
                    } else if (isSale) {
                        const fee = price * SECONDARY_SALE_MARKETPLACE_PERCENT;
                        const royalty = price * SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
                        const sellerAmt = price * SECONDARY_SALE_SELLER_PERCENT;
                        if (isKTA) {
                            secondaryCountKTA++;
                            secondaryKTA += price; secondaryFeesKTA += fee; secondaryRoyaltiesKTA += royalty; secondarySellerKTA += sellerAmt;
                            ktaVolume += price; ktaFees += fee; ktaRoyalties += royalty;
                        } else {
                            secondaryCountPUNKS++;
                            secondaryPUNKS += price; secondaryFeesPUNKS += fee; secondaryRoyaltiesPUNKS += royalty; secondarySellerPUNKS += sellerAmt;
                            punksVolume += price; punksFees += fee; punksRoyalties += royalty;
                        }
                    }
                });
                
                const fmt = (val, currency) => val > 0 ? `${val.toFixed(4)} ${currency}` : `0 ${currency}`;
                
                // Update summary cards
                document.getElementById('escrowTotalSales').textContent = totalSales;
                document.getElementById('escrowTotalVolumeKTA').textContent = fmt(ktaVolume, 'KTA');
                document.getElementById('escrowTotalVolumePUNKS').textContent = fmt(punksVolume, 'PUNKS');
                document.getElementById('escrowTotalFeesKTA').textContent = fmt(ktaFees, 'KTA');
                document.getElementById('escrowTotalFeesPUNKS').textContent = fmt(punksFees, 'PUNKS');
                
                // Escrow balances
                try {
                    document.getElementById('escrowBalanceKTA').textContent = fmt(parseFloat(state.balanceKTA || 0), 'KTA');
                    document.getElementById('escrowBalancePUNKS').textContent = fmt(parseFloat(state.balancePunks || 0), 'PUNKS');
                    if (!state.balanceKTA && !state.balancePunks) {
                        const balResult = await window.getEscrowBalance();
                        document.getElementById('escrowBalanceKTA').textContent = fmt(parseFloat(balResult?.data?.balance || 0), 'KTA');
                    }
                } catch(e) {
                    document.getElementById('escrowBalanceKTA').textContent = 'N/A';
                    document.getElementById('escrowBalancePUNKS').textContent = 'N/A';
                }
                
                // KTA Primary breakdown
                document.getElementById('escrowPrimaryCountKTA').textContent = primaryCountKTA;
                document.getElementById('escrowPrimaryVolumeKTA').textContent = fmt(primaryKTA, 'KTA');
                document.getElementById('escrowPrimaryFeesKTA').textContent = fmt(primaryFeesKTA, 'KTA');
                document.getElementById('escrowPrimaryCreatorKTA').textContent = fmt(primaryCreatorKTA, 'KTA');
                
                // KTA Secondary breakdown
                document.getElementById('escrowSecondaryCountKTA').textContent = secondaryCountKTA;
                document.getElementById('escrowSecondaryVolumeKTA').textContent = fmt(secondaryKTA, 'KTA');
                document.getElementById('escrowSecondaryFeesKTA').textContent = fmt(secondaryFeesKTA, 'KTA');
                document.getElementById('escrowSecondaryRoyaltiesKTA').textContent = fmt(secondaryRoyaltiesKTA, 'KTA');
                document.getElementById('escrowSecondarySellerKTA').textContent = fmt(secondarySellerKTA, 'KTA');
                
                // PUNKS Primary breakdown
                document.getElementById('escrowPrimaryCountPUNKS').textContent = primaryCountPUNKS;
                document.getElementById('escrowPrimaryVolumePUNKS').textContent = fmt(primaryPUNKS, 'PUNKS');
                document.getElementById('escrowPrimaryFeesPUNKS').textContent = fmt(primaryFeesPUNKS, 'PUNKS');
                document.getElementById('escrowPrimaryCreatorPUNKS').textContent = fmt(primaryCreatorPUNKS, 'PUNKS');
                
                // PUNKS Secondary breakdown
                document.getElementById('escrowSecondaryCountPUNKS').textContent = secondaryCountPUNKS;
                document.getElementById('escrowSecondaryVolumePUNKS').textContent = fmt(secondaryPUNKS, 'PUNKS');
                document.getElementById('escrowSecondaryFeesPUNKS').textContent = fmt(secondaryFeesPUNKS, 'PUNKS');
                document.getElementById('escrowSecondaryRoyaltiesPUNKS').textContent = fmt(secondaryRoyaltiesPUNKS, 'PUNKS');
                document.getElementById('escrowSecondarySellerPUNKS').textContent = fmt(secondarySellerPUNKS, 'PUNKS');
                
                // Render transaction table
                window.filterEscrowTx();
                
                console.log(`‚úÖ Escrow stats loaded: ${totalSales} sales (KTA: ${primaryCountKTA+secondaryCountKTA}, PUNKS: ${primaryCountPUNKS+secondaryCountPUNKS}), KTA vol: ${ktaVolume.toFixed(4)}, PUNKS vol: ${punksVolume.toFixed(4)}`);
                
            } catch (err) {
                console.error("‚ùå Failed to load escrow stats:", err);
                window.notify("Failed to load escrow stats", "error");
            }
        };
        
        window.filterEscrowTx = () => {
            const filter = document.getElementById('escrowTxFilter')?.value || 'all';
            const tbody = document.getElementById('escrowTxBody');
            if (!tbody) return;
            
            let filtered = window._escrowTxData || [];
            if (filter === 'primary') filtered = filtered.filter(tx => tx.type === 'mint' || tx.type === 'primary');
            if (filter === 'secondary') filtered = filtered.filter(tx => tx.type === 'sale' || tx.type === 'purchase' || tx.type === 'secondary');
            if (filter === 'listing') filtered = filtered.filter(tx => tx.type === 'listing');
            if (filter === 'cancellation') filtered = filtered.filter(tx => tx.type === 'cancellation');
            
            const countEl = document.getElementById('escrowTxCount');
            if (countEl) countEl.textContent = `${filtered.length} of ${(window._escrowTxData || []).length} records`;
            
            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="12" class="p-8 text-center text-gray-600">No transactions found</td></tr>';
                return;
            }
            
            const shortAddr = (addr) => addr ? addr.substring(0, 10) + '...' + addr.slice(-4) : '-';
            const shortHash = (hash) => {
                if (!hash) return '-';
                if (hash.startsWith('listing_') || hash.startsWith('offer_') || hash.startsWith('mint_')) return hash;
                return hash.substring(0, 12) + '...';
            };
            
            tbody.innerHTML = filtered.map(tx => {
                const price = parseFloat(tx.price || tx.amount || 0);
                const currency = tx.currency || tx.priceCurrency || 'KTA';
                const txType = tx.type || 'unknown';
                const isPrimary = txType === 'mint' || txType === 'primary';
                const isListing = txType === 'listing';
                const isCancel = txType === 'cancellation';
                const isSale = txType === 'sale' || txType === 'purchase' || txType === 'secondary';
                
                let mktFee = 0, royalty = 0, sellerGot = 0;
                if (tx.marketplaceFee !== undefined) {
                    mktFee = parseFloat(tx.marketplaceFee);
                    royalty = parseFloat(tx.creatorRoyalty || 0);
                    sellerGot = parseFloat(tx.sellerPayout || 0);
                } else if (isPrimary && price > 0) {
                    mktFee = price * PRIMARY_SALE_MARKETPLACE_PERCENT;
                    sellerGot = price * PRIMARY_SALE_CREATOR_PERCENT;
                } else if (isSale && price > 0) {
                    mktFee = price * SECONDARY_SALE_MARKETPLACE_PERCENT;
                    royalty = price * SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
                    sellerGot = price * SECONDARY_SALE_SELLER_PERCENT;
                }
                
                const date = tx.timestamp || tx.createdAt || '';
                const dateStr = date ? new Date(date).toLocaleDateString() + ' ' + new Date(date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : 'N/A';
                
                let typeBadge = '';
                if (isPrimary) typeBadge = '<span class="px-2 py-0.5 rounded text-[8px] font-bold bg-cyan-500/20 text-cyan-400">MINT</span>';
                else if (txType === 'purchase') typeBadge = '<span class="px-2 py-0.5 rounded text-[8px] font-bold bg-green-500/20 text-green-400">BUY</span>';
                else if (txType === 'sale') typeBadge = '<span class="px-2 py-0.5 rounded text-[8px] font-bold bg-purple-500/20 text-purple-400">SALE</span>';
                else if (isListing) typeBadge = '<span class="px-2 py-0.5 rounded text-[8px] font-bold bg-yellow-500/20 text-yellow-400">LIST</span>';
                else if (isCancel) typeBadge = '<span class="px-2 py-0.5 rounded text-[8px] font-bold bg-red-500/20 text-red-400">CANCEL</span>';
                else typeBadge = '<span class="px-2 py-0.5 rounded text-[8px] font-bold bg-gray-500/20 text-gray-400">' + txType.toUpperCase() + '</span>';
                
                const status = tx.status || 'unknown';
                const inEscrow = tx.inEscrow ? ' üîí' : '';
                let statusBadge = '';
                if (status === 'completed') statusBadge = '<span class="text-green-400 text-[8px]">‚úÖ Done' + inEscrow + '</span>';
                else if (status === 'listed') statusBadge = '<span class="text-yellow-400 text-[8px]">üìã Listed' + inEscrow + '</span>';
                else if (status === 'cancelled') statusBadge = '<span class="text-red-400 text-[8px]">‚ùå Cancelled</span>';
                else if (status === 'pending') statusBadge = '<span class="text-orange-400 text-[8px] animate-pulse">‚è≥ Pending</span>';
                else statusBadge = '<span class="text-gray-500 text-[8px]">' + status + '</span>';
                
                const buyer = tx.counterParty || tx.buyer || (txType === 'purchase' ? tx.wallet : null);
                const seller = tx.sellerWallet || tx.seller || tx.creator || (txType === 'sale' || txType === 'listing' ? tx.wallet : null);
                const txHash = tx.txHash || tx.transactionHash || '';
                
                return '<tr class="hover:bg-white/5 transition-colors text-[10px]">' +
                    '<td class="p-2 text-gray-400 whitespace-nowrap">' + dateStr + '</td>' +
                    '<td class="p-2">' + typeBadge + '</td>' +
                    '<td class="p-2">' + statusBadge + '</td>' +
                    '<td class="p-2 text-white font-bold truncate max-w-[100px]" title="' + (tx.nftName || '') + ' (' + (tx.nftId || '') + ')">' + (tx.nftName || (tx.nftId ? tx.nftId.substring(0,15) : '-')) + '</td>' +
                    '<td class="p-2 text-gray-400 truncate max-w-[80px]" title="' + (tx.collection || tx.collectionTitle || '') + '">' + (tx.collection || tx.collectionTitle || '-') + '</td>' +
                    '<td class="p-2 text-right text-white font-bold">' + (price > 0 ? price.toFixed(2) + ' ' + currency : '-') + '</td>' +
                    '<td class="p-2 text-right text-green-400">' + (mktFee > 0 ? mktFee.toFixed(4) : '-') + '</td>' +
                    '<td class="p-2 text-right text-purple-400">' + (royalty > 0 ? royalty.toFixed(4) : '-') + '</td>' +
                    '<td class="p-2 text-right text-cyan-400">' + (sellerGot > 0 ? sellerGot.toFixed(4) : '-') + '</td>' +
                    '<td class="p-2 text-gray-500" title="' + (buyer || '') + '">' + shortAddr(buyer) + '</td>' +
                    '<td class="p-2 text-gray-500" title="' + (seller || '') + '">' + shortAddr(seller) + '</td>' +
                    '<td class="p-2 text-gray-600 font-mono" title="' + txHash + '"><span class="cursor-pointer hover:text-cyan-400" onclick="navigator.clipboard.writeText(\'' + txHash + '\'); window.notify(\'TX hash copied!\',\'success\')">' + shortHash(txHash) + '</span></td>' +
                '</tr>';
            }).join('');
        };
        
        window.exportEscrowCSV = () => {
            const data = window._escrowTxData || [];
            if (data.length === 0) return window.notify("No data to export. Click Refresh first.", "warning");
            
            const headers = ['Date','Type','Status','NFT Name','NFT ID','Collection','Collection ID','Price','Currency','Marketplace Fee','Creator Royalty','Seller Payout','Buyer Wallet','Seller Wallet','Counter Party','In Escrow','TX Hash','Transaction ID'];
            const rows = data.map(tx => {
                const price = parseFloat(tx.price || tx.amount || 0);
                const txType = tx.type || 'unknown';
                const isPrimary = txType === 'mint' || txType === 'primary';
                const isSale = txType === 'sale' || txType === 'purchase' || txType === 'secondary';
                let mktFee = 0, royalty = 0, sellerGot = 0;
                if (tx.marketplaceFee !== undefined) {
                    mktFee = parseFloat(tx.marketplaceFee);
                    royalty = parseFloat(tx.creatorRoyalty || 0);
                    sellerGot = parseFloat(tx.sellerPayout || 0);
                } else if (isPrimary && price > 0) {
                    mktFee = price * PRIMARY_SALE_MARKETPLACE_PERCENT;
                    sellerGot = price * PRIMARY_SALE_CREATOR_PERCENT;
                } else if (isSale && price > 0) {
                    mktFee = price * SECONDARY_SALE_MARKETPLACE_PERCENT;
                    royalty = price * SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
                    sellerGot = price * SECONDARY_SALE_SELLER_PERCENT;
                }
                const date = tx.timestamp || tx.createdAt || '';
                const buyer = tx.counterParty || tx.buyer || (txType === 'purchase' ? tx.wallet : '');
                const seller = tx.sellerWallet || tx.seller || tx.creator || (txType === 'sale' || txType === 'listing' ? tx.wallet : '');
                const esc = (v) => (v || '').toString().replace(/,/g, ' ').replace(/"/g, "'");
                return [
                    date ? new Date(date).toISOString() : '',
                    txType,
                    tx.status || '',
                    esc(tx.nftName || tx.nftId),
                    esc(tx.nftId),
                    esc(tx.collection || tx.collectionTitle),
                    esc(tx.collectionId),
                    price.toFixed(4),
                    tx.currency || tx.priceCurrency || 'KTA',
                    mktFee.toFixed(4),
                    royalty.toFixed(4),
                    sellerGot.toFixed(4),
                    buyer,
                    seller,
                    tx.counterParty || '',
                    tx.inEscrow ? 'YES' : 'NO',
                    tx.txHash || tx.transactionHash || '',
                    tx.id || ''
                ].join(',');
            });
            
            const csv = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `punkswap_escrow_stats_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            window.notify("‚úÖ CSV exported!", "success");
        };

        // FIX #4: Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Verify critical functions are defined
            const criticalFunctions = ['initNeuralLink', 'importWallet', 'mintFromCollection', 'buyNFT'];
            criticalFunctions.forEach(funcName => {
                if (typeof window[funcName] !== 'function') {
                    console.error(`‚ùå Critical function missing: ${funcName}`);
                } else {
                    console.log(`‚úÖ Function verified: ${funcName}`);
                }
            });
            
            const priceInput = document.getElementById('listingPriceInput');
            if (priceInput) priceInput.addEventListener('input', window.updateFeeBreakdown);
            const currencyInputs = document.querySelectorAll('input[name="listingCurrency"]');
            currencyInputs.forEach(input => input.addEventListener('change', window.updateFeeBreakdown));
            
            // Setup verification panel
            window.setupVerificationPanel();
            
            // FIX #6: ULTRA-SAFE Auto-restore - Wait for KeetaNet AND strict validation
            setTimeout(async () => {
                try {
                    console.log("üîÑ Checking for saved wallet session...");
                    
                    // CRITICAL: Wait for KeetaNet library to load first
                    let attempts = 0;
                    while (typeof KeetaNet === 'undefined' && attempts < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                    
                    if (typeof KeetaNet === 'undefined') {
                        console.error("‚ùå KeetaNet library failed to load after 5 seconds");
                        return;
                    }
                    
                    console.log("‚úÖ KeetaNet library loaded successfully");
                    
                    let savedSeed = (sessionStorage.getItem('punkswap_wallet_seed') || '').trim();
                    
                    // If sessionStorage failed, try localStorage backup
                    if (!savedSeed) {
                        savedSeed = (localStorage.getItem('punkswap_wallet_seed_backup') || '').trim();
                        if (savedSeed) {
                            console.log("üíæ Found wallet in backup storage (localStorage)");
                        }
                    } else {
                        console.log("üíæ Found wallet in session storage");
                    }
                    
                    // If no seed saved, skip silently
                    if (!savedSeed) {
                        console.log("‚ÑπÔ∏è No saved wallet session found - please connect manually");
                        console.log("üîç Checked both sessionStorage and localStorage - both empty");
                        return;
                    }
                    
                    console.log("üîë Found saved wallet session, validating...");
                    
                    // LENIENT VALIDATION - Only block obvious junk
                    const words = savedSeed.split(/\s+/).filter(w => {
                        if (!w || w.length < 2) return false; // Too short
                        if (/^https?:\/\//.test(w)) return false; // URL
                        if (/^keeta_/.test(w)) return false; // Keeta address
                        if (/^\d+$/.test(w)) return false; // Pure numbers
                        return true; // Accept everything else
                    });
                    
                    console.log(`üìù Seed has ${words.length} words`);
                    
                    // Validate word count silently
                    if (words.length !== 12 && words.length !== 24) {
                        console.warn(`‚ö†Ô∏è Invalid seed word count: ${words.length} (need 12 or 24)`);
                        sessionStorage.removeItem('punkswap_wallet_seed');
                        console.log("üßπ Cleared invalid seed from session");
                        return;
                    }
                    
                    console.log(`üîÑ Restoring wallet from session (${words.length} words)...`);
                    
                    // VALIDATE BEFORE IMPORTING - Try to create account first
                    try {
                        const testPassphrase = words.join(' ');
                        const testHex = await KeetaNet.lib.Account.seedFromPassphrase(testPassphrase, { asString: true });
                        const testAccount = KeetaNet.lib.Account.fromSeed(testHex, 0);
                        console.log("‚úÖ Seed validation passed - restoring wallet...");
                    } catch (validationError) {
                        console.error("‚ùå Seed validation failed:", validationError.message);
                        sessionStorage.removeItem('punkswap_wallet_seed');
                        localStorage.removeItem('punkswap_wallet_seed_backup');
                        console.log("üßπ Cleared corrupted seed from session");
                        return;
                    }
                    
                    console.log("üîê Importing wallet directly (bypassing seed boxes)...");
                    
                    // DIRECT IMPORT - Don't use seed boxes, import directly
                    try {
                        const passphrase = words.join(' ');
                        const hex = await KeetaNet.lib.Account.seedFromPassphrase(passphrase, { asString: true });
                        state.keetaAccount = KeetaNet.lib.Account.fromSeed(hex, 0);
                        state.address = state.keetaAccount.publicKeyString.get();
                        
                        // Connect to network
                        try {
                            state.keetaClient = KeetaNet.UserClient.fromNetwork('', state.keetaAccount);
                            console.log("‚úÖ Connected to network");
                        } catch (e) {
                            try {
                                state.keetaClient = KeetaNet.UserClient.fromNetwork('production', state.keetaAccount);
                            } catch (e2) {
                                try {
                                    state.keetaClient = KeetaNet.UserClient.fromNetwork('main', state.keetaAccount);
                                } catch (e3) {
                                    state.keetaClient = KeetaNet.UserClient.fromNetwork('test', state.keetaAccount);
                                }
                            }
                        }
                        
                        // Update UI
                        document.getElementById('profileOffline')?.classList.add('hidden');
                        document.getElementById('profileOnline')?.classList.remove('hidden');
                        const addrDisplay = document.getElementById('walletAddressDisplay');
                        if (addrDisplay) addrDisplay.innerText = state.address;
                        
                        console.log("üîê Wallet connected:", state.address);
                        
                        // Initialize wallet
                        const linkLoop = async () => {
                            try {
                                if (state.keetaClient && typeof state.keetaClient.init === 'function') {
                                    await state.keetaClient.init();
                                }
                                await window.refreshBalance();
                                window.refreshAuthGate();
                                window.checkEscrowAccess();
                                await window.loadNFTsFromFirebase();
                                await window.loadCollections();
                                await window.loadTraitCounts();
                                await window.autoDetectExternalNFTs();
                                await window.loadTransactions();
                                await window.loadOffers();
                                
                                setTimeout(() => window.calculatePortfolio(), 1000);
                            } catch (e) { 
                                console.warn("Link initialization delay, retrying...");
                                setTimeout(linkLoop, 3000); 
                            }
                        };
                        linkLoop();
                        
                        console.log("‚úÖ Wallet restored from session successfully!");
                        window.notify("‚úÖ Wallet reconnected automatically", "success");
                        
                    } catch (error) {
                        console.error("‚ùå Direct import failed:", error);
                        sessionStorage.removeItem('punkswap_wallet_seed');
                        localStorage.removeItem('punkswap_wallet_seed_backup');
                        throw error;
                    }
                    
                } catch (error) {
                    console.error("‚ùå Wallet restoration failed:", error);
                    console.error("Error details:", error.message, error.stack);
                    
                    // Clear corrupted data
                    try {
                        sessionStorage.removeItem('punkswap_wallet_seed');
                        document.querySelectorAll('.seed-box').forEach(box => {
                            if (box) box.value = '';
                        });
                        console.log("üßπ Cleaned up after restoration failure");
                    } catch (e) {
                        console.error("Cleanup error:", e);
                    }
                }
            }, 1500); // Reduced to 1.5 seconds for faster reconnect
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AIRDROP ADMIN FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // State for airdrop
        let airdropState = {
            selectedCollection: null,
            airdropHistory: [],
            unlocked: false,
            passcode: "KEEPUNKS2026" // Change this passcode as needed
        };

        // Verify airdrop passcode
        window.verifyAirdropPasscode = () => {
            const input = document.getElementById('airdropPasscodeInput');
            const error = document.getElementById('airdropPasscodeError');
            const gate = document.getElementById('airdropPasscodeGate');
            const content = document.getElementById('airdropContent');
            
            if (input.value === airdropState.passcode) {
                airdropState.unlocked = true;
                gate.classList.add('hidden');
                content.classList.remove('hidden');
                window.notify("‚úÖ Airdrop unlocked", "success");
                window.loadAirdropCollections();
            } else {
                error.textContent = "‚ùå Incorrect passcode";
                error.classList.remove('hidden');
                input.value = '';
                input.focus();
                setTimeout(() => {
                    error.classList.add('hidden');
                }, 3000);
            }
        };

        // Load user's collections for airdrop
        window.loadAirdropCollections = async () => {
            if (!state.address) {
                console.log("‚ö†Ô∏è loadAirdropCollections: No wallet connected");
                return;
            }
            
            console.log("üìã Loading airdrop collections...");
            console.log("   - User address:", state.address);
            console.log("   - Total collections:", state.collections.length);
            console.log("   - Total NFTs loaded:", state.nfts.length);
            
            const select = document.getElementById('airdropCollectionSelect');
            if (!select) {
                console.error("‚ùå Airdrop dropdown element not found!");
                return;
            }
            
            // Clear existing options except first
            select.innerHTML = '<option value="">-- Select a collection --</option>';
            
            // Filter collections created by current user (including blind mints)
            const userCollections = state.collections.filter(c => {
                const isCreator = c.creator && c.creator.toLowerCase() === state.address.toLowerCase();
                console.log(`   - ${c.collectionTitle}: creator=${c.creator}, isCreator=${isCreator}, blind=${c.blindMintEnabled}`);
                return isCreator;
            });
            
            console.log("   - User's collections:", userCollections.length);
            
            if (userCollections.length === 0) {
                select.innerHTML += '<option value="" disabled>No collections created by you</option>';
                console.log("‚ö†Ô∏è No airdrop-eligible collections (you haven't created any)");
                return;
            }
            
            userCollections.forEach(collection => {
                // Count NFTs owned by user in this collection
                const ownedNFTs = state.nfts.filter(nft => {
                    const matchesCollection = nft.collectionId === collection.collectionId;
                    const isOwner = nft.owner === state.address;
                    const notInEscrow = !nft.inEscrow;
                    return matchesCollection && isOwner && notInEscrow;
                }).length;
                
                console.log(`   - ${collection.collectionTitle}: ${ownedNFTs} owned NFTs`);
                
                const option = document.createElement('option');
                option.value = collection.collectionId;
                option.textContent = `${collection.collectionTitle} (${ownedNFTs} owned)`;
                select.appendChild(option);
            });
            
            console.log(`‚úÖ Loaded ${userCollections.length} airdrop-eligible collections`);
        };

        // Load selected collection details
        window.loadAirdropCollection = async () => {
            const select = document.getElementById('airdropCollectionSelect');
            const collectionId = select.value;
            
            if (!collectionId) {
                document.getElementById('airdropCollectionInfo')?.classList.add('hidden');
                document.getElementById('airdropOptionsSection')?.classList.add('hidden');
                return;
            }
            
            const collection = state.collections.find(c => c.collectionId === collectionId);
            if (!collection) return;
            
            // Check if user is creator
            if (collection.creator !== state.address) {
                window.notify("You can only airdrop from collections you created", "error");
                select.value = "";
                return;
            }
            
            // CRITICAL: Block airdrop for blind mint collections
            if (collection.blindMintEnabled) {
                window.notify("‚ö†Ô∏è Airdrop disabled for blind mint collections. Blind mints are for public minting only.", "error");
                select.value = "";
                document.getElementById('airdropCollectionInfo')?.classList.add('hidden');
                document.getElementById('airdropOptionsSection')?.classList.add('hidden');
                return;
            }
            
            airdropState.selectedCollection = collection;
            
            // Count NFTs owned by user (available for airdrop)
            const ownedNFTs = state.nfts.filter(nft => 
                nft.collectionId === collection.collectionId && 
                nft.owner === state.address &&
                !nft.inEscrow // Not listed for sale
            );
            
            // Update UI
            document.getElementById('airdropCollectionName').textContent = collection.collectionTitle;
            document.getElementById('airdropMintedCount').textContent = collection.mintedCount;
            document.getElementById('airdropTotalSupply').textContent = collection.totalSupply;
            document.getElementById('airdropRemainingSupply').textContent = `${ownedNFTs.length} owned (available)`;
            document.getElementById('airdropCreatorAddress').textContent = collection.creator.substring(0, 20) + '...';
            
            document.getElementById('airdropCollectionInfo')?.classList.remove('hidden');
            document.getElementById('airdropOptionsSection')?.classList.remove('hidden');
            
            // Set max for specific NFT input (user-friendly: 1 to totalSupply)
            const nftInput = document.getElementById('airdropNFTNumber');
            if (nftInput) {
                nftInput.max = collection.totalSupply; // User enters 1-256, not 0-255
                nftInput.min = 1;
            }
            
            // Update single NFT help text
            const singleHelp = document.getElementById('singleNFTHelp');
            if (singleHelp) {
                singleHelp.innerHTML = `Enter the NFT number: 1-${collection.totalSupply}<br>NFT #1 = 001.json, NFT #2 = 002.json, etc.<br><span class="text-cyan-400">You own ${ownedNFTs.length} NFTs from this collection</span>`;
            }
            
            // Update batch NFT range display
            const rangeDisplay = document.getElementById('batchNFTRange');
            if (rangeDisplay) {
                rangeDisplay.textContent = `(1-${collection.totalSupply})`;
            }
            
            console.log(`‚úÖ Loaded collection for airdrop: ${collection.collectionTitle} (${ownedNFTs.length} owned)`);
        };

        // Toggle specific NFT input
        window.toggleAirdropNFTInput = () => {
            const mode = document.getElementById('airdropNFTMode').value;
            const specificDiv = document.getElementById('airdropSpecificNFT');
            
            if (mode === 'specific') {
                specificDiv?.classList.remove('hidden');
            } else {
                specificDiv?.classList.add('hidden');
            }
        };

        // Execute single airdrop - TRANSFER owned NFT
        window.executeSingleAirdrop = async () => {
            if (!airdropState.selectedCollection) {
                return window.notify("Please select a collection first", "error");
            }
            
            const collection = airdropState.selectedCollection;
            const recipient = document.getElementById('airdropRecipient').value.trim();
            const nftNumberInput = document.getElementById('airdropNFTNumber').value.trim();
            
            // Validate recipient
            if (!recipient || !recipient.startsWith('keeta_')) {
                return window.notify("Please enter a valid wallet address", "error");
            }
            
            // Validate NFT number
            if (!nftNumberInput || nftNumberInput === '') {
                return window.notify("Please enter the NFT number to send (1-256)", "error");
            }
            
            const userNftNumber = parseInt(nftNumberInput);
            if (isNaN(userNftNumber) || userNftNumber < 1 || userNftNumber > collection.totalSupply) {
                return window.notify(`Invalid NFT number. Must be 1-${collection.totalSupply}`, "error");
            }
            
            console.log(`üéÅ AIRDROP: Looking for NFT #${userNftNumber} in collection ${collection.collectionTitle}`);
            
            // Get all your NFTs from this collection
            const yourNFTs = state.nfts.filter(nft => 
                nft.collectionId === collection.collectionId &&
                nft.owner === state.address &&
                !nft.inEscrow
            );
            
            console.log(`   You own ${yourNFTs.length} NFTs from this collection:`, yourNFTs.map(n => n.name));
            
            // Try multiple name patterns to find the NFT
            const nftToSend = yourNFTs.find(nft => {
                // Pattern 1: "Collection Title #5"
                if (nft.name === `${collection.collectionTitle} #${userNftNumber}`) return true;
                // Pattern 2: "Collection Title #05" (2-digit padded)
                if (nft.name === `${collection.collectionTitle} #${String(userNftNumber).padStart(2, '0')}`) return true;
                // Pattern 3: "Collection Title #005" (3-digit padded)
                if (nft.name === `${collection.collectionTitle} #${String(userNftNumber).padStart(3, '0')}`) return true;
                // Pattern 4: Just "#5" at the end
                if (nft.name.endsWith(`#${userNftNumber}`)) return true;
                // Pattern 5: Just "#05" at the end (2-digit padded)
                if (nft.name.endsWith(`#${String(userNftNumber).padStart(2, '0')}`)) return true;
                // Pattern 6: Just "#005" at the end (3-digit padded)
                if (nft.name.endsWith(`#${String(userNftNumber).padStart(3, '0')}`)) return true;
                return false;
            });
            
            if (!nftToSend) {
                console.error(`‚ùå Could not find NFT #${userNftNumber} in your wallet`);
                console.log(`   Looking for: "${collection.collectionTitle} #${userNftNumber}"`);
                console.log(`   Your NFTs in this collection:`, yourNFTs.map(n => n.name));
                console.log(`   Tried patterns:`);
                console.log(`     - "${collection.collectionTitle} #${userNftNumber}"`);
                console.log(`     - "${collection.collectionTitle} #${String(userNftNumber).padStart(2, '0')}"`);
                console.log(`     - "${collection.collectionTitle} #${String(userNftNumber).padStart(3, '0')}"`);
                console.log(`     - Ending with "#${userNftNumber}"`);
                console.log(`     - Ending with "#${String(userNftNumber).padStart(2, '0')}"`);
                console.log(`     - Ending with "#${String(userNftNumber).padStart(3, '0')}"`);
                console.log(`   Your actual NFT names:`, yourNFTs.map(n => `"${n.name}"`));
                return window.notify(`You don't own NFT #${userNftNumber} from this collection`, "error");
            }
            
            console.log(`‚úÖ Found NFT to send: "${nftToSend.name}"`);
            console.log(`   Token ID: ${nftToSend.tokenId || 'MISSING!'}`);
            console.log(`   Token Address: ${nftToSend.tokenAddress || 'N/A'}`);
            
            // Use tokenId (that's what's saved in Firebase)
            const tokenAddress = nftToSend.tokenId || nftToSend.tokenAddress;
            
            if (!tokenAddress) {
                console.error(`‚ùå NFT has no tokenId or tokenAddress!`);
                return window.notify(`NFT ${nftToSend.name} has no blockchain token address`, "error");
            }
            
            window.notify("Transferring NFT...", "info");
            
            try {
                // Transfer NFT on blockchain - simple send like Keeta wallet
                const builder = state.keetaClient.initBuilder();
                builder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                
                const recipientAccount = KeetaNet.lib.Account.fromPublicKeyString(recipient);
                const tokenAccount = KeetaNet.lib.Account.fromPublicKeyString(tokenAddress);
                
                // Simple send: TO recipient, AMOUNT 1, OF token
                builder.send(recipientAccount, 1n, tokenAccount);
                
                await state.keetaClient.computeBuilderBlocks(builder);
                const tx = await state.keetaClient.publishBuilder(builder);
                
                console.log("‚úÖ Transfer transaction published:", tx);
                console.log("‚úÖ Airdrop complete!");
                
                // Update Firebase to mark NFT as transferred
                try {
                    await db.collection('nfts').doc(nftToSend.id).update({
                        inVault: false,
                        transferredOutside: true,
                        owner: recipient,
                        updatedAt: new Date().toISOString()
                    });
                    console.log("‚úÖ Firebase updated: NFT marked as transferred");
                } catch (fbError) {
                    console.error("‚ö†Ô∏è Failed to update Firebase:", fbError);
                    // Continue anyway - blockchain transfer succeeded
                }
                
                window.notify(`‚úÖ Sent ${nftToSend.name} to recipient!`, "success");
                
                // Refresh NFT data from Firebase
                await window.loadNFTsFromFirebase();
                await window.loadCollections();
                window.loadAirdropCollections();
                
                // Clear inputs
                document.getElementById('airdropRecipient').value = '';
                document.getElementById('airdropNFTNumber').value = '';
                
            } catch (error) {
                console.error("Airdrop transfer failed:", error);
                window.notify(`Transfer failed: ${error.message}`, "error");
            }
        };

        // Validate airdrop addresses
        window.validateAirdropAddresses = () => {
            const textarea = document.getElementById('batchAirdropAddresses');
            const lines = textarea.value.split('\n').map(l => l.trim()).filter(l => l);
            
            const valid = [];
            const invalid = [];
            
            lines.forEach(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length !== 2) {
                    invalid.push({ line, reason: 'Must have wallet,nft_number format' });
                    return;
                }
                
                const [wallet, nftNum] = parts;
                
                if (!wallet.startsWith('keeta_')) {
                    invalid.push({ line, reason: 'Invalid wallet address' });
                    return;
                }
                
                const num = parseInt(nftNum);
                if (isNaN(num) || num < 1) {
                    invalid.push({ line, reason: 'Invalid NFT number (must be 1 or higher)' });
                    return;
                }
                
                // Convert user number (1-256) to internal index (0-255)
                valid.push({ wallet, nftNumber: num, nftIndex: num - 1 });
            });
            
            const status = document.getElementById('batchAirdropStatus');
            status.classList.remove('hidden');
            
            if (invalid.length > 0) {
                status.className = 'p-4 rounded-lg border border-red-500/30 bg-red-500/10';
                status.innerHTML = `
                    <p class="text-red-400 text-sm font-bold">‚ùå ${invalid.length} invalid line(s)</p>
                    <p class="text-xs text-gray-400 mt-1">Format: wallet_address, nft_number (1-256)</p>
                    <p class="text-xs text-gray-500 mt-1">${invalid[0]?.reason || ''}</p>
                `;
            } else {
                status.className = 'p-4 rounded-lg border border-green-500/30 bg-green-500/10';
                status.innerHTML = `
                    <p class="text-green-400 text-sm font-bold">‚úÖ ${valid.length} valid assignment(s)</p>
                    <p class="text-xs text-gray-400 mt-1">Ready to airdrop</p>
                `;
            }
            
            document.getElementById('batchAirdropCount').textContent = valid.length;
        };

        // Import CSV for batch airdrop
        window.importAirdropCSV = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv,.txt';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    document.getElementById('batchAirdropAddresses').value = event.target.result;
                    window.validateAirdropAddresses();
                    window.notify(`CSV imported`, "success");
                };
                reader.readAsText(file);
            };
            input.click();
        };

        // Execute batch airdrop
        window.executeBatchAirdrop = async () => {
            if (!airdropState.selectedCollection) {
                return window.notify("Please select a collection first", "error");
            }
            
            const collection = airdropState.selectedCollection;
            const textarea = document.getElementById('batchAirdropAddresses');
            const lines = textarea.value.split('\n').map(l => l.trim()).filter(l => l);
            
            const assignments = [];
            lines.forEach(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length === 2 && parts[0].startsWith('keeta_')) {
                    const num = parseInt(parts[1]);
                    if (!isNaN(num) && num >= 1) {
                        assignments.push({ 
                            wallet: parts[0], 
                            nftNumber: num           // User-friendly (1-256)
                        });
                    }
                }
            });
            
            if (assignments.length === 0) {
                return window.notify("Please enter valid wallet,nft_number pairs", "error");
            }
            
            // Count owned NFTs instead of remaining supply
            const ownedNFTs = state.nfts.filter(nft => 
                nft.collectionId === collection.collectionId && 
                nft.owner === state.address &&
                !nft.inEscrow
            ).length;
            
            if (assignments.length > ownedNFTs) {
                return window.notify(`Not enough NFTs owned. Have: ${ownedNFTs}, Need: ${assignments.length}`, "error");
            }
            
            const confirmed = confirm(`Airdrop ${assignments.length} NFTs to ${assignments.length} owners?\n\nThis cannot be undone.`);
            if (!confirmed) return;
            
            window.notify(`Processing batch airdrop of ${assignments.length} NFTs...`, "info");
            
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < assignments.length; i++) {
                const { wallet, nftNumber } = assignments[i];
                
                // Update UI - show user-friendly number
                window.notify(`Airdropping ${i + 1}/${assignments.length}... (NFT #${nftNumber} ‚Üí ${wallet.substring(0, 20)}...)`, "info");
                
                try {
                    // Set values using user-friendly number
                    document.getElementById('airdropRecipient').value = wallet;
                    document.getElementById('airdropNFTNumber').value = nftNumber;
                    
                    await window.executeSingleAirdrop();
                    successCount++;
                    
                    // Small delay to prevent rate limiting
                    await new Promise(r => setTimeout(r, 1500));
                    
                } catch (error) {
                    console.error(`Failed to airdrop NFT #${nftNumber} to ${wallet}:`, error);
                    failCount++;
                }
            }
            
            window.notify(`‚úÖ Batch complete: ${successCount} successful, ${failCount} failed`, "success");
            
            // Clear textarea
            textarea.value = '';
            document.getElementById('batchAirdropCount').textContent = '0';
        };

        // Render airdrop history
        window.renderAirdropHistory = () => {
            const list = document.getElementById('airdropHistoryList');
            if (!list) return;
            
            if (airdropState.airdropHistory.length === 0) {
                list.innerHTML = '<p class="text-sm text-gray-500 text-center py-8">No airdrops yet</p>';
                return;
            }
            
            list.innerHTML = airdropState.airdropHistory.slice(0, 10).map(drop => `
                <div class="p-3 bg-black/40 border border-green-500/20 rounded-lg flex justify-between items-center">
                    <div>
                        <p class="text-sm text-white font-bold">${drop.nftName}</p>
                        <p class="text-xs text-gray-500 font-mono">${drop.recipient.substring(0, 30)}...</p>
                    </div>
                    <div class="text-right">
                        <p class="text-xs text-green-400">${new Date(drop.timestamp).toLocaleString()}</p>
                        ${drop.txHash ? `<p class="text-xs text-gray-500 font-mono">${drop.txHash.substring(0, 12)}...</p>` : ''}
                    </div>
                </div>
            `).join('');
        };

        // Show airdrop tab always (for testing; was: only when user is a creator)
        window.updateAirdropVisibility = () => {
            const nav = document.getElementById('nav-airdrop');
            nav?.classList.remove('hidden');
        };

        // ============================================
        // KEETA MINT PIPELINE - PRODUCTION GRADE
        // ============================================
        //
        // FAILURE MODE ANALYSIS:
        // STEP 1 FAIL (Validation)     ‚Üí Abort immediately, no blockchain interaction
        // STEP 2 FAIL (Metadata)       ‚Üí Abort, no token created, no payment
        // STEP 3 FAIL (Token Creation) ‚Üí No payment made, user can retry
        // STEP 4 FAIL (Payment)        ‚Üí Token exists but mint incomplete; user has orphan token
        // STEP 5 FAIL (Firebase)       ‚Üí NFT on chain, owned by user, but not in UI; needs reconciliation
        //
        // Usage: const pipeline = window.createKeetaMintPipeline();
        //        const result = await pipeline.executeMint({
        //          collectionId: '...',
        //          userWallet: state.address,
        //          userClient: state.keetaClient,
        //          userAccount: state.keetaAccount  // Optional if userClient has .account
        //        });
        //

        window.KeetaMintPipeline = class KeetaMintPipeline {
            constructor(firestoreDb, appId) {
                this.db = firestoreDb;
                this.appId = appId || state.appId;
            }

            async getCollection(collectionId) {
                const ref = doc(this.db, 'collections', collectionId);
                const snap = await getDoc(ref);
                if (!snap.exists()) return null;
                return { id: snap.id, ...snap.data() };
            }

            async getUserMintCount(collectionId, userWallet) {
                const ref = doc(this.db, 'walletMintTracking', `${userWallet}_${collectionId}`);
                const snap = await getDoc(ref);
                return snap.exists() ? (snap.data().mintedCount || 0) : 0;
            }

            async checkWhitelist(collectionId, userWallet) {
                console.log(`üîç checkWhitelist called:`);
                console.log(`   - Collection: ${collectionId}`);
                console.log(`   - Wallet: ${userWallet}`);
                
                // Use NEW phase-based whitelist system
                const activePhase = window.getActivePhaseForWallet(collectionId, userWallet);
                if (!activePhase) {
                    console.log(`‚ùå Wallet not in any active phase for collection ${collectionId}`);
                    console.log(`   - Settings exist:`, !!state.whitelistSettings[collectionId]);
                    console.log(`   - Current time:`, new Date().toISOString());
                    return false;
                }
                
                console.log(`‚úÖ Found active phase: "${activePhase.name}"`);
                console.log(`   - Phase price: ${activePhase.priceKTA} KTA`);
                console.log(`   - Max mints: ${activePhase.maxMintsPerWallet || 1}`);
                
                // Check if user has reached max mints for their phase
                const maxMints = activePhase.maxMintsPerWallet || 1;
                const walletTracking = state.walletMintTracking?.[collectionId]?.[userWallet];
                const usedMints = walletTracking?.count || 0;
                
                console.log(`   - Used mints: ${usedMints}/${maxMints}`);
                
                if (usedMints >= maxMints) {
                    console.log(`‚ùå Wallet has reached max mints (${usedMints}/${maxMints})`);
                    return false;
                }
                
                console.log(`‚úÖ Whitelist check passed: Phase "${activePhase.name}", ${usedMints}/${maxMints} mints used`);
                return true;
            }

            async getKTABalance(walletAddress) {
                try {
                    const bal = await KeetaNet.lib.rpc.balance(walletAddress);
                    const kta = bal?.find(b => b.token?.$type === 'KTA' || b.token?.publicKeyString);
                    return kta ? Number(kta.amount || 0n) / KTA_DECIMALS : 0;
                } catch (e) {
                    return 0;
                }
            }

            async getAndIncrementMintIndex(collectionId) {
                const collectionRef = doc(this.db, 'collections', collectionId);
                
                // Get current state
                const beforeSnap = await getDoc(collectionRef);
                const beforeCount = beforeSnap.data().mintedCount || 0;
                console.log(`üìà BEFORE increment: mintedCount=${beforeCount}, remainingSupply=${beforeSnap.data().remainingSupply}`);
                
                // Increment
                await updateDoc(collectionRef, { mintedCount: increment(1), remainingSupply: increment(-1) });
                
                // Get new state
                const afterSnap = await getDoc(collectionRef);
                const afterCount = afterSnap.data().mintedCount || 0;
                console.log(`üìà AFTER increment: mintedCount=${afterCount}, remainingSupply=${afterSnap.data().remainingSupply}`);
                
                const mintIndex = afterCount - 1;
                console.log(`üéØ Mint will use index: ${mintIndex}`);
                
                return mintIndex;
            }

            extractHashFromTx(tx) {
                try {
                    // Primary: voteStaple blocks
                    const h0 = tx?.voteStaple?.blocks?.[0]?.$hash;
                    if (h0) return h0;
                    const h1 = tx?.voteStaple?.blocks?.[1]?.$hash;
                    if (h1) return h1;
                    // Fallback: any block in array
                    const blocks = tx?.voteStaple?.blocks;
                    if (Array.isArray(blocks)) {
                        for (const b of blocks) {
                            const h = b?.$hash;
                            if (h) return h;
                        }
                    }
                    // Fallback: stringify and regex for hex hash
                    if (tx) {
                        const str = JSON.stringify(tx, (k, v) => typeof v === 'bigint' ? v.toString() : v);
                        const match = str.match(/"(\$hash|hash)":\s*"([A-Fa-f0-9]{64})"/);
                        if (match) return match[2];
                        const alt = str.match(/([A-Fa-f0-9]{64})/);
                        if (alt) return alt[1];
                    }
                    return null;
                } catch (e) {
                    return null;
                }
            }

            async validateMintRequest(req) {
                console.log("üîç [STEP 1] Validating mint request...");
                console.log("üìã Request details:", {
                    collectionId: req.collectionId,
                    userWallet: req.userWallet,
                    stateBalance: state.balanceKTA
                });
                
                const collection = await this.getCollection(req.collectionId);
                if (!collection) {
                    console.error("‚ùå Collection not found:", req.collectionId);
                    return { valid: false, error: "Collection not found" };
                }
                
                console.log("‚úÖ Collection found:", collection.collectionTitle);
                
                // üìä CONCURRENT USER DETECTION
                const totalSupply = (collection.mintedCount || 0) + (collection.remainingSupply || 0);
                const currentMinted = collection.mintedCount || 0;
                const supplyPct = ((currentMinted / totalSupply) * 100).toFixed(1);
                
                console.log(`üìä COLLECTION STATUS:`);
                console.log(`   üéØ Minted: ${currentMinted}/${totalSupply} (${supplyPct}%)`);
                console.log(`   üì¶ Remaining: ${collection.remainingSupply || 0}`);
                
                // Estimate concurrent users based on rapid mint index increments
                if (state.performanceMetrics.batchMints.length > 0) {
                    const lastBatch = state.performanceMetrics.batchMints[state.performanceMetrics.batchMints.length - 1];
                    const timeSinceLastBatch = (Date.now() - new Date(lastBatch.timestamp).getTime()) / 1000;
                    
                    if (timeSinceLastBatch < 60) { // Within last minute
                        console.log(`   ‚ö° Recent Activity: Last mint was ${timeSinceLastBatch.toFixed(0)}s ago`);
                    }
                }
                
                if ((collection.mintedCount || 0) >= totalSupply) return { valid: false, error: "Collection sold out" };
                const userMintCount = await this.getUserMintCount(req.collectionId, req.userWallet);
                const maxPer = collection.maxMintsPerWallet ?? 10;
                if (userMintCount >= maxPer) return { valid: false, error: `Max ${maxPer} mints per wallet` };
                // Whitelist settings should already be loaded during initialization
                // Don't load during validation - this causes 12s delay!
                const ws = state.whitelistSettings?.[req.collectionId];
                if (ws?.enabled) {
                    console.log(`üîê Whitelist enabled for collection ${req.collectionId}`);
                    const mintType = collection.blindMintEnabled ? 'BLIND_MINT' : 'STANDARD_MINT';
                    if (ws.mode && ws.mode !== 'BOTH' && ws.mode !== mintType) {
                        console.log(`‚ùå Whitelist mode mismatch: ${ws.mode} !== ${mintType}`);
                        return { valid: false, error: "Whitelist not active for this mint type" };
                    }
                    const now = Date.now();
                    if (ws.mintWindowStart && now < new Date(ws.mintWindowStart).getTime()) {
                        console.log(`‚ùå Mint window hasn't started yet`);
                        return { valid: false, error: "Mint window not open yet" };
                    }
                    if (ws.mintWindowEnd && now > new Date(ws.mintWindowEnd).getTime()) {
                        console.log(`‚ùå Mint window has ended`);
                        return { valid: false, error: "Mint window closed" };
                    }
                    
                    console.log(`üîç Checking whitelist for wallet: ${req.userWallet}`);
                    const isWhitelisted = await this.checkWhitelist(req.collectionId, req.userWallet);
                    if (!isWhitelisted) {
                        console.log(`‚ùå Whitelist check failed for wallet: ${req.userWallet}`);
                        // Check if wallet is in ANY phase (even if not active)
                        const settings = state.whitelistSettings[req.collectionId];
                        const inAnyPhase = settings?.phases?.some(p => 
                            p.wallets?.some(w => w.toLowerCase().trim() === req.userWallet.toLowerCase().trim())
                        );
                        if (inAnyPhase) {
                            return { valid: false, error: "Your mint phase is not currently active" };
                        } else {
                            return { valid: false, error: "Wallet not whitelisted" };
                        }
                    }
                    console.log(`‚úÖ Whitelist check passed!`);
                }
                // Get price using unified helper (supports KTA + PUNKS)
                const valCp = window.getCollectionPrice(collection, req.userWallet);
                let price = valCp.price;
                let valCurrency = valCp.currency;
                const activePhase = window.getActivePhaseForWallet(req.collectionId, req.userWallet);
                
                if (activePhase) {
                    price = activePhase.priceKTA;
                    valCurrency = 'KTA';
                    console.log(`üíé Phase pricing detected in validation: "${activePhase.name}" = ${price} KTA`);
                }

                const balance = valCurrency === 'PUNKS' ? (state.balancePunks || 0) : (state.balanceKTA || 0);
                console.log(`üí∞ Balance check: Have ${balance} ${valCurrency}, Need ${price} ${valCurrency}`);

                if (balance < price) {
                    console.error(`‚ùå Insufficient balance: ${balance} < ${price}`);
                    return { valid: false, error: `Insufficient ${valCurrency} (need ${price}, have ${balance.toFixed(2)})` };
                }

                console.log(`‚úÖ Balance sufficient: ${balance} >= ${price}`);
                console.log("‚úÖ [STEP 1] ALL VALIDATION CHECKS PASSED");
                console.log("üìã Validation summary:", {
                    collection: collection.collectionTitle,
                    supply: `${collection.mintedCount}/${collection.totalSupply}`,
                    userMints: `${userMintCount}/${maxPer}`,
                    balance: `${balance.toFixed(2)} ${valCurrency}`,
                    price: `${price} ${valCurrency}`,
                    whitelisted: ws?.enabled ? 'Yes' : 'No'
                });
                return { valid: true };
            }

            async resolveMetadata(collectionId) {
                console.log("üìÑ [STEP 2] Resolving metadata...");
                
                // ‚ö° OPTIMIZATION: Fetch collection and increment index in PARALLEL
                const [collection, mintIndex] = await Promise.all([
                    this.getCollection(collectionId),
                    this.getAndIncrementMintIndex(collectionId)
                ]);
                
                console.log(`üìä Collection info:`, {
                    blindMintEnabled: collection.blindMintEnabled,
                    scannedFilesCount: collection.scannedFiles?.length || 0,
                    mintIndex: mintIndex,
                    totalSupply: collection.totalSupply
                });
                
                let filename;
                if (collection.blindMintEnabled && collection.scannedFiles?.length) {
                    filename = collection.scannedFiles[mintIndex] || `${String(mintIndex + 1).padStart(3, '0')}.json`;
                    console.log(`üé≤ Blind mint: Index ${mintIndex} ‚Üí File ${filename}`);
                    console.log(`üìÅ ScannedFiles array has ${collection.scannedFiles.length} files`);
                    
                    // Warn if index is beyond scannedFiles length
                    if (mintIndex >= collection.scannedFiles.length) {
                        console.warn(`‚ö†Ô∏è WARNING: Mint index ${mintIndex} exceeds scannedFiles length ${collection.scannedFiles.length}`);
                    }
                } else {
                    filename = `${String(mintIndex + 1).padStart(3, '0')}.json`;
                    console.log(`üìù Sequential mint: Index ${mintIndex} ‚Üí File ${filename}`);
                }
                
                // ‚ö° SPEED FIX: Use Promise.any (first success wins) + 8s timeout per gateway
                // ipfs.io first since Pinata blocks file:// origin with CORS
                const gateways = ['https://ipfs.io/ipfs', 'https://gateway.pinata.cloud/ipfs', 'https://4everland.io/ipfs', 'https://w3s.link/ipfs', 'https://dweb.link/ipfs'];
                let metadata = null;
                
                // Clean CID and filename to prevent double slashes and remove ipfs:// protocol
                let cleanCid = collection.ipfsCid || '';
                if (cleanCid.startsWith('ipfs://')) {
                    cleanCid = cleanCid.replace('ipfs://', '');
                }
                cleanCid = cleanCid.replace(/^\/+|\/+$/g, '');
                const cleanFilename = filename.replace(/^\/+/g, '');
                
                console.log(`üîó Final URL components: CID=${cleanCid.substring(0, 20)}... File=${cleanFilename}`);
                
                // ‚ö° SPEED FIX: Promise.any = returns FIRST success, ignores slower gateways
                // Each gateway gets 8 second timeout instead of waiting forever
                const GATEWAY_TIMEOUT = 8000;
                
                const fetchWithTimeout = (gw) => {
                    const metaUrl = `${gw}/${cleanCid}/${cleanFilename}`;
                    console.log(`üîç Trying: ${metaUrl}`);
                    const controller = new AbortController();
                    const timer = setTimeout(() => controller.abort(), GATEWAY_TIMEOUT);
                    return fetch(metaUrl, { signal: controller.signal })
                        .then(res => {
                            clearTimeout(timer);
                            if (!res.ok) throw new Error(`HTTP ${res.status}`);
                            return res.json();
                        })
                        .then(data => {
                            console.log(`‚úÖ Metadata loaded from: ${gw} (fast!)`);
                            return data;
                        })
                        .catch(err => {
                            clearTimeout(timer);
                            throw err;
                        });
                };
                
                try {
                    // Promise.any: first fulfilled promise wins, rest are abandoned
                    metadata = await Promise.any(gateways.map(gw => fetchWithTimeout(gw)));
                } catch (e) {
                    console.error(`‚ùå All gateways failed:`, e);
                    throw new Error(`Metadata fetch failed: ${cleanCid}/${cleanFilename}`);
                }
                
                if (!metadata.name || !metadata.image) throw new Error("Invalid metadata schema: missing name or image");
                let imagePath = metadata.image;
                if (imagePath.startsWith('ipfs://')) imagePath = imagePath.replace('ipfs://', '');
                else if (!imagePath.startsWith('http')) imagePath = `${collection.ipfsCid}/${imagePath}`;
                console.log("‚úÖ [STEP 2] Metadata resolved:", metadata.name);
                return { metadata, imagePath, mintIndex };
            }

            async createNFTToken(req, metadata, collection) {
                console.log("üé® [STEP 3] Creating NFT token with TWO-TRANSACTION pattern...");
                console.log("   NFT Name:", metadata.name);
                console.log("   Collection:", collection.collectionTitle);
                const account = req.userClient?.account || req.userAccount;
                if (!account) throw new Error("userClient.account or userAccount required");
                
                // ========================================
                // TRANSACTION 1: Create Token + Set Permissions
                // ========================================
                console.log("üìù TX 1: Creating token and setting permissions...");
                
                const builder1 = req.userClient.initBuilder();
                builder1.updateAccounts({ signer: account, account });
                
                const nftID = builder1.generateIdentifier(KeetaNet.lib.Account.AccountKeyAlgorithm.TOKEN);
                await req.userClient.computeBuilderBlocks(builder1);
                
                const tokenAccount = nftID.account;
                const tokenId = tokenAccount.publicKeyString.get();
                
                console.log("   Token address:", tokenId);
                
                // Set permissions and mint supply in TX 1
                // WORKAROUND: Keeta SDK validation is STRICT: ONLY [A-Z_] in name field
                // Strategy: Use generic name, put real NFT name in description
                
                // Create a generic but unique name using collection + a simple identifier
                let collectionName = (collection.collectionTitle || 'NFT')
                    .toUpperCase()
                    .replace(/[^A-Z]/g, '_')
                    .replace(/_+/g, '_')
                    .replace(/^_|_$/g, '');
                
                // Use collection name as the token name
                let nftName = collectionName;
                
                // Ensure minimum 6 characters
                if (nftName.length < 6) {
                    nftName = nftName + '_TOKEN';
                }
                
                // Ensure within 50 char limit
                nftName = nftName.substring(0, 50);
                
                // Put the REAL NFT name in the description field (this shows in wallet!)
                // Format: "NFT Name: Glitchborn Punk #088 - Description text..."
                let fullDescription = `${metadata.name}`;
                if (metadata.description) {
                    fullDescription += ` - ${metadata.description}`;
                }
                
                console.log("   ‚öôÔ∏è Original NFT name:", metadata.name);
                console.log("   ‚öôÔ∏è Generic token name:", nftName);
                console.log("   ‚öôÔ∏è Description with real name:", fullDescription.substring(0, 100) + '...');
                
                // Create symbol from collection name (shorter, for symbol field)  
                let collectionSymbol = (collection.collectionTitle || 'NFT')
                    .toUpperCase()
                    .replace(/[^A-Z]/g, '_')
                    .replace(/_+/g, '_')
                    .replace(/^_|_$/g, '')
                    .substring(0, 10);
                
                // Ensure symbol also meets minimum length requirement
                if (collectionSymbol.length < 6) {
                    collectionSymbol = nftName.substring(0, 10);
                }
                
                builder1.setInfo({
                    name: nftName,  // Generic: "GLITCHTESTY" (same for all NFTs in collection)
                    symbol: collectionSymbol,  // e.g., "GLITCHTEST"
                    description: fullDescription,  // REAL NAME HERE: "Glitchborn Punk #088 - Description..."
                    metadata: btoa(JSON.stringify(metadata)),
                    defaultPermission: new KeetaNet.lib.Permissions(['ACCESS'])
                }, { account: tokenAccount });
                
                builder1.modifyTokenSupply(1n, { account: tokenAccount });
                
                console.log("   Publishing TX 1...");
                await req.userClient.publishBuilder(builder1);
                console.log("   ‚úÖ TX 1 complete! Permissions committed to ledger.");
                
                // EXPERIMENTAL OPTIMIZATION: Removed 3s wait
                // TX1 and TX2 operate sequentially on the same token, so voting shouldn't conflict
                // If this causes failures, restore the 3s wait below:
                // await new Promise(r => setTimeout(r, 3000));
                
                // ========================================
                // TRANSACTION 2: Allocate to User
                // ========================================
                console.log("üìù TX 2: Allocating NFT to user wallet...");
                console.log("   DEBUG - TX2 Details:");
                console.log("   - User Wallet Address:", req.userWallet);
                console.log("   - User Account:", account);
                console.log("   - Token Account:", tokenAccount);
                console.log("   - Token Address:", tokenId);
                
                const builder2 = req.userClient.initBuilder();
                builder2.updateAccounts({ signer: account, account });
                
                console.log("   - Sending 1 token FROM:", tokenAccount.publicKeyString.get());
                console.log("   - Sending 1 token TO:", account.publicKeyString.get());
                
                builder2.send(account, 1n, tokenAccount, undefined, { account: tokenAccount });
                
                console.log("   Publishing TX 2...");
                const tx2Result = await req.userClient.publishBuilder(builder2);
                console.log("   ‚úÖ TX 2 complete! Result:", tx2Result);
                console.log("   NFT allocated to user.");
                
                // CRITICAL DEBUG: Verify the transaction was published
                if (tx2Result && tx2Result.voteStaple) {
                    console.log("   ‚úÖ TX 2 has voteStaple - transaction confirmed");
                } else {
                    console.warn("   ‚ö†Ô∏è TX 2 missing voteStaple - may not be confirmed!");
                }
                
                console.log("‚úÖ [STEP 3] NFT token created with TWO-TRANSACTION pattern:", tokenId);
                return tokenId;
            }

            async executePayment(req, collection) {
                console.log("üí∞ [STEP 4] Processing payment...");
                
                // Get price using unified helper (supports KTA + PUNKS)
                const cp = window.getCollectionPrice(collection, req.userWallet);
                let price = cp.price;
                let mintCurrency = cp.currency;
                
                const activePhase = window.getActivePhaseForWallet(collection.collectionId, req.userWallet);
                if (activePhase) {
                    price = activePhase.priceKTA;
                    mintCurrency = 'KTA';
                    console.log(`üíé Phase pricing active: "${activePhase.name}" = ${price} KTA`);
                } else {
                    console.log(`üí∞ Standard pricing: ${price} ${mintCurrency}`);
                }
                
                // Handle FREE mints - skip payment
                if (price === 0) {
                    console.log(`‚úÖ [STEP 4] FREE MINT - No payment required`);
                    return 'free_mint_no_payment';
                }
                
                // Process paid mints
                const account = req.userClient?.account || req.userAccount;
                if (!account) throw new Error("userClient.account or userAccount required");
                
                const paymentBuilder = req.userClient.initBuilder();
                paymentBuilder.updateAccounts({ signer: account, account });
                
                const paymentToken = window.getTokenForCurrency(mintCurrency);
                
                const creatorShare = price * PRIMARY_SALE_CREATOR_PERCENT;
                const marketplaceShare = price * PRIMARY_SALE_MARKETPLACE_PERCENT;
                
                console.log(`üí∞ Payment split: Creator ${creatorShare} ${mintCurrency} (90%) | Marketplace ${marketplaceShare} ${mintCurrency} (10%)`);
                
                const creatorAccount = KeetaNet.lib.Account.fromPublicKeyString(collection.creator || collection.creatorWallet);
                paymentBuilder.send(creatorAccount, BigInt(Math.floor(creatorShare * KTA_DECIMALS)), paymentToken);
                
                const marketplaceAccount = KeetaNet.lib.Account.fromPublicKeyString(MARKETPLACE_FEE_WALLET);
                paymentBuilder.send(marketplaceAccount, BigInt(Math.floor(marketplaceShare * KTA_DECIMALS)), paymentToken);
                
                await req.userClient.computeBuilderBlocks(paymentBuilder);
                const paymentTx = await req.userClient.publishBuilder(paymentBuilder);
                const txHash = paymentTx?.voteStaple?.blocks?.[0]?.$hash || this.extractHashFromTx(paymentTx);
                
                console.log("‚úÖ [STEP 4] Payment complete, tx:", txHash);
                return txHash;
            }

            async commitToFirebase(req, tokenId, metadata, imagePath, txHash, mintIndex, collection) {
                console.log("üíæ [STEP 5] Committing to Firebase...");
                console.log("TX Hash being saved:", txHash || "(none)");
                if (!txHash) {
                    console.warn("‚ö†Ô∏è WARNING: Committing NFT without transaction hash");
                    console.warn("This means hash extraction failed earlier in the pipeline");
                }
                // OPTIMIZATION: Use passed collection instead of fetching again
                // const collection = await this.getCollection(req.collectionId);
                const docId = `nft_${getNormalizedId(collection.collectionToken || collection.id)}_${mintIndex}`;
                
                // Create unique symbol from collection title
                // Example: "Peregrine Falcon Punk" ‚Üí "PFPN"
                // Example: "Cool Cats" ‚Üí "CCAT"
                // Example: "Bored Ape Yacht Club" ‚Üí "BAYC"
                const words = (collection.collectionTitle || 'NFT').split(/\s+/);
                let collectionSymbol;
                
                if (words.length >= 2) {
                    // Multi-word: Take first letter of each word
                    collectionSymbol = words
                        .map(word => word.charAt(0))
                        .join('')
                        .toUpperCase()
                        .substring(0, 4);
                } else {
                    // Single word: Take first 4 letters
                    collectionSymbol = (collection.collectionTitle || 'NFT')
                        .toUpperCase()
                        .replace(/[^A-Z0-9]/g, '')
                        .substring(0, 4);
                }
                
                // Ensure minimum length of 2
                if (collectionSymbol.length < 2) {
                    collectionSymbol = collectionSymbol + 'NFT'.substring(0, 4 - collectionSymbol.length);
                }
                
                const walletStyleDescription = metadata.description || `${metadata.name} from the ${collection.collectionTitle} collection. Token #${mintIndex} of ${collection.totalSupply}.`;
                
                // Ensure NFT name includes the number (like "Peregrine Falcon Punk NFT No 191")
                let nftName = metadata.name;
                
                // If the name doesn't already have a number pattern (#123, No 123, etc.), add it
                const hasNumber = /(?:#|\bNo\.?\s*)\d+/i.test(nftName);
                if (!hasNumber) {
                    // Add "No X" format to match Keeta wallet style
                    nftName = `${nftName} No ${mintIndex}`;
                }
                
                // OPTIMIZATION: Execute independent Firebase writes in parallel
                const nftDoc = setDoc(doc(this.db, 'nfts', docId), {
                    id: docId,
                    tokenId,
                    owner: req.userWallet,
                    collectionId: req.collectionId,
                    collectionTitle: collection.collectionTitle || collection.title,
                    collectionName: collection.collectionTitle || collection.title,
                    collectionSymbol: collectionSymbol,  // NEW: Unique per collection
                    collection: collection.collectionTitle || collection.title,
                    collectionToken: collection.collectionToken,
                    name: nftName,  // ENHANCED: Always includes number
                    description: walletStyleDescription,  // ENHANCED: Better formatted description
                    imageCid: imagePath,
                    imagePath: imagePath,
                    attributes: metadata.attributes || [],
                    mintIndex,
                    mintNumber: `#${mintIndex}`,  // NEW: Display format
                    totalSupply: collection.totalSupply,  // NEW: For "X of Y" display
                    mintTxHash: txHash,
                    mintedAt: new Date().toISOString(),
                    status: 'minted',
                    isListed: false,
                    listedPrice: null,
                    listedCurrency: null,
                    inEscrow: false,
                    creator: collection.creator,
                    priceKTA: collection.priceKTA,
                    pricePunks: collection.pricePunks,
                    wasBlindMinted: !!collection.blindMintEnabled,
                    externalUrl: metadata.external_url || ''
                });
                
                // Wallet tracking - can run in parallel
                const walletTrackingPromise = (async () => {
                    const walletTrackingRef = doc(this.db, 'walletMintTracking', `${req.userWallet}_${req.collectionId}`);
                    const trackingSnap = await getDoc(walletTrackingRef);
                    const currentCount = trackingSnap.exists() ? trackingSnap.data().mintedCount : 0;
                    const newCount = currentCount + 1;
                    await setDoc(walletTrackingRef, { 
                        walletAddress: req.userWallet, 
                        collectionId: req.collectionId, 
                        mintedCount: newCount,
                        lastMintedAt: new Date().toISOString()
                    });
                    
                    // Update state immediately for UI refresh
                    if (!state.walletMintTracking) state.walletMintTracking = {};
                    if (!state.walletMintTracking[req.collectionId]) state.walletMintTracking[req.collectionId] = {};
                    state.walletMintTracking[req.collectionId][req.userWallet] = {
                        count: newCount,
                        lastMintedAt: new Date().toISOString()
                    };
                    console.log(`üìä Updated wallet mint tracking: ${req.collectionId} ‚Üí ${newCount} mints`);
                })();
                
                // Whitelist update - can run in parallel
                const whitelistPromise = (async () => {
                    const ws = state.whitelistSettings?.[req.collectionId];
                    if (ws?.enabled) {
                        const wallets = state.whitelistWallets?.[req.collectionId] || [];
                        const entry = wallets.find(w => (w.walletAddress || '').toLowerCase() === req.userWallet.toLowerCase());
                        if (entry) {
                            try {
                                const walletRef = doc(this.db, 'whitelistWallets', entry.id);
                                await updateDoc(walletRef, { usedMints: (entry.usedMints || 0) + 1 });
                            } catch (e) { console.warn("Whitelist usage increment failed:", e); }
                        }
                    }
                })();
                
                // Transaction recording - can run in parallel
                const batchCp = window.getCollectionPrice(collection, state.address);
                const txRecordPromise = window.recordTransaction?.({ 
                    type: 'mint', 
                    nftId: docId, 
                    nftName: metadata.name, 
                    collection: collection.collectionTitle, 
                    collectionId: req.collectionId, 
                    counterParty: collection.creator, 
                    price: batchCp.price, 
                    currency: batchCp.currency, 
                    txHash 
                });
                
                // Wait for all parallel operations to complete
                await Promise.all([nftDoc, walletTrackingPromise, whitelistPromise, txRecordPromise].filter(Boolean));
                
                // Update trait counts for rarity calculation
                if (metadata.attributes && metadata.attributes.length > 0) {
                    await window.updateTraitCounts(collection.collectionId, metadata.attributes);
                }
                
                // Recalculate collection-wide trait counts for accurate rarity percentages
                setTimeout(async () => {
                    try {
                        await window.calculateAndSaveTraitCounts(collection.collectionToken || collection.collectionId);
                        await window.loadTraitCounts();
                        console.log("‚úÖ Trait counts updated for rarity system");
                    } catch (e) {
                        console.warn("‚ö†Ô∏è Trait count calculation failed:", e);
                    }
                }, 2000);
                
                console.log("‚úÖ [STEP 5] Firebase commit complete");
                
                // DISABLED: Auto-escrow for blind mints
                // NFTs now stay with the user after minting
                // Escrow only used for atomic swaps during purchases
                /*
                if (collection.blindMintEnabled && state.escrowClient && state.escrowAccount && state.escrowAddress && req.userClient) {
                    console.log("üîÑ [STEP 5B] Transferring NFT to escrow for blind mint...");
                    try {
                        const account = req.userClient?.account || req.userAccount;
                        const transferBuilder = req.userClient.initBuilder();
                        transferBuilder.updateAccounts({ signer: account, account });
                        
                        const escrowAccount = KeetaNet.lib.Account.fromPublicKeyString(state.escrowAddress);
                        const nftAccount = KeetaNet.lib.Account.fromPublicKeyString(tokenId);
                        
                        transferBuilder.send(escrowAccount, 1n, nftAccount);
                        await req.userClient.computeBuilderBlocks(transferBuilder);
                        await req.userClient.publishBuilder(transferBuilder);
                        
                        // Update Firebase to show escrow as owner
                        await updateDoc(doc(this.db, 'nfts', docId), {
                            owner: state.escrowAddress,
                            inEscrow: true
                        });
                        
                        console.log("‚úÖ [STEP 5B] NFT transferred to escrow");
                    } catch (escrowError) {
                        console.warn("‚ö†Ô∏è Escrow transfer failed:", escrowError);
                        // NFT still exists in user wallet, they can manually transfer or list normally
                    }
                }
                */
                
                return docId;
            }

            async executeMint(req) {
                let mintIndex = null;
                let collectionRef = null;
                
                // üìä PERFORMANCE MONITORING START
                const perfStart = performance.now();
                const timings = {};
                
                try {
                    if (typeof req.userClient?.init === 'function') await req.userClient.init();
                    
                    // Store collection ref FIRST for potential rollback
                    collectionRef = doc(this.db, 'collections', req.collectionId);
                    
                    // Validation timing
                    const t1 = performance.now();
                    const validation = await this.validateMintRequest(req);
                    timings.validation = (performance.now() - t1).toFixed(0);
                    if (!validation.valid) return { success: false, error: validation.error };
                    
                    // Metadata resolution timing (includes Firebase mint index increment)
                    const t2 = performance.now();
                    const { metadata, imagePath, mintIndex: resolvedIndex } = await this.resolveMetadata(req.collectionId);
                    timings.metadata = (performance.now() - t2).toFixed(0);
                    mintIndex = resolvedIndex;
                    
                    const collection = await this.getCollection(req.collectionId);
                    
                    // NFT token creation timing (TX1 + TX2)
                    const t3 = performance.now();
                    const tokenId = await this.createNFTToken(req, metadata, collection);
                    timings.tokenCreation = (performance.now() - t3).toFixed(0);
                    
                    // Payment execution timing
                    const t4 = performance.now();
                    const txHash = await this.executePayment(req, collection);
                    timings.payment = (performance.now() - t4).toFixed(0);
                    
                    // Firebase commit timing
                    const t5 = performance.now();
                    const nftId = await this.commitToFirebase(req, tokenId, metadata, imagePath, txHash, mintIndex, collection);
                    timings.firebase = (performance.now() - t5).toFixed(0);
                    
                    // üìä PERFORMANCE MONITORING END
                    const perfEnd = performance.now();
                    const totalTime = (perfEnd - perfStart).toFixed(0);
                    
                    // üåê NETWORK QUALITY INDICATOR
                    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                    const networkType = connection?.effectiveType || 'unknown';
                    const downlink = connection?.downlink ? `${connection.downlink}Mbps` : 'unknown';
                    const rtt = connection?.rtt ? `${connection.rtt}ms` : 'unknown';
                    
                    console.log(`üìä MINT PERFORMANCE REPORT:`);
                    console.log(`   üéØ Mint Index: ${mintIndex}`);
                    console.log(`   ‚è±Ô∏è Total Time: ${totalTime}ms (${(totalTime/1000).toFixed(1)}s)`);
                    console.log(`   üìã Breakdown:`);
                    console.log(`      - Validation: ${timings.validation}ms`);
                    console.log(`      - Metadata/Index: ${timings.metadata}ms`);
                    console.log(`      - Token Creation (TX1+TX2): ${timings.tokenCreation}ms`);
                    console.log(`      - Payment: ${timings.payment}ms`);
                    console.log(`      - Firebase: ${timings.firebase}ms`);
                    console.log(`   üåê Network Quality:`);
                    console.log(`      - Status: ${navigator.onLine ? 'üü¢ Online' : 'üî¥ Offline'}`);
                    console.log(`      - Type: ${networkType}`);
                    console.log(`      - Speed: ${downlink}`);
                    console.log(`      - Latency: ${rtt}`);
                    
                    return { success: true, nftId, tokenId, txHash, perfMetrics: { totalTime, timings, mintIndex } };
                    
                } catch (error) {
                    console.error("‚ùå Mint pipeline failed:", error);
                    
                    // CRITICAL: Rollback mint index if we got past metadata resolution
                    if (mintIndex !== null && collectionRef) {
                        try {
                            console.log(`üîÑ Rolling back mint index ${mintIndex} due to pipeline failure`);
                            
                            // Check state before rollback
                            const beforeRollback = await getDoc(collectionRef);
                            console.log(`üìâ BEFORE rollback: mintedCount=${beforeRollback.data().mintedCount}, remainingSupply=${beforeRollback.data().remainingSupply}`);
                            
                            await updateDoc(collectionRef, {
                                mintedCount: increment(-1),
                                remainingSupply: increment(1)
                            });
                            
                            // Check state after rollback
                            const afterRollback = await getDoc(collectionRef);
                            console.log(`üìâ AFTER rollback: mintedCount=${afterRollback.data().mintedCount}, remainingSupply=${afterRollback.data().remainingSupply}`);
                            console.log(`‚úÖ Rollback successful - mint cancelled`);
                        } catch (rollbackErr) {
                            console.error("‚ùå Rollback failed:", rollbackErr);
                            // Even worse - supply is now incorrect
                            return { 
                                success: false, 
                                error: `Mint failed AND rollback failed: ${error?.message}. Contact admin.` 
                            };
                        }
                    }
                    
                    return { 
                        success: false, 
                        error: error?.message || String(error),
                        rolled_back: mintIndex !== null 
                    };
                }
            }
        };

        // Expose pipeline factory for use: new KeetaMintPipeline(db, state.appId)
        window.createKeetaMintPipeline = () => new window.KeetaMintPipeline(db, state.appId);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // OFFER SYSTEM - Make and manage offers
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        let offerState = {
            currentNFT: null,
            currentCollection: null,
            isCollectionOffer: false
        };

        window.makeOfferOnNFT = async (nftId) => {
            if (!state.address) {
                return window.notify("Connect wallet first", "error");
            }
            const nft = state.nfts.find(n => n.id === nftId);
            if (!nft) return window.notify("NFT not found", "error");
            if (nft.owner && nft.owner.toLowerCase() === state.address.toLowerCase()) {
                return window.notify("Cannot make offer on your own NFT", "error");
            }
            offerState.currentNFT = nft;
            offerState.isCollectionOffer = false;
            offerState.currentCollection = null;
            
            // FIX: Handle external NFTs (like PFP) properly
            const imgPath = window.getNFTImagePath(nft);
            let imgUrl;
            if (nft.isExternal && imgPath && (imgPath.startsWith('http://') || imgPath.startsWith('https://'))) {
                imgUrl = imgPath; // Already a full URL
            } else if (imgPath) {
                imgUrl = getIPFSUrl(imgPath);
            } else {
                imgUrl = '';
            }
            
            document.getElementById('offerNFTPreview').innerHTML = `<img src="${imgUrl}" class="w-full h-full object-cover rounded-lg">`;
            document.getElementById('offerNFTName').textContent = nft.name || 'Unknown NFT';
            document.getElementById('offerNFTOwner').textContent = nft.owner ? nft.owner.substring(0, 20) + '...' : 'Unknown';
            document.getElementById('offerNFTListed').textContent = nft.isListed ? `${nft.listedPrice} ${nft.listedCurrency}` : 'Not Listed';
            const subEl = document.getElementById('offerModalSubtitle');
            if (subEl) subEl.textContent = 'Propose a price to the NFT owner';
            document.getElementById('offerKTABalance').textContent = (state.balanceKTA || 0).toFixed(2);
            document.getElementById('offerPUNKSBalance').textContent = (state.balancePunks || 0).toLocaleString();
            document.getElementById('offerAmountInput').value = '';
            const ktaRadio = document.querySelector('input[name="offerCurrency"][value="KTA"]');
            if (ktaRadio) ktaRadio.checked = true;
            window.updateOfferSummary();
            document.getElementById('offerModal').classList.remove('hidden');
        };

        window.makeOfferOnCollection = async (colToken) => {
            if (!state.address) return window.notify("Connect wallet first", "error");
            const colNfts = state.nfts.filter(n => getNormalizedId(n.collectionToken) === getNormalizedId(colToken));
            const base = colNfts[0];
            if (!base) return window.notify("Collection not found", "error");
            const listedNfts = colNfts.filter(n => n.isListed);
            const ktaListings = listedNfts.filter(n => n.listedCurrency === 'KTA');
            const punksListings = listedNfts.filter(n => n.listedCurrency === 'PUNKS');
            const floorKTA = ktaListings.length > 0 ? Math.min(...ktaListings.map(n => n.listedPrice)) : null;
            const floorPUNKS = punksListings.length > 0 ? Math.min(...punksListings.map(n => n.listedPrice)) : null;
            const floorText = floorKTA ? `${floorKTA} KTA` : (floorPUNKS ? `${floorPUNKS} PUNKS` : 'N/A');
            offerState.currentNFT = null;
            offerState.currentCollection = {
                collectionId: base.collectionId,
                collectionTitle: base.collection || base.collectionTitle || 'Unknown Collection'
            };
            offerState.isCollectionOffer = true;
            
            // FIX: Handle external NFTs (like PFP) properly
            const thumbCid = base.collectionThumbnailCid || window.getNFTImagePath(base);
            let imgUrl;
            if (base.isExternal && thumbCid && (thumbCid.startsWith('http://') || thumbCid.startsWith('https://'))) {
                imgUrl = thumbCid; // Already a full URL
            } else if (thumbCid) {
                imgUrl = `${getIPFSUrl(thumbCid)}`;
            } else {
                imgUrl = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Crect fill='%23000' width='400' height='400'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%2300ffff' font-size='20'%3ECLASSIFIED%3C/text%3E%3C/svg%3E`;
            }
            
            document.getElementById('offerNFTPreview').innerHTML = `<img src="${imgUrl}" class="w-full h-full object-cover rounded-lg">`;
            document.getElementById('offerNFTName').textContent = offerState.currentCollection.collectionTitle;
            document.getElementById('offerNFTOwner').textContent = `${colNfts.length} items`;
            document.getElementById('offerNFTListed').textContent = `Floor: ${floorText}`;
            const subEl = document.getElementById('offerModalSubtitle');
            if (subEl) subEl.textContent = 'Offer KTA or PUNKS for any NFT in this collection';
            document.getElementById('offerKTABalance').textContent = (state.balanceKTA || 0).toFixed(2);
            document.getElementById('offerPUNKSBalance').textContent = (state.balancePunks || 0).toLocaleString();
            document.getElementById('offerAmountInput').value = '';
            const ktaRadio = document.querySelector('input[name="offerCurrency"][value="KTA"]');
            if (ktaRadio) ktaRadio.checked = true;
            window.updateOfferSummary();
            document.getElementById('offerModal').classList.remove('hidden');
        };

        window.closeOfferModal = () => {
            document.getElementById('offerModal').classList.add('hidden');
            offerState.currentNFT = null;
            offerState.currentCollection = null;
            offerState.isCollectionOffer = false;
        };

        window.updateOfferSummary = () => {
            const amount = parseFloat(document.getElementById('offerAmountInput')?.value || 0);
            const currency = document.querySelector('input[name="offerCurrency"]:checked')?.value || 'KTA';
            if (isNaN(amount) || amount <= 0) {
                document.getElementById('offerTotal').textContent = '0.00 ' + currency;
                return;
            }
            document.getElementById('offerTotal').textContent = `${amount.toFixed(2)} ${currency}`;
        };

        window.submitOffer = async () => {
            if (!state.address) return window.notify("Connect wallet first", "error");
            const amount = parseFloat(document.getElementById('offerAmountInput')?.value || 0);
            const currency = document.querySelector('input[name="offerCurrency"]:checked')?.value || 'KTA';
            if (isNaN(amount) || amount <= 0) return window.notify("Enter valid offer amount", "error");
            if (currency === 'KTA' && (state.balanceKTA || 0) < amount) {
                return window.notify(`Insufficient KTA balance (need ${amount}, have ${(state.balanceKTA || 0).toFixed(2)})`, "error");
            }
            if (currency === 'PUNKS' && (state.balancePunks || 0) < amount) {
                return window.notify(`Insufficient PUNKS balance (need ${amount}, have ${state.balancePunks})`, "error");
            }
            try {
                window.notify("Submitting offer...", "success");
                
                // LOCK KTA IN ESCROW when making offer
                let escrowLockTxHash = null;
                if (currency === 'KTA') {
                    window.notify("Locking KTA in escrow...", "success");
                    const builder = state.keetaClient.initBuilder();
                    builder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                    builder.send(
                        KeetaNet.lib.Account.fromPublicKeyString(ESCROW_ADDRESS), // Send to escrow (public address)
                        BigInt(Math.floor(amount * KTA_DECIMALS)),
                        state.keetaClient.baseToken
                    );
                    await state.keetaClient.computeBuilderBlocks(builder);
                    const tx = await state.keetaClient.publishBuilder(builder);
                    escrowLockTxHash = tx?.voteStaple?.blocks?.[0]?.$hash || tx?.hash || null;
                    console.log("‚úÖ KTA locked in escrow:", escrowLockTxHash);
                }
                
                const offer = {
                    id: `offer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: offerState.isCollectionOffer ? 'collection' : 'nft',
                    offerer: state.address,
                    amount: amount,
                    currency: currency,
                    createdAt: new Date().toISOString(),
                    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                    status: 'active',
                    inEscrow: currency === 'KTA', // Mark if funds are in escrow
                    escrowLockTxHash: escrowLockTxHash // Store escrow tx hash
                };
                
                if (offerState.isCollectionOffer && offerState.currentCollection) {
                    offer.collectionId = offerState.currentCollection.collectionId;
                    offer.collectionTitle = offerState.currentCollection.collectionTitle;
                    offer.note = 'Floor offer for any NFT in this collection';
                } else if (offerState.currentNFT) {
                    offer.nftId = offerState.currentNFT.id;
                    offer.nftName = offerState.currentNFT.name;
                    offer.nftOwner = offerState.currentNFT.owner;
                    offer.collectionId = offerState.currentNFT.collectionId;
                    offer.collectionName = offerState.currentNFT.collection || offerState.currentNFT.collectionTitle;
                }
                
                await setDoc(doc(db, 'offers', offer.id), offer);
                
                console.log("‚úÖ Offer created:", offer.id);
                
                window.notify(`‚úÖ Offer submitted: ${amount} ${currency}`, "success");
                window.closeOfferModal();
                
                // Refresh
                if (typeof window.loadOffers === 'function') await window.loadOffers();
                
                // Show helpful message
                setTimeout(() => {
                    window.notify(`üí∞ Your offer is now active! Check the Offers tab to view it.`, "success");
                }, 1500);
                
            } catch (error) {
                console.error("Error submitting offer:", error);
                window.notify("Failed to submit offer: " + error.message, "error");
            }
        };

        window.loadOffers = async () => {
            if (!state.address || !db) return;
            try {
                const offersRef = collection(db, 'offers');
                const snapshot = await getDocs(offersRef);
                state.offers = [];
                state.myOffers = [];
                state.offersOnMyNFTs = [];
                
                console.log(`üì• Loading offers for wallet: ${state.address}`);
                
                snapshot.forEach(d => {
                    const offer = { id: d.id, ...d.data() };
                    
                    // Debug logging
                    console.log(`  Checking offer ${offer.id}:`, {
                        offerer: offer.offerer,
                        status: offer.status,
                        expired: offer.expiresAt && new Date(offer.expiresAt) < new Date()
                    });
                    
                    // Skip expired offers
                    if (offer.expiresAt && new Date(offer.expiresAt) < new Date()) {
                        console.log(`  ‚è≠Ô∏è Skipping expired offer`);
                        return;
                    }
                    
                    // Skip non-active offers
                    if (offer.status && offer.status !== 'active') {
                        console.log(`  ‚è≠Ô∏è Skipping non-active offer (status: ${offer.status})`);
                        return;
                    }
                    
                    state.offers.push(offer);
                    
                    // Check if it's MY offer (case-insensitive)
                    if (offer.offerer && offer.offerer.toLowerCase() === state.address.toLowerCase()) {
                        console.log(`  ‚úÖ This is MY offer!`);
                        state.myOffers.push(offer);
                    }
                    
                    // Check if it's an offer ON MY NFT
                    if (offer.type === 'nft') {
                        const nft = state.nfts.find(n => n.id === offer.nftId);
                        if (nft && nft.owner && nft.owner.toLowerCase() === state.address.toLowerCase()) {
                            console.log(`  ‚úÖ This is an offer ON MY NFT!`);
                            state.offersOnMyNFTs.push(offer);
                        }
                    }
                });
                
                console.log(`‚úÖ Loaded ${state.offers.length} offers (${state.myOffers.length} mine, ${state.offersOnMyNFTs.length} on my NFTs)`);
                if (typeof window.renderOffers === 'function') window.renderOffers();
            } catch (error) {
                console.error("Error loading offers:", error);
            }
        };

        window.renderOffers = () => {
            const onMyList = document.getElementById('offersOnMyNFTsList');
            const myList = document.getElementById('myOffersList');
            if (!onMyList || !myList) return;
            const incoming = state.offersOnMyNFTs || [];
            const outgoing = state.myOffers || [];
            onMyList.innerHTML = incoming.length === 0
                ? '<p class="text-gray-500 fira text-sm py-8 text-center">No offers on your NFTs yet</p>'
                : incoming.map(o => {
                    const nft = state.nfts.find(n => n.id === o.nftId);
                    const imgPath = nft ? window.getNFTImagePath(nft) : '';
                    const imgUrl = imgPath ? getIPFSUrl(imgPath) : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23333%22/%3E%3C/svg%3E';
                    return `<div class="flex items-center gap-4 p-4 bg-black/40 rounded-lg border border-cyan-500/20">
                        <img src="${imgUrl}" class="w-16 h-16 rounded-lg object-cover">
                        <div class="flex-1 min-w-0">
                            <p class="orbitron text-sm font-bold text-white truncate">${o.nftName || 'NFT'}</p>
                            <p class="fira text-xs text-cyan-400">${o.amount} ${o.currency} from ${(o.offerer || '').substring(0, 16)}...</p>
                        </div>
                        <button onclick="window.acceptOffer('${o.id}')" class="btn-primary !py-1 px-3 !text-[9px]">Accept</button>
                    </div>`;
                }).join('');
            myList.innerHTML = outgoing.length === 0
                ? '<p class="text-gray-500 fira text-sm py-8 text-center">No offers made yet</p>'
                : outgoing.map(o => {
                    const nft = state.nfts.find(n => n.id === o.nftId);
                    const imgPath = nft ? window.getNFTImagePath(nft) : '';
                    const imgUrl = imgPath ? getIPFSUrl(imgPath) : 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect fill=%22%23333%22/%3E%3C/svg%3E';
                    return `<div class="flex items-center gap-4 p-4 bg-black/40 rounded-lg border border-purple-500/20">
                        <img src="${imgUrl}" class="w-16 h-16 rounded-lg object-cover">
                        <div class="flex-1 min-w-0">
                            <p class="orbitron text-sm font-bold text-white truncate">${o.nftName || 'NFT'}</p>
                            <p class="fira text-xs text-magenta-400">${o.amount} ${o.currency} ‚Ä¢ ${o.status || 'active'}</p>
                        </div>
                        <button onclick="window.cancelOffer('${o.id}')" class="p-2 text-red-400 hover:bg-red-500/10 rounded text-[9px]">Cancel</button>
                    </div>`;
                }).join('');
        };

        window.acceptOffer = async (offerId) => {
            const offer = state.offers.find(o => o.id === offerId);
            if (!offer) return window.notify("Offer not found", "error");
            
            const nft = state.nfts.find(n => n.id === offer.nftId);
            if (!nft || nft.owner.toLowerCase() !== state.address.toLowerCase()) {
                return window.notify("You don't own this NFT", "error");
            }
            
            // Calculate fee splits
            const offerAmount = parseFloat(offer.amount);
            const collection = state.collections.find(c => 
                c.collectionId === nft.collectionId || 
                c.collectionToken === nft.collectionToken
            );
            const royaltyPercent = collection?.creatorRoyaltyPercent || SECONDARY_SALE_CREATOR_ROYALTY_PERCENT;
            const marketplaceFeePercent = SECONDARY_SALE_MARKETPLACE_PERCENT;
            const sellerPercent = 1 - royaltyPercent - marketplaceFeePercent;
            
            const sellerPayout = offerAmount * sellerPercent;
            const creatorRoyalty = offerAmount * royaltyPercent;
            const marketplaceFee = offerAmount * marketplaceFeePercent;
            
            const confirmed = await window.showCustomConfirm({
                icon: 'üí∞',
                title: 'Accept Offer',
                message: `Accept offer of ${offer.amount} ${offer.currency} for ${nft.name}?\n\nYou will receive: ${sellerPayout.toFixed(2)} ${offer.currency}\nCreator royalty: ${creatorRoyalty.toFixed(2)} ${offer.currency}\nMarketplace fee: ${marketplaceFee.toFixed(2)} ${offer.currency}`,
                confirmText: '‚úÖ Accept Offer',
                danger: false
            });
            
            if (!confirmed) return;
            
            try {
                window.notify("Processing offer acceptance...", "success");
                console.log("üí∞ Accepting offer:", offer);
                console.log("üí∞ Fee breakdown:", {
                    total: offerAmount,
                    seller: sellerPayout,
                    creator: creatorRoyalty,
                    marketplace: marketplaceFee
                });
                
                const buyerWallet = offer.offerer;
                const sellerWallet = state.address;
                const currency = offer.currency;
                
                // RELEASE ESCROWED FUNDS - Escrow pays seller, creator, marketplace
                // NOTE: Offers system needs Cloud Function for escrow payment release
                // For now, if escrow funds are involved, use Cloud Function
                window.notify("Processing payments...", "success");
                
                // TODO: When offers hold funds in escrow, use a Cloud Function to release them
                // For now, offers are trust-based (buyer sends payment directly at acceptance)
                console.log("‚ö†Ô∏è Offer acceptance: escrow payment release not yet implemented via Cloud Functions");
                console.log("üí≥ Proceeding with trust-based offer acceptance");
                
                // Seller sends NFT directly to buyer (seller signs)
                // Payment was already escrowed or will be sent by buyer
                const paymentTx = { hash: 'offer_acceptance_' + Date.now() };
                
                console.log("‚úÖ Offer payment processed");
                console.log(`  - Seller: ${sellerPayout.toFixed(4)} KTA to ${sellerWallet}`);
                console.log(`  - Creator: ${creatorRoyalty.toFixed(4)} KTA to ${nft.creator}`);
                console.log(`  - Marketplace: ${marketplaceFee.toFixed(4)} KTA to ${MARKETPLACE_FEE_WALLET}`);
                
                // SELLER SENDS NFT TO BUYER ON BLOCKCHAIN
                window.notify("Transferring NFT on blockchain...", "success");
                
                const nftBuilder = state.keetaClient.initBuilder();
                nftBuilder.updateAccounts({ signer: state.keetaAccount, account: state.keetaAccount });
                nftBuilder.send(
                    KeetaNet.lib.Account.fromPublicKeyString(buyerWallet),
                    1n, // 1 NFT
                    KeetaNet.lib.Account.fromPublicKeyString(nft.tokenId)
                );
                
                await state.keetaClient.computeBuilderBlocks(nftBuilder);
                const nftTransferTx = await state.keetaClient.publishBuilder(nftBuilder);
                
                console.log("‚úÖ NFT transferred on blockchain:", nftTransferTx);
                
                // Update NFT ownership in Firebase
                window.notify("Updating database...", "success");
                
                const nftRef = doc(db, 'nfts', nft.id);
                await updateDoc(nftRef, {
                    owner: buyerWallet,
                    previousOwner: sellerWallet,
                    lastTransferredAt: new Date().toISOString(),
                    isListed: false,
                    listedPrice: null,
                    listedCurrency: null
                });
                
                console.log("‚úÖ NFT ownership transferred");
                
                // Create transaction record
                window.notify("Recording transaction...", "success");
                
                const transactionId = `tx_offer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const transactionData = {
                    id: transactionId,
                    type: 'offer_accepted',
                    nftId: nft.id,
                    nftName: nft.name,
                    nftImage: nft.imagePath || nft.imageCid,
                    collectionId: nft.collectionId || nft.collection,
                    collection: nft.collectionTitle || nft.collection || 'Unknown',
                    price: offerAmount,
                    currency: currency,
                    seller: sellerWallet,
                    sellerWallet: sellerWallet,
                    buyer: buyerWallet,
                    wallet: sellerWallet,
                    offerId: offerId,
                    timestamp: new Date().toISOString(),
                    txHash: `offer_${offerId}`,
                    status: 'completed',
                    // Fee breakdown
                    sellerPayout: sellerPayout,
                    creatorRoyalty: creatorRoyalty,
                    marketplaceFee: marketplaceFee,
                    creatorAddress: nft.creator,
                    marketplaceAddress: MARKETPLACE_FEE_WALLET
                };
                
                // Save transaction for seller
                await setDoc(
                    doc(db, 'transactions', transactionId),
                    transactionData
                );
                
                // Save transaction for buyer
                const buyerTransactionId = `${transactionId}_buyer`;
                await setDoc(
                    doc(db, 'transactions', buyerTransactionId),
                    {
                        ...transactionData,
                        id: buyerTransactionId,
                        wallet: buyerWallet,
                        type: 'offer_purchase'
                    }
                );
                
                console.log("‚úÖ Transaction records created");
                
                // Update offer status
                await updateDoc(
                    doc(db, 'offers', offerId),
                    {
                        status: 'accepted',
                        acceptedAt: new Date().toISOString(),
                        transactionId: transactionId
                    }
                );
                
                // Update wallet stats for seller
                await window.updateWalletStats({
                    type: 'sale',
                    price: sellerPayout, // Use seller payout, not total
                    currency: currency,
                    timestamp: new Date().toISOString()
                });
                
                console.log("‚úÖ Offer acceptance complete!");
                window.notify(`‚úÖ Offer accepted! You received ${sellerPayout.toFixed(2)} ${currency}`, "success");
                
                // Refresh data
                await window.loadOffers();
                await window.loadNFTsFromFirebase();
                await window.loadTransactions();
                window.renderMarketplace();
                
                // If user is on collection tab, refresh it
                const collectionTab = document.getElementById('tab-collection');
                if (collectionTab && !collectionTab.classList.contains('hidden')) {
                    window.renderCollection();
                }
                
            } catch (error) {
                console.error("‚ùå Error accepting offer:", error);
                window.notify("Failed to accept offer: " + error.message, "error");
            }
        };
        window.cancelOffer = async (offerId) => {
            const offer = state.offers.find(o => o.id === offerId);
            if (!offer || offer.offerer.toLowerCase() !== state.address.toLowerCase()) {
                return window.notify("Can only cancel your own offers", "error");
            }
            
            try {
                // REFUND FROM ESCROW if funds were locked
                if (offer.inEscrow && offer.currency === 'KTA') {
                    window.notify("Refunding KTA from escrow...", "success");
                    
                    // TODO: Implement refund via Cloud Function when offer escrow is enabled
                    console.log("‚ö†Ô∏è Offer escrow refund not yet implemented via Cloud Functions");
                    console.log("üí≥ Offer marked as cancelled - manual refund may be needed");
                }
                
                await updateDoc(doc(db, 'offers', offerId), {
                    status: 'cancelled',
                    cancelledAt: new Date().toISOString()
                });
                
                window.notify("‚úÖ Offer cancelled and refunded", "success");
                await window.loadOffers();
                await window.refreshBalance(); // Refresh balance after refund
                
            } catch (error) {
                console.error("‚ùå Error cancelling offer:", error);
                window.notify("Failed to cancel offer: " + error.message, "error");
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UI WIPE & RELOAD FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.updateCachedItemsDisplay = () => {
            const nftsCount = document.getElementById('cachedNFTsCount');
            const collectionsCount = document.getElementById('cachedCollectionsCount');
            const transactionsCount = document.getElementById('cachedTransactionsCount');
            const totalCount = document.getElementById('cachedItemsCount');
            
            if (nftsCount) nftsCount.textContent = state.nfts?.length || 0;
            if (collectionsCount) collectionsCount.textContent = state.collections?.length || 0;
            if (transactionsCount) transactionsCount.textContent = state.transactions?.length || 0;
            if (totalCount) {
                const total = (state.nfts?.length || 0) + (state.collections?.length || 0) + (state.transactions?.length || 0);
                totalCount.textContent = total;
            }
        };
        
        window.wipeUIAndReload = async (hardWipe = false) => {
            const confirmMsg = hardWipe 
                ? "‚ö†Ô∏è HARD WIPE: This will clear ALL cached data and force a complete reload. Continue?"
                : "üîÑ SOFT RELOAD: This will refresh data from database. Continue?";
            
            if (!confirm(confirmMsg)) return;
            
            try {
                console.log(`üî• ${hardWipe ? 'HARD' : 'SOFT'} WIPE INITIATED`);
                window.notify(`${hardWipe ? 'üí•' : 'üîÑ'} Wiping UI cache...`, "success");
                
                if (hardWipe) {
                    // HARD WIPE: Clear everything
                    console.log("üí• Clearing all state...");
                    
                    // Clear all state arrays
                    state.nfts = [];
                    state.collections = [];
                    state.transactions = [];
                    state.allTransactions = [];
                    state.offers = [];
                    state.offersOnMyNFTs = [];
                    state.myOffers = [];
                    state.traitCounts = {};
                    state.viewingCollection = null;
                    
                    // Clear session storage
                    try {
                        sessionStorage.clear();
                        console.log("‚úÖ Session storage cleared");
                    } catch (e) {
                        console.warn("‚ö†Ô∏è Could not clear session storage:", e);
                    }
                    
                    // Clear any chart data
                    if (window.currentChart) {
                        window.currentChart.destroy();
                        window.currentChart = null;
                    }
                    
                    console.log("‚úÖ State wiped clean");
                }
                
                // Force reload all data from Firebase
                window.notify("üì• Loading fresh data from database...", "success");
                console.log("üì• Loading fresh data from Firebase...");
                
                await window.loadNFTsFromFirebase();
                await window.loadCollections();
                await window.loadTraitCounts();
                
                if (state.address) {
                    await window.loadTransactions();
                    await window.loadOffers();
                }
                
                // Re-render all views
                window.notify("üé® Refreshing all views...", "success");
                console.log("üé® Re-rendering all views...");
                
                window.renderMarketplace();
                window.renderDrops();
                window.renderCollection();
                window.populateChartSelector();
                await window.initFloorPulseChart();
                
                // Update the cached items display
                window.updateCachedItemsDisplay();
                
                console.log("‚úÖ UI WIPE COMPLETE!");
                window.notify(`‚úÖ ${hardWipe ? 'Hard wipe' : 'Soft reload'} complete! UI synced with database.`, "success");
                
            } catch (error) {
                console.error("‚ùå Error during wipe:", error);
                window.notify("‚ùå Wipe failed: " + error.message, "error");
            }
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AUTO FIREBASE DATABASE WIPE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        window.autoWipeFirebaseDatabase = async function() {
            console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üî• FIREBASE DATABASE AUTO-WIPE
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë This will DELETE:
‚ïë   ‚ùå All NFTs
‚ïë   ‚ùå All Transactions  
‚ïë   ‚ùå All Offers/Bids/Auctions
‚ïë   ‚ùå All Comments
‚ïë 
‚ïë This will PRESERVE:
‚ïë   ‚úÖ Collection definitions
‚ïë   ‚úÖ Whitelist settings
‚ïë   ‚úÖ Trait counts
‚ïë 
‚ïë This will RESET:
‚ïë   üîÑ Collection mint counters to 0
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            `);
            
            // Check if user is authenticated
            if (!state.address) {
                window.notify('‚ùå You must be connected with your wallet first!', 'error');
                console.error('‚ùå ERROR: You must be connected with your wallet first!');
                console.log('üí° TIP: Connect your wallet, then try again.');
                return;
            }
            
            // Check if user is escrow wallet (admin only)
            // FIX: Use global ESCROW_WALLET constant instead of duplicate declaration
            if (state.address !== ESCROW_WALLET) {
                window.notify('‚ùå Only the admin wallet can wipe the database!', 'error');
                console.error('‚ùå ERROR: Only the escrow wallet can run database wipes!');
                console.log('Current wallet:', state.address);
                console.log('Required wallet:', ESCROW_WALLET);
                return;
            }
            
            // Final confirmation
            const confirmed = confirm(`‚ö†Ô∏è FINAL WARNING ‚ö†Ô∏è

This will PERMANENTLY DELETE all NFTs, transactions, offers, and comments from Firebase!

Are you absolutely sure you want to proceed?

Click OK to wipe database.
Click Cancel to abort.`);
            
            if (!confirmed) {
                console.log('‚ùå Database wipe cancelled by user.');
                window.notify('Database wipe cancelled', 'error');
                return;
            }
            
            try {
                console.log('üî• Starting Firebase database wipe...\n');
                window.notify('üî• Wiping Firebase database...', 'success');
                
                // Collections to wipe
                const WIPE_COLLECTIONS = ['nfts', 'transactions', 'offers', 'bids', 'auctions', 'comments'];
                
                const stats = {
                    totalDeleted: 0,
                    byCollection: {}
                };
                
                // Step 1: Delete all documents from wipe collections
                for (const collectionName of WIPE_COLLECTIONS) {
                    try {
                        console.log(`üì¶ Processing collection: ${collectionName}`);
                        window.notify(`üóëÔ∏è Deleting ${collectionName}...`, 'success');
                        
                        const collectionRef = collection(db, collectionName);
                        const snapshot = await getDocs(collectionRef);
                        
                        if (snapshot.empty) {
                            console.log(`   ‚ÑπÔ∏è  Collection is already empty`);
                            stats.byCollection[collectionName] = 0;
                            continue;
                        }
                        
                        console.log(`   üóëÔ∏è  Found ${snapshot.size} documents to delete...`);
                        
                        // Delete all documents
                        let deleted = 0;
                        for (const docSnapshot of snapshot.docs) {
                            try {
                                await deleteDoc(doc(db, collectionName, docSnapshot.id));
                                deleted++;
                                
                                // Progress indicator every 10 deletions
                                if (deleted % 10 === 0) {
                                    console.log(`   ‚è≥ Deleted ${deleted}/${snapshot.size}...`);
                                }
                            } catch (error) {
                                console.error(`   ‚ö†Ô∏è  Failed to delete document ${docSnapshot.id}:`, error.message);
                            }
                        }
                        
                        stats.byCollection[collectionName] = deleted;
                        stats.totalDeleted += deleted;
                        console.log(`   ‚úÖ Deleted ${deleted} documents from ${collectionName}\n`);
                        
                    } catch (error) {
                        console.error(`   ‚ùå Error wiping ${collectionName}:`, error.message);
                        stats.byCollection[collectionName] = 'ERROR';
                    }
                }
                
                // Step 2: Reset collection counters
                console.log('üîÑ Resetting collection mint counters...\n');
                window.notify('üîÑ Resetting collection counters...', 'success');
                
                try {
                    const collectionsRef = collection(db, 'collections');
                    const collectionsSnapshot = await getDocs(collectionsRef);
                    
                    let resetCount = 0;
                    for (const collectionDoc of collectionsSnapshot.docs) {
                        const data = collectionDoc.data();
                        const totalSupply = data.totalSupply || 0;
                        
                        try {
                            await updateDoc(doc(db, 'collections', collectionDoc.id), {
                                mintedCount: 0,
                                remainingSupply: totalSupply
                            });
                            
                            console.log(`   ‚úÖ Reset: ${data.collectionTitle || collectionDoc.id}`);
                            console.log(`      mintedCount: ${data.mintedCount || 0} ‚Üí 0`);
                            console.log(`      remainingSupply: ${data.remainingSupply || 0} ‚Üí ${totalSupply}\n`);
                            resetCount++;
                        } catch (error) {
                            console.error(`   ‚ùå Failed to reset ${collectionDoc.id}:`, error.message);
                        }
                    }
                    
                    console.log(`‚úÖ Reset ${resetCount} collection counters\n`);
                    
                } catch (error) {
                    console.error('‚ùå Error resetting collection counters:', error.message);
                }
                
                // Step 3: Display summary
                console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë üìä DATABASE WIPE COMPLETE!
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë Total Documents Deleted: ${stats.totalDeleted}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë Breakdown by Collection:
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                
                for (const [collectionName, count] of Object.entries(stats.byCollection)) {
                    const icon = count === 'ERROR' ? '‚ùå' : count === 0 ? '‚ÑπÔ∏è' : '‚úÖ';
                    console.log(`‚ïë   ${icon} ${collectionName}: ${count}`);
                }
                
                console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïë ‚úÖ Collections preserved: collections, whitelistSettings, traitCounts
‚ïë ‚úÖ Collection counters reset to 0
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                `);
                
                window.notify(`‚úÖ Database wiped! Deleted ${stats.totalDeleted} documents`, 'success');
                
                // Auto-trigger UI wipe after database wipe
                const autoWipeUI = confirm(`
‚úÖ Database wipe complete! Deleted ${stats.totalDeleted} documents.

Do you want to automatically wipe the UI cache now?

This will:
- Clear all cached NFTs, collections, transactions
- Reload fresh data from Firebase
- Sync UI with the now-empty database

Click OK to auto-wipe UI.
Click Cancel to do it manually later.`);
                
                if (autoWipeUI) {
                    console.log('üîÑ Triggering UI cache wipe...');
                    await window.wipeUIAndReload(true);
                } else {
                    console.log('‚ÑπÔ∏è  UI wipe skipped. Click "Hard Wipe & Reload" button when ready.');
                    window.notify('‚ö†Ô∏è Remember to wipe UI cache!', 'warning');
                }
                
            } catch (error) {
                console.error('üí• FATAL ERROR during database wipe:', error);
                window.notify('‚ùå Database wipe failed: ' + error.message, 'error');
            }
        };
        
        // DATABASE WIPE FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.confirmDatabaseWipe = () => {
            const confirmText = prompt(
                '‚ö†Ô∏è DANGER: This will PERMANENTLY delete ALL marketplace data from Firebase.\n\n' +
                'Type "WIPE MARKETPLACE" to confirm:'
            );
            
            if (confirmText === 'WIPE MARKETPLACE') {
                window.executeDatabaseWipe();
            } else if (confirmText !== null) {
                window.notify("Database wipe cancelled - incorrect confirmation", "error");
            }
        };
        
        window.executeDatabaseWipe = async () => {
            try {
                window.notify("üóëÔ∏è Starting database wipe...", "success");
                console.log("üóëÔ∏è DATABASE WIPE INITIATED");
                
                const collections = [
                    { name: 'nfts', label: 'NFTs' },
                    { name: 'collections', label: 'Collections' },
                    { name: 'transactions', label: 'Transactions' },
                    { name: 'offers', label: 'Offers' },
                    { name: 'whitelistWallets', label: 'Whitelist Wallets' },
                    { name: 'whitelistSettings', label: 'Whitelist Settings' },
                    { name: 'traitCounts', label: 'Trait Counts' },
                    { name: 'walletMintTracking', label: 'Wallet Tracking' },
                    { name: 'walletStats', label: 'Wallet Stats' }
                ];
                
                let totalDeleted = 0;
                
                for (const col of collections) {
                    try {
                        console.log(`üóëÔ∏è Wiping ${col.label}...`);
                        const colRef = collection(db, col.name);
                        const snapshot = await getDocs(colRef);
                        
                        if (snapshot.empty) {
                            console.log(`  ‚ÑπÔ∏è ${col.label}: Already empty`);
                            continue;
                        }
                        
                        console.log(`  üìä ${col.label}: Found ${snapshot.size} documents`);
                        
                        // Delete all documents in batches
                        const deletePromises = [];
                        snapshot.forEach((docSnap) => {
                            deletePromises.push(deleteDoc(doc(db, col.name, docSnap.id)));
                        });
                        
                        await Promise.all(deletePromises);
                        totalDeleted += snapshot.size;
                        
                        console.log(`  ‚úÖ ${col.label}: Deleted ${snapshot.size} documents`);
                        window.notify(`‚úÖ Deleted ${snapshot.size} ${col.label}`, "success");
                        
                    } catch (error) {
                        console.error(`  ‚ùå ${col.label}: Error -`, error);
                        window.notify(`‚ö†Ô∏è Error deleting ${col.label}`, "error");
                    }
                }
                
                console.log(`‚úÖ DATABASE WIPE COMPLETE: Deleted ${totalDeleted} total documents`);
                window.notify(`‚úÖ Database wiped: ${totalDeleted} documents deleted`, "success");
                
                // Clear local state
                state.nfts = [];
                state.collections = [];
                state.transactions = [];
                state.allTransactions = [];
                state.offers = [];
                state.offersOnMyNFTs = [];
                state.myOffers = [];
                state.traitCounts = {};
                state.whitelistSettings = {};
                state.whitelistWallets = {};
                state.viewingCollection = null;
                
                // Clear session storage
                try {
                    sessionStorage.clear();
                } catch (e) {
                    console.warn("Could not clear session storage:", e);
                }
                
                window.notify("üîÑ Reloading marketplace...", "success");
                
                // Wait 2 seconds then reload page
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
                
            } catch (error) {
                console.error("‚ùå Database wipe failed:", error);
                window.notify(`‚ùå Database wipe failed: ${error.message}`, "error");
            }
        };
        
        window.hardRefreshPage = () => {
            if (confirm("üîÑ This will refresh the entire page (like pressing F5). Continue?")) {
                window.location.reload(true);
            }
        };
        
        window.forceReload = async () => {
            // Legacy function - redirect to new wipe function
            await window.wipeUIAndReload(false);
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FORCE SYNC & GHOST DATA CLEANUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        window.forceSyncCollections = async () => {
            if (!confirm("üîÑ Force sync collections from Firebase? This will clear cached collections and reload from database.")) return;
            
            try {
                console.log("üîÑ Force syncing collections...");
                window.notify("üîÑ Syncing collections from Firebase...", "success");
                
                // Clear current collections
                state.collections = [];
                console.log("‚úÖ Cleared cached collections");
                
                // Reload from Firebase
                await window.loadCollections();
                
                // Reload related data
                await window.loadTraitCounts();
                
                // Refresh UI
                window.renderCollections();
                window.renderMarketplace();
                window.updateCachedItemsDisplay();
                
                window.notify(`‚úÖ Synced ${state.collections.length} collections from Firebase`, "success");
                console.log(`‚úÖ Collections synced: ${state.collections.length} found`);
                
            } catch (error) {
                console.error("‚ùå Force sync failed:", error);
                window.notify("‚ùå Sync failed: " + error.message, "error");
            }
        };
        
        window.clearGhostData = async () => {
            if (!confirm("üëª Clear ghost data? This will:\n- Clear collections with 0 NFTs\n- Clear invalid collection references\n- Force reload from database")) return;
            
            try {
                console.log("üëª Clearing ghost data...");
                window.notify("üëª Clearing ghost data...", "success");
                
                // Count NFTs per collection
                const collectionNFTCounts = {};
                state.nfts.forEach(nft => {
                    const colId = nft.collectionId || nft.collection;
                    collectionNFTCounts[colId] = (collectionNFTCounts[colId] || 0) + 1;
                });
                
                // Filter out collections with no NFTs or invalid data
                const beforeCount = state.collections.length;
                state.collections = state.collections.filter(col => {
                    const colId = col.collectionId || col.id;
                    const nftCount = collectionNFTCounts[colId] || 0;
                    
                    // Keep if has NFTs or is actively listed
                    return nftCount > 0 || col.blindMintEnabled === true;
                });
                
                const removed = beforeCount - state.collections.length;
                console.log(`üëª Removed ${removed} ghost collections (had 0 NFTs)`);
                
                // Reload from Firebase to get fresh data
                await window.loadCollections();
                await window.loadNFTsFromFirebase();
                
                // Refresh UI
                window.renderCollections();
                window.renderMarketplace();
                window.updateCachedItemsDisplay();
                
                window.notify(`‚úÖ Cleared ${removed} ghost collections. ${state.collections.length} valid collections remain.`, "success");
                
            } catch (error) {
                console.error("‚ùå Ghost cleanup failed:", error);
                window.notify("‚ùå Cleanup failed: " + error.message, "error");
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AUCTION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Load active auctions
        window.loadAuctions = async () => {
            console.log("üé™ Loading auctions...");
            
            try {
                const auctionsQuery = query(
                    collection(db, 'auctions'),
                    where('status', '==', 'active'),
                    orderBy('endTime', 'asc')
                );
                
                const snapshot = await getDocs(auctionsQuery);
                state.auctions = [];
                
                snapshot.forEach(doc => {
                    state.auctions.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(`‚úÖ Loaded ${state.auctions.length} active auctions`);
                
                // Load user's bids if connected
                if (state.address) {
                    await window.loadMyBids();
                }
                
            } catch (error) {
                console.error("‚ùå Error loading auctions:", error);
            }
        };
        
        // Load user's bids
        window.loadMyBids = async () => {
            if (!state.address) return;
            
            try {
                const bidsQuery = query(
                    collection(db, 'bids'),
                    where('bidder', '==', state.address),
                    orderBy('timestamp', 'desc')
                );
                
                const snapshot = await getDocs(bidsQuery);
                state.myBids = [];
                
                snapshot.forEach(doc => {
                    state.myBids.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(`‚úÖ Loaded ${state.myBids.length} of my bids`);
                
            } catch (error) {
                console.error("‚ùå Error loading bids:", error);
            }
        };
        
        // Render auctions grid
        window.renderAuctions = () => {
            const grid = document.getElementById('auctionsGrid');
            if (!grid) return;
            
            if (state.auctions.length === 0) {
                grid.innerHTML = '<div class="col-span-full text-center py-12 text-gray-500 fira text-sm">No active auctions</div>';
                return;
            }
            
            grid.innerHTML = state.auctions.map(auction => {
                const timeLeft = window.getTimeRemaining(auction.endTime);
                const isEnded = new Date(auction.endTime) <= new Date();
                const imgUrl = getIPFSUrl(auction.nftImage);
                const isMyAuction = auction.seller === state.address;
                const isHighestBidder = auction.highestBidder === state.address;
                
                return `
                    <div class="glass-card overflow-hidden hover:border-cyan-500/40 transition-all">
                        <div class="relative aspect-square bg-gradient-to-br from-purple-900/40 to-cyan-900/40">
                            ${isMyAuction ? '<div class="absolute top-2 right-2 bg-purple-500/90 px-2 py-1 rounded text-[9px] orbitron font-bold text-white">YOUR AUCTION</div>' : ''}
                            ${isHighestBidder ? '<div class="absolute top-2 right-2 bg-green-500/90 px-2 py-1 rounded text-[9px] orbitron font-bold text-white">HIGHEST BID</div>' : ''}
                            <img src="${imgUrl}" class="w-full h-full object-cover" alt="${auction.nftName}">
                        </div>
                        <div class="p-6 space-y-4">
                            <div>
                                <h4 class="orbitron text-sm font-bold text-white">${auction.nftName}</h4>
                                <div class="text-xs text-gray-500 mt-1">${auction.bidCount} bid${auction.bidCount !== 1 ? 's' : ''}</div>
                            </div>
                            
                            <div class="space-y-2">
                                <div>
                                    <div class="text-xs text-gray-500">Current Bid</div>
                                    <div class="text-xl font-bold text-cyan-400">${auction.currentBid} KTA</div>
                                </div>
                                ${auction.reservePrice > 0 ? `
                                <div>
                                    <div class="text-xs text-gray-500">Reserve Price</div>
                                    <div class="text-sm text-purple-400">${auction.reservePrice} KTA</div>
                                </div>
                                ` : ''}
                            </div>
                            
                            <div class="bg-black/40 p-3 rounded-lg border border-white/5">
                                <div class="text-[10px] text-gray-500 uppercase">Time ${isEnded ? 'Ended' : 'Remaining'}</div>
                                <div class="text-lg font-bold ${isEnded ? 'text-red-400' : 'text-cyan-400'} orbitron">${timeLeft}</div>
                            </div>
                            
                            ${!isEnded && !isMyAuction ? `
                                <button onclick="window.placeBid('${auction.id}')" class="btn-primary w-full py-2 text-sm">
                                    üíé Place Bid
                                </button>
                            ` : isMyAuction ? `
                                <div class="text-xs text-center text-gray-500">Your auction</div>
                                ${auction.bidCount === 0 ? `
                                    <button onclick="window.cancelAuction('${auction.id}')" class="w-full p-2 border border-red-500/30 text-red-400 rounded text-xs hover:bg-red-500/20 transition-all">
                                        Cancel Auction
                                    </button>
                                ` : ''}
                            ` : `
                                <div class="text-sm text-center text-red-400">Auction Ended</div>
                            `}
                        </div>
                    </div>
                `;
            }).join('');
        };
        
        // Get time remaining
        window.getTimeRemaining = (endTime) => {
            const now = new Date();
            const end = new Date(endTime);
            const diff = end - now;
            
            if (diff <= 0) return 'Ended';
            
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            if (minutes > 0) return `${minutes}m ${seconds}s`;
            return `${seconds}s`;
        };
        
        // Create auction - show modal
        window.createAuction = async (nftId) => {
            if (!state.address) return window.notify("Connect wallet first", "error");
            
            const nft = state.nfts.find(n => n.id === nftId);
            if (!nft) return window.notify("NFT not found", "error");
            
            if (nft.owner !== state.address) return window.notify("You don't own this NFT", "error");
            
            // Show auction creation modal
            window.showAuctionModal(nft);
        };
        
        // Show auction modal
        window.showAuctionModal = (nft) => {
            const modal = document.createElement('div');
            modal.id = 'auctionModal';
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-view';
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-2xl w-full space-y-6 border-2 border-cyan-500/30">
                    <h3 class="orbitron text-2xl text-cyan-400 font-bold uppercase">üé™ Create Auction</h3>
                    
                    <div class="flex gap-6">
                        <img src="${getIPFSUrl(window.getNFTImagePath(nft))}" 
                             class="w-48 h-48 rounded-lg object-cover border-2 border-white/10">
                        <div class="flex-1 space-y-4">
                            <div>
                                <label class="block text-xs orbitron text-gray-400 uppercase mb-2">NFT</label>
                                <div class="text-lg font-bold text-white">${nft.name}</div>
                            </div>
                            
                            <div>
                                <label class="block text-xs orbitron text-gray-400 uppercase mb-2">Starting Bid (KTA)</label>
                                <input type="number" id="auctionStartingBid" value="1" min="0.1" step="0.1"
                                       class="w-full bg-black/60 border-2 border-cyan-500/30 p-3 rounded-lg text-white outline-none focus:border-cyan-500">
                            </div>
                            
                            <div>
                                <label class="block text-xs orbitron text-gray-400 uppercase mb-2">Reserve Price (Optional)</label>
                                <input type="number" id="auctionReservePrice" placeholder="Minimum to sell" min="0" step="0.1"
                                       class="w-full bg-black/60 border-2 border-purple-500/30 p-3 rounded-lg text-white outline-none focus:border-purple-500">
                                <div class="text-[10px] text-gray-600 mt-1">Auction won't complete if reserve not met</div>
                            </div>
                            
                            <div>
                                <label class="block text-xs orbitron text-gray-400 uppercase mb-2">Duration</label>
                                <select id="auctionDuration" class="w-full bg-black/60 border-2 border-cyan-500/30 p-3 rounded-lg text-white outline-none">
                                    <option value="3600">1 Hour</option>
                                    <option value="21600">6 Hours</option>
                                    <option value="86400" selected>24 Hours</option>
                                    <option value="259200">3 Days</option>
                                    <option value="604800">7 Days</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-yellow-900/20 border-2 border-yellow-500/30 p-4 rounded-lg">
                        <div class="text-sm text-yellow-400 font-bold mb-2">‚ö†Ô∏è Important</div>
                        <div class="text-xs text-gray-400 space-y-1">
                            <div>‚Ä¢ NFT will be locked in auction until it ends</div>
                            <div>‚Ä¢ 3% marketplace fee deducted from winning bid</div>
                            <div>‚Ä¢ Winning bidder pays automatically when auction ends</div>
                        </div>
                    </div>
                    
                    <div class="flex gap-3">
                        <button onclick="document.getElementById('auctionModal').remove()" 
                                class="flex-1 p-3 rounded-lg border border-white/10 text-gray-400 hover:bg-white/5 transition-all">
                            Cancel
                        </button>
                        <button onclick="window.confirmCreateAuction('${nft.id}')" 
                                class="flex-1 btn-primary p-3">
                            üé™ Start Auction
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        // Confirm create auction
        window.confirmCreateAuction = async (nftId) => {
            const startingBid = parseFloat(document.getElementById('auctionStartingBid')?.value || 0);
            const reservePrice = parseFloat(document.getElementById('auctionReservePrice')?.value || 0);
            const duration = parseInt(document.getElementById('auctionDuration')?.value || 86400);
            
            if (startingBid <= 0) return window.notify("Invalid starting bid", "error");
            if (reservePrice > 0 && reservePrice < startingBid) {
                return window.notify("Reserve must be >= starting bid", "error");
            }
            
            try {
                window.notify("Creating auction...", "success");
                
                const nft = state.nfts.find(n => n.id === nftId);
                const endTime = new Date(Date.now() + (duration * 1000)).toISOString();
                
                // Create auction document (FLAT path)
                const auctionRef = doc(collection(db, 'auctions'));
                await setDoc(auctionRef, {
                    nftId: nftId,
                    nftToken: nft.tokenId,
                    nftName: nft.name,
                    nftImage: nft.imageCid,
                    seller: state.address,
                    startingBid: startingBid,
                    currentBid: startingBid,
                    reservePrice: reservePrice || 0,
                    highestBidder: null,
                    bidCount: 0,
                    startTime: new Date().toISOString(),
                    endTime: endTime,
                    status: 'active',
                    currency: 'KTA'
                });
                
                // Update NFT status (FLAT path)
                await updateDoc(doc(db, 'nfts', nftId), {
                    inAuction: true,
                    auctionId: auctionRef.id,
                    isListed: false,
                    listedPrice: null
                });
                
                document.getElementById('auctionModal')?.remove();
                window.notify("üé™ Auction created!", "success");
                
                // Reload
                await window.loadAuctions();
                await window.loadNFTsFromFirebase();
                window.switchTab('auctions');
                
            } catch (error) {
                console.error("‚ùå Auction creation error:", error);
                window.notify("Failed to create auction", "error");
            }
        };
        
        // Place bid
        window.placeBid = async (auctionId) => {
            if (!state.address) return window.notify("Connect wallet first", "error");
            
            const auction = state.auctions.find(a => a.id === auctionId);
            if (!auction) return window.notify("Auction not found", "error");
            
            // Show bid modal
            window.showBidModal(auction);
        };
        
        // Show bid modal
        window.showBidModal = (auction) => {
            const minBid = auction.currentBid + (auction.currentBid * 0.05); // 5% increment
            
            const modal = document.createElement('div');
            modal.id = 'bidModal';
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-view';
            modal.innerHTML = `
                <div class="glass-card p-8 max-w-md w-full space-y-6 border-2 border-cyan-500/30">
                    <h3 class="orbitron text-2xl text-cyan-400 font-bold uppercase">üíé Place Bid</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <div class="text-xs text-gray-500">NFT</div>
                            <div class="text-lg font-bold text-white">${auction.nftName}</div>
                        </div>
                        
                        <div>
                            <div class="text-xs text-gray-500">Current Bid</div>
                            <div class="text-xl font-bold text-cyan-400">${auction.currentBid} KTA</div>
                        </div>
                        
                        <div>
                            <label class="block text-xs orbitron text-gray-400 uppercase mb-2">Your Bid (KTA)</label>
                            <input type="number" id="bidAmount" value="${minBid.toFixed(2)}" min="${minBid}" step="0.1"
                                   class="w-full bg-black/60 border-2 border-cyan-500/30 p-3 rounded-lg text-white text-xl font-bold outline-none focus:border-cyan-500">
                            <div class="text-[10px] text-gray-600 mt-1">Minimum: ${minBid.toFixed(2)} KTA (5% above current)</div>
                        </div>
                        
                        <div class="bg-cyan-900/20 border-2 border-cyan-500/30 p-4 rounded-lg">
                            <div class="text-xs text-gray-400 space-y-1">
                                <div>‚Ä¢ Your balance: ${state.balanceKTA.toFixed(2)} KTA</div>
                                <div>‚Ä¢ If outbid, funds returned automatically</div>
                                <div>‚Ä¢ If you win, NFT transferred to you</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex gap-3">
                        <button onclick="document.getElementById('bidModal').remove()" 
                                class="flex-1 p-3 rounded-lg border border-white/10 text-gray-400 hover:bg-white/5 transition-all">
                            Cancel
                        </button>
                        <button onclick="window.confirmPlaceBid('${auction.id}')" 
                                class="flex-1 btn-primary p-3">
                            üíé Place Bid
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        // Confirm place bid
        window.confirmPlaceBid = async (auctionId) => {
            const bidAmount = parseFloat(document.getElementById('bidAmount')?.value || 0);
            
            const auction = state.auctions.find(a => a.id === auctionId);
            if (!auction) return window.notify("Auction not found", "error");
            
            const minBid = auction.currentBid + (auction.currentBid * 0.05);
            
            if (bidAmount < minBid) {
                return window.notify(`Bid must be at least ${minBid.toFixed(2)} KTA`, "error");
            }
            
            if (bidAmount > state.balanceKTA) {
                return window.notify("Insufficient KTA balance", "error");
            }
            
            try {
                window.notify("Placing bid...", "success");
                
                // Create bid record (FLAT path)
                const bidRef = doc(collection(db, 'bids'));
                await setDoc(bidRef, {
                    auctionId: auctionId,
                    bidder: state.address,
                    amount: bidAmount,
                    timestamp: new Date().toISOString(),
                    status: 'active'
                });
                
                // Update auction (FLAT path)
                await updateDoc(doc(db, 'auctions', auctionId), {
                    currentBid: bidAmount,
                    highestBidder: state.address,
                    bidCount: (auction.bidCount || 0) + 1
                });
                
                // If there was a previous bidder, mark their bid as outbid
                if (auction.highestBidder) {
                    const previousBidsQuery = query(
                        collection(db, 'bids'),
                        where('auctionId', '==', auctionId),
                        where('bidder', '==', auction.highestBidder),
                        where('status', '==', 'active')
                    );
                    const previousBids = await getDocs(previousBidsQuery);
                    previousBids.forEach(async (bidDoc) => {
                        await updateDoc(doc(db, 'bids', bidDoc.id), { status: 'outbid' });
                    });
                }
                
                document.getElementById('bidModal')?.remove();
                window.notify("‚úÖ Bid placed successfully!", "success");
                
                // Reload
                await window.loadAuctions();
                window.renderAuctions();
                
            } catch (error) {
                console.error("‚ùå Bid placement error:", error);
                window.notify("Failed to place bid", "error");
            }
        };
        
        // Cancel auction (only if no bids)
        window.cancelAuction = async (auctionId) => {
            const auction = state.auctions.find(a => a.id === auctionId);
            if (!auction) return window.notify("Auction not found", "error");
            
            if (auction.bidCount > 0) {
                return window.notify("Cannot cancel auction with bids", "error");
            }
            
            const confirmed = await window.showCustomConfirm({
                icon: 'üóëÔ∏è',
                title: 'Cancel Auction',
                message: `Cancel auction for ${auction.nftName}?\n\nThe NFT will be returned to your wallet.`,
                confirmText: 'üóëÔ∏è Yes, Cancel Auction',
                danger: true
            });
            
            if (!confirmed) return;
            
            try {
                window.notify("Cancelling auction...", "success");
                
                // Update auction status (FLAT path)
                await updateDoc(doc(db, 'auctions', auctionId), {
                    status: 'cancelled'
                });
                
                // Update NFT (FLAT path)
                await updateDoc(doc(db, 'nfts', auction.nftId), {
                    inAuction: false,
                    auctionId: null
                });
                
                window.notify("‚úÖ Auction cancelled", "success");
                
                // Reload
                await window.loadAuctions();
                await window.loadNFTsFromFirebase();
                window.renderAuctions();
                
            } catch (error) {
                console.error("‚ùå Auction cancel error:", error);
                window.notify("Failed to cancel auction", "error");
            }
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // COLLECTION VERIFICATION SYSTEM (Admin Only)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Verify collection (escrow wallet only)
        window.verifyCollection = async (collectionId) => {
            if (!state.address || state.address !== ESCROW_WALLET) {
                return window.notify("Only escrow wallet can verify collections", "error");
            }
            
            const confirmed = await window.showCustomConfirm({
                icon: '‚úÖ',
                title: 'Verify Collection',
                message: 'Mark this collection as verified?\n\nThis adds a blue checkmark badge to show authenticity.',
                confirmText: '‚úÖ Verify Collection',
                danger: false
            });
            
            if (!confirmed) return;
            
            try {
                await updateDoc(doc(db, 'collections', collectionId), {
                    verified: true,
                    verifiedAt: new Date().toISOString(),
                    verifiedBy: state.address
                });
                
                window.notify("‚úÖ Collection verified!", "success");
                await window.loadCollections();
                
            } catch (error) {
                console.error("‚ùå Verification error:", error);
                window.notify("Failed to verify collection", "error");
            }
        };
        
        // Unverify collection (escrow wallet only)
        window.unverifyCollection = async (collectionId) => {
            if (!state.address || state.address !== ESCROW_WALLET) {
                return window.notify("Only escrow wallet can manage verification", "error");
            }
            
            const confirmed = await window.showCustomConfirm({
                icon: '‚ö†Ô∏è',
                title: 'Remove Verification',
                message: 'Remove verification badge from this collection?',
                confirmText: 'üóëÔ∏è Remove Badge',
                danger: true
            });
            
            if (!confirmed) return;
            
            try {
                await updateDoc(doc(db, 'collections', collectionId), {
                    verified: false
                });
                
                window.notify("‚úÖ Verification removed", "success");
                await window.loadCollections();
                
            } catch (error) {
                console.error("‚ùå Unverify error:", error);
                window.notify("Failed to remove verification", "error");
            }
        };
        
        // Populate verification collection selector
        window.populateVerificationSelector = () => {
            const selector = document.getElementById('verifyCollectionSelector');
            if (!selector) return;
            
            selector.innerHTML = '<option value="">-- Select a Collection --</option>';
            state.collections.forEach(col => {
                const option = document.createElement('option');
                option.value = col.collectionId;
                option.textContent = `${col.collectionTitle}${col.verified ? ' ‚úÖ' : ''}`;
                selector.appendChild(option);
            });
        };
        
        // Handle verification selector change
        window.setupVerificationPanel = () => {
            const selector = document.getElementById('verifyCollectionSelector');
            const controls = document.getElementById('verificationControls');
            const verifyBtn = document.getElementById('verifyBtn');
            const unverifyBtn = document.getElementById('unverifyBtn');
            
            if (selector) {
                selector.addEventListener('change', (e) => {
                    const collectionId = e.target.value;
                    if (collectionId && controls) {
                        const collection = state.collections.find(c => c.collectionId === collectionId);
                        controls.classList.remove('hidden');
                        
                        if (collection && collection.verified) {
                            verifyBtn?.classList.add('opacity-50', 'pointer-events-none');
                            unverifyBtn?.classList.remove('opacity-50', 'pointer-events-none');
                        } else {
                            verifyBtn?.classList.remove('opacity-50', 'pointer-events-none');
                            unverifyBtn?.classList.add('opacity-50', 'pointer-events-none');
                        }
                    } else {
                        controls?.classList.add('hidden');
                    }
                });
            }
        };
        
        // Verify from panel
        window.verifyCollectionFromPanel = async () => {
            const collectionId = document.getElementById('verifyCollectionSelector')?.value;
            if (!collectionId) return window.notify("Select a collection first", "error");
            await window.verifyCollection(collectionId);
            window.populateVerificationSelector();
        };
        
        // Unverify from panel
        window.unverifyCollectionFromPanel = async () => {
            const collectionId = document.getElementById('verifyCollectionSelector')?.value;
            if (!collectionId) return window.notify("Select a collection first", "error");
            await window.unverifyCollection(collectionId);
            window.populateVerificationSelector();
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // COMMENTS SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Load comments for NFT
        window.loadComments = async (nftId) => {
            try {
                const commentsQuery = query(
                    collection(db, 'comments'),
                    where('nftId', '==', nftId),
                    orderBy('timestamp', 'desc')
                );
                
                const snapshot = await getDocs(commentsQuery);
                const comments = [];
                
                snapshot.forEach(doc => {
                    comments.push({ id: doc.id, ...doc.data() });
                });
                
                state.comments[nftId] = comments;
                console.log(`‚úÖ Loaded ${comments.length} comments for NFT ${nftId}`);
                return comments;
                
            } catch (error) {
                console.error("‚ùå Error loading comments:", error);
                return [];
            }
        };
        
        // Post comment
        // Post comment from collection page inline input
        window.postCollectionComment = async () => {
            const input = document.getElementById('collectionCommentInput');
            if (!input) return;
            
            const text = input.value.trim();
            if (!text) {
                window.notify('Please enter a comment', 'error');
                return;
            }
            
            if (!state.address) {
                window.notify('Please connect wallet to comment', 'error');
                return;
            }
            
            if (!state.viewingCollection) {
                window.notify('No collection selected', 'error');
                return;
            }
            
            const nftId = 'collection_' + state.viewingCollection;
            
            try {
                await window.postComment(nftId, text);
                input.value = ''; // Clear input
                // Reload comments
                await window.loadComments(nftId);
                window.renderCollectionComments(nftId);
            } catch (error) {
                console.error('Error posting collection comment:', error);
                window.notify('Failed to post comment', 'error');
            }
        };
        
        // Render comments on collection page
        window.renderCollectionComments = (nftId) => {
            const container = document.getElementById('collectionCommentsList');
            const countElement = document.getElementById('commentCount');
            const inputSection = document.getElementById('commentInputSection');
            
            if (!container) return;
            
            // Show input if wallet connected
            if (inputSection && state.address) {
                inputSection.classList.remove('hidden');
            }
            
            const comments = state.comments[nftId] || [];
            
            // Update count
            if (countElement) {
                countElement.textContent = `(${comments.length} comment${comments.length !== 1 ? 's' : ''})`;
            }
            
            if (comments.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-12 text-gray-500 fira">
                        <span class="text-5xl mb-3 block">üí¨</span>
                        <p>No comments yet. Be the first to share your thoughts!</p>
                    </div>
                `;
                return;
            }
            
            // Render comments
            container.innerHTML = comments.map(comment => {
                const isAuthor = state.address && comment.author === state.address;
                const isAdmin = state.address === ESCROW_WALLET;
                const canDelete = isAuthor || isAdmin;
                
                const shortAddress = comment.author ? 
                    comment.author.substring(0, 12) + '...' + comment.author.substring(comment.author.length - 6) : 
                    'Anonymous';
                
                // Generate avatar color from address
                let avatarColor = '#00ffff';
                if (comment.author) {
                    const hash = comment.author.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const hue = hash % 360;
                    avatarColor = `hsl(${hue}, 70%, 60%)`;
                }
                
                return `
                    <div class="bg-black/40 border border-white/5 rounded-xl p-5 hover:border-cyan-500/20 transition-all">
                        <div class="flex items-start gap-4">
                            <!-- Avatar -->
                            <div class="w-12 h-12 rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0"
                                 style="background: linear-gradient(135deg, ${avatarColor}, ${avatarColor}88);">
                                ${comment.author ? comment.author.substring(6, 8).toUpperCase() : '??'}
                            </div>
                            
                            <!-- Comment Content -->
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center gap-2 mb-2">
                                    <span class="font-bold text-sm text-cyan-400 fira">${shortAddress}</span>
                                    ${isAuthor ? '<span class="bg-purple-500/20 text-purple-400 px-2 py-0.5 rounded text-[10px] font-bold uppercase">YOU</span>' : ''}
                                    <span class="text-xs text-gray-500 fira">${window.getTimeAgo(new Date(comment.timestamp))}</span>
                                </div>
                                <p class="text-white text-sm fira break-words">${window.escapeHtml(comment.text)}</p>
                            </div>
                            
                            <!-- Delete Button -->
                            ${canDelete ? `
                                <button onclick="window.deleteComment('${comment.id}', '${nftId}')" 
                                        class="text-gray-500 hover:text-red-400 transition-colors p-2">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                    </svg>
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        };
        
        window.postComment = async (nftId, text) => {
            if (!state.address) return window.notify("Connect wallet to comment", "error");
            if (!text || text.trim().length === 0) return window.notify("Comment cannot be empty", "error");
            if (text.length > 500) return window.notify("Comment too long (max 500 characters)", "error");
            
            try {
                const commentRef = doc(collection(db, 'comments'));
                await setDoc(commentRef, {
                    nftId: nftId,
                    author: state.address,
                    text: text.trim(),
                    timestamp: new Date().toISOString(),
                    likes: 0
                });
                
                window.notify("‚úÖ Comment posted!", "success");
                await window.loadComments(nftId);
                window.renderComments(nftId);
                
            } catch (error) {
                console.error("‚ùå Error posting comment:", error);
                window.notify("Failed to post comment", "error");
            }
        };
        
        // Delete comment (author or admin only)
        window.deleteComment = async (commentId, nftId, authorAddress) => {
            if (!state.address) return;
            
            // Only author or escrow wallet can delete
            if (state.address !== authorAddress && state.address !== ESCROW_WALLET) {
                return window.notify("You can only delete your own comments", "error");
            }
            
            const confirmed = await window.showCustomConfirm({
                icon: 'üóëÔ∏è',
                title: 'Delete Comment',
                message: 'Delete this comment permanently?',
                confirmText: 'üóëÔ∏è Delete',
                danger: true
            });
            
            if (!confirmed) return;
            
            try {
                await deleteDoc(doc(db, 'comments', commentId));
                window.notify("‚úÖ Comment deleted", "success");
                await window.loadComments(nftId);
                window.renderComments(nftId); // Refresh widget
                window.renderCollectionComments(nftId); // Refresh inline section
                
            } catch (error) {
                console.error("‚ùå Error deleting comment:", error);
                window.notify("Failed to delete comment", "error");
            }
        };
        
        // Render comments in floating widget
        window.renderComments = (nftId) => {
            const container = document.getElementById('commentWidgetMessages');
            if (!container) return;
            
            const comments = state.comments[nftId] || [];
            
            if (comments.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-12 text-gray-500 fira text-sm">
                        <span class="text-4xl mb-2 block">üí¨</span>
                        No comments yet<br/>
                        <span class="text-xs">Be the first to comment!</span>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = comments.map(comment => {
                const date = new Date(comment.timestamp);
                const timeAgo = window.getTimeAgo(date);
                const shortAddress = comment.author.substring(0, 8) + '...' + comment.author.substring(comment.author.length - 4);
                const isAuthor = comment.author === state.address;
                const isAdmin = state.address === ESCROW_WALLET;
                
                return `
                    <div class="bg-gradient-to-br from-gray-800/50 to-gray-900/50 border ${isAuthor ? 'border-cyan-500/30' : 'border-white/5'} rounded-lg p-3 space-y-2 hover:border-cyan-500/20 transition-all">
                        <div class="flex justify-between items-start">
                            <div class="flex items-center gap-2">
                                <div class="w-8 h-8 bg-gradient-to-br from-purple-500 to-pink-500 rounded-full flex items-center justify-center text-xs font-bold">
                                    ${comment.author.substring(6, 8).toUpperCase()}
                                </div>
                                <div>
                                    <div class="font-mono text-xs text-cyan-400">${shortAddress}</div>
                                    <div class="text-[10px] text-gray-500">${timeAgo}</div>
                                </div>
                                ${isAuthor ? '<span class="text-[8px] bg-purple-500/20 text-purple-400 px-2 py-0.5 rounded orbitron font-bold ml-2">YOU</span>' : ''}
                            </div>
                            ${(isAuthor || isAdmin) ? `
                                <button onclick="window.deleteComment('${comment.id}', '${nftId}', '${comment.author}')" 
                                        class="text-red-400 hover:text-red-300 text-xs p-1 hover:bg-red-500/10 rounded transition-all"
                                        title="Delete comment">
                                    üóëÔ∏è
                                </button>
                            ` : ''}
                        </div>
                        <p class="text-sm text-white fira pl-10">${window.escapeHtml(comment.text)}</p>
                    </div>
                `;
            }).join('');
            
            // Auto-scroll to bottom
            container.scrollTop = container.scrollHeight;
            
            // Update badge
            const badge = document.getElementById('commentBadge');
            if (badge && comments.length > 0) {
                badge.textContent = comments.length;
                badge.classList.remove('hidden');
            }
        };
        
        // Toggle comment widget
        window.toggleCommentWidget = () => {
            const panel = document.getElementById('commentWidgetPanel');
            const toggle = document.getElementById('commentWidgetToggle');
            
            if (panel.classList.contains('hidden')) {
                // Show panel, hide button
                panel.classList.remove('hidden');
                toggle.classList.add('hidden');
                
                // Populate dropdown
                window.populateCommentCollectionDropdown();
                
                // If no collection loaded yet, load comments for current collection
                if (!state.currentCommentTarget && state.viewingCollection) {
                    const col = state.collections.find(c => c.collectionId === state.viewingCollection);
                    window.openCommentWidget(state.viewingCollection, col?.collectionTitle || 'Collection');
                }
            } else {
                // Hide panel, show button
                panel.classList.add('hidden');
                toggle.classList.remove('hidden');
            }
        };
        
        // Minimize widget
        window.minimizeCommentWidget = () => {
            const panel = document.getElementById('commentWidgetPanel');
            const toggle = document.getElementById('commentWidgetToggle');
            panel.classList.add('hidden');
            toggle.classList.remove('hidden');
        };
        
        // Close widget (just minimizes)
        window.closeCommentWidget = () => {
            const panel = document.getElementById('commentWidgetPanel');
            const toggle = document.getElementById('commentWidgetToggle');
            panel.classList.add('hidden');
            toggle.classList.remove('hidden');
            state.commentWidgetOpen = false;
        };
        
        // Open widget for collection
        window.openCommentWidget = (collectionId, collectionName) => {
            const widget = document.getElementById('commentWidget');
            const toggle = document.getElementById('commentWidgetToggle');
            const panel = document.getElementById('commentWidgetPanel');
            
            // Show widget container
            widget.classList.remove('hidden');
            
            // Show panel, hide toggle button
            toggle.classList.add('hidden');
            panel.classList.remove('hidden');
            
            // Populate dropdown with all collections
            window.populateCommentCollectionDropdown();
            
            // Select current collection
            const selector = document.getElementById('commentCollectionSelector');
            if (selector && collectionId) {
                selector.value = collectionId;
            }
            
            state.currentCommentTarget = 'collection_' + collectionId;
            state.commentWidgetOpen = true;
            
            // Load comments
            if (collectionId) {
                window.loadComments('collection_' + collectionId).then(() => {
                    window.renderComments('collection_' + collectionId);
                });
            }
        };
        
        // Populate comment collection dropdown
        window.populateCommentCollectionDropdown = () => {
            const selector = document.getElementById('commentCollectionSelector');
            if (!selector || !state.collections || state.collections.length === 0) return;
            
            selector.innerHTML = '<option value="">-- Select Collection --</option>';
            
            state.collections.forEach(col => {
                const option = document.createElement('option');
                option.value = col.collectionId;
                option.textContent = col.collectionTitle || col.collection || 'Unknown';
                selector.appendChild(option);
            });
        };
        
        // Switch to different collection's comments
        window.switchCommentCollection = (collectionId) => {
            if (!collectionId) {
                // Clear comments
                const container = document.getElementById('commentWidgetMessages');
                if (container) {
                    container.innerHTML = `
                        <div class="text-center py-12 text-gray-500 fira text-sm">
                            <span class="text-4xl mb-2 block">üí¨</span>
                            Select a collection to view comments
                        </div>
                    `;
                }
                state.currentCommentTarget = null;
                return;
            }
            
            state.currentCommentTarget = 'collection_' + collectionId;
            
            // Load and render comments for selected collection
            window.loadComments('collection_' + collectionId).then(() => {
                window.renderComments('collection_' + collectionId);
            });
        };
        
        // Send comment from widget
        window.sendCommentFromWidget = async () => {
            const input = document.getElementById('commentWidgetTextInput');
            const text = input?.value?.trim();
            
            if (!text) return;
            if (!state.currentCommentTarget) {
                window.notify("No collection selected", "error");
                return;
            }
            
            await window.postComment(state.currentCommentTarget, text);
            input.value = '';
        };
        
        // Helper: Escape HTML
        window.escapeHtml = (text) => {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        };
        
        // Helper: Time ago
        window.getTimeAgo = (date) => {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            const intervals = {
                year: 31536000,
                month: 2592000,
                week: 604800,
                day: 86400,
                hour: 3600,
                minute: 60
            };
            
            for (const [unit, secondsInUnit] of Object.entries(intervals)) {
                const interval = Math.floor(seconds / secondsInUnit);
                if (interval >= 1) {
                    return `${interval} ${unit}${interval > 1 ? 's' : ''} ago`;
                }
            }
            
            return 'Just now';
        };

        // Call initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => initializeMarketplace());
        } else {
            initializeMarketplace();
        }
        
    </script>
<!-- OFFER MODAL -->
<div id="offerModal" class="listing-modal-overlay hidden">
    <div class="glass-card p-12 max-w-3xl w-full border-cyan-500/20 shadow-2xl">
        <div class="flex justify-between items-start mb-8">
            <div>
                <h2 class="orbitron text-2xl font-black uppercase text-cyan-400 tracking-tighter">Make an Offer</h2>
                <p id="offerModalSubtitle" class="fira text-xs text-gray-500 mt-2">Propose a price to the NFT owner</p>
            </div>
            <button onclick="window.closeOfferModal()" class="text-gray-500 hover:text-white transition-colors">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="grid grid-cols-2 gap-8 mb-8">
            <div>
                <div id="offerNFTPreview" class="w-full aspect-square bg-black/40 rounded-xl border border-white/10 mb-4 overflow-hidden"></div>
                <h3 id="offerNFTName" class="orbitron text-lg font-bold text-white mb-2">---</h3>
                <div class="space-y-1">
                    <div class="fira text-xs text-gray-400">Owner: <span id="offerNFTOwner" class="text-cyan-400 font-mono">---</span></div>
                    <div class="fira text-xs text-gray-400">Listed: <span id="offerNFTListed" class="text-green-400">---</span></div>
                </div>
            </div>
            <div class="space-y-6">
                <div>
                    <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Select Currency</label>
                    <div class="flex gap-3">
                        <label class="flex-1 cursor-pointer">
                            <input type="radio" name="offerCurrency" value="KTA" checked class="hidden peer" onchange="window.updateOfferSummary()">
                            <div class="p-4 rounded-lg border-2 border-cyan-500/30 bg-cyan-500/5 peer-checked:border-cyan-500 peer-checked:bg-cyan-500/20 transition-all text-center hover:border-cyan-500/50">
                                <div class="orbitron text-sm font-bold text-cyan-400">KTA</div>
                                <div class="fira text-[9px] text-gray-500 mt-1">Balance: <span id="offerKTABalance">0</span></div>
                            </div>
                        </label>
                        <label class="flex-1 cursor-pointer">
                            <input type="radio" name="offerCurrency" value="PUNKS" class="hidden peer" onchange="window.updateOfferSummary()">
                            <div class="p-4 rounded-lg border-2 border-magenta-500/30 bg-magenta-500/5 peer-checked:border-magenta-500 peer-checked:bg-magenta-500/20 transition-all text-center hover:border-magenta-500/50">
                                <div class="orbitron text-sm font-bold text-magenta-400">PUNKS</div>
                                <div class="fira text-[9px] text-gray-500 mt-1">Balance: <span id="offerPUNKSBalance">0</span></div>
                            </div>
                        </label>
                    </div>
                </div>
                <div>
                    <label class="block text-[9px] orbitron text-gray-500 uppercase font-black mb-2">Your Offer Amount</label>
                    <input type="number" id="offerAmountInput" step="0.1" min="0" placeholder="Enter amount..." class="w-full bg-black/60 border border-white/5 p-4 rounded-xl fira text-xl text-cyan-400 outline-none font-bold focus:border-cyan-500" oninput="window.updateOfferSummary()">
                </div>
                <div class="bg-black/40 p-4 rounded-xl border border-white/5">
                    <div class="text-[9px] orbitron text-gray-500 uppercase font-black mb-3">Offer Summary</div>
                    <div class="space-y-2 fira text-xs">
                        <div class="flex justify-between"><span class="text-gray-400">Your offer</span><span id="offerTotal" class="text-white font-bold">0.00 KTA</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">Valid for</span><span class="text-cyan-400 font-bold">7 days</span></div>
                    </div>
                </div>
                <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-3">
                    <div class="flex items-start gap-2">
                        <span class="text-yellow-500 text-sm">üí°</span>
                        <p class="fira text-[9px] text-yellow-200">Offer will be visible to the NFT owner who can accept or decline it.</p>
                    </div>
                </div>
                <button onclick="window.submitOffer()" class="btn-primary w-full py-4 text-sm">Submit Offer</button>
            </div>
        </div>
    </div>
</div>

<!-- Floating Comment Widget -->
<div id="commentWidget" class="fixed bottom-6 right-6 z-40">
    <!-- Widget Toggle Button (when minimized) -->
    <button id="commentWidgetToggle" onclick="window.toggleCommentWidget()" 
            class="w-16 h-16 bg-gradient-to-br from-purple-600 to-pink-600 rounded-full shadow-2xl flex items-center justify-center hover:scale-110 transition-all border-2 border-white/20">
        <span class="text-2xl">üí¨</span>
        <span id="commentBadge" class="absolute -top-1 -right-1 bg-red-500 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center hidden">0</span>
    </button>
    
    <!-- Widget Panel (when expanded) -->
    <div id="commentWidgetPanel" class="hidden flex flex-col bg-gradient-to-br from-gray-900 to-black border-2 border-cyan-500/30 rounded-2xl shadow-2xl w-96 h-[600px] overflow-hidden">
        <!-- Header -->
        <div class="bg-gradient-to-r from-purple-900/40 to-pink-900/40 p-4 border-b border-white/10">
            <div class="flex justify-between items-center mb-3">
                <div class="flex items-center gap-3">
                    <span class="text-2xl">üí¨</span>
                    <h4 class="orbitron text-sm font-bold text-white">Collection Chat</h4>
                </div>
                <div class="flex items-center gap-2">
                    <button onclick="window.minimizeCommentWidget()" 
                            class="text-gray-400 hover:text-white p-1 transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    <button onclick="window.closeCommentWidget()" 
                            class="text-gray-400 hover:text-red-400 p-1 transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Collection Selector Dropdown -->
            <select id="commentCollectionSelector" 
                    onchange="window.switchCommentCollection(this.value)"
                    class="w-full bg-black/60 border border-cyan-500/30 rounded-lg px-3 py-2 text-white text-xs fira outline-none focus:border-cyan-500">
                <option value="">-- Select Collection --</option>
            </select>
        </div>
        
        <!-- Comments List (scrollable history) -->
        <div id="commentWidgetMessages" class="flex-1 overflow-y-auto p-4 space-y-3 bg-black/40">
            <div class="text-center py-12 text-gray-500 fira text-sm">
                <span class="text-4xl mb-2 block">üí¨</span>
                No comments yet
            </div>
        </div>
        
        <!-- Input Area -->
        <div id="commentWidgetInput" class="p-4 bg-gradient-to-r from-gray-900/80 to-black/80 border-t border-white/10">
            <div class="flex gap-2">
                <input type="text" 
                       id="commentWidgetTextInput" 
                       placeholder="Type your comment..." 
                       maxlength="500"
                       class="flex-1 bg-black/60 border-2 border-cyan-500/30 rounded-lg px-3 py-2 text-white text-sm outline-none focus:border-cyan-500"
                       onkeypress="if(event.key==='Enter') window.sendCommentFromWidget()">
                <button onclick="window.sendCommentFromWidget()" 
                        class="bg-cyan-500/20 border-2 border-cyan-500/50 text-cyan-400 px-4 rounded-lg orbitron font-bold hover:bg-cyan-500/30 transition-all">
                    Send
                </button>
            </div>
            <div class="text-xs text-gray-500 mt-2 fira">Press Enter to send ‚Ä¢ Max 500 chars</div>
        </div>
    </div>
</div>

<!-- Custom Confirmation Modal -->
<div id="customConfirmModal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
    <div class="bg-gradient-to-br from-gray-900 to-black border-2 border-cyan-500/30 rounded-2xl p-8 max-w-md w-full shadow-[0_0_50px_rgba(0,255,255,0.3)] animate-view">
        <div class="text-center mb-6">
            <div class="text-6xl mb-4" id="confirmModalIcon">‚ö†Ô∏è</div>
            <h3 class="orbitron text-2xl font-black text-white mb-2" id="confirmModalTitle">Confirm Action</h3>
            <p class="fira text-sm text-gray-400" id="confirmModalMessage">Are you sure you want to proceed?</p>
        </div>
        
        <div class="space-y-3">
            <button id="confirmModalConfirm" class="w-full py-4 rounded-xl orbitron font-bold text-sm transition-all">
                Confirm
            </button>
            <button id="confirmModalCancel" class="w-full py-4 rounded-xl bg-gray-700/30 border border-gray-600/30 text-gray-300 hover:bg-gray-700/50 orbitron font-bold text-sm transition-all">
                Cancel
            </button>
        </div>
    </div>
</div>

</body>
</html>
